[{"categories":["重构驱动学习"],"content":"分离 我们想实现如下效果： 领导层定义，不同业务线的错误码，也是错误码的前几位 不同业务线的开发，定义自己内部的错误码，也就是错误码后面的 如果领导层调整不同业务线的错误码，业务线的同事不受影响（领导层文化喜欢改动这些，你懂的） 那么既然要达到如上效果，就需要我们去分离这两个码。 package com.baidu; import lombok.Getter; import lombok.ToString; /** * 老板负责定义大的方向，业务方向的错误码前缀 */ interface CommonErrorCode { // 系统错误码 public final String PREFIX_ERROR_CODE_SYSTEM = \"100\"; // 会员错误码 public final String PREFIX_ERROR_CODE_MEMBER = \"200\"; // 商城错误码 public final String PREFIX_ERROR_CODE_SHOP = \"300\"; } /** * 会员领域负责定义本领域的错误码 */ @ToString enum MemberErrorCode implements CommonErrorCode { OK(\"0\", \"ok\"), FAIL_MEMBER_INVALID(\"3001\", \"会员已过期\"), FAIL_MEMBER_BLOCK(\"3002\", \"会员被冻结\"), FAIL_MEMBER_NOT_FOUND(\"3003\", \"会员不存在\"); MemberErrorCode(String code, String msg) { this.code = String.format(\"%s%s\", PREFIX_ERROR_CODE_MEMBER, code); this.msg = msg; } @Getter private final String code; @Getter private final String msg; } System.out.println(MemberErrorCode.FAIL_MEMBER_BLOCK); System.out.println(MemberErrorCode.FAIL_MEMBER_NOT_FOUND); 输出结果： MemberErrorCode.FAIL_MEMBER_BLOCK(code=2003002, msg=会员被冻结) MemberErrorCode.FAIL_MEMBER_NOT_FOUND(code=2003003, msg=会员不存在) ","date":"2023-07-15","objectID":"/posts/java%E8%80%81%E5%8F%B8%E6%9C%BA/%E9%87%8D%E6%9E%84%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0/%E4%B8%8D%E5%90%8C%E4%B8%9A%E5%8A%A1%E7%BA%BF%E7%9A%84%E9%94%99%E8%AF%AF%E7%A0%81%E7%BB%9F%E4%B8%80/:1:0","tags":["错误码","错误","重构"],"title":"不同业务线的错误码统一规划","uri":"/posts/java%E8%80%81%E5%8F%B8%E6%9C%BA/%E9%87%8D%E6%9E%84%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0/%E4%B8%8D%E5%90%8C%E4%B8%9A%E5%8A%A1%E7%BA%BF%E7%9A%84%E9%94%99%E8%AF%AF%E7%A0%81%E7%BB%9F%E4%B8%80/"},{"categories":["PHP提高"],"content":"字符串初始化尽量使用单引号 单引号不需要检查解析字符串中的变量，效率高于双引号。就类似别人告诉不需要线程安全的场景下，变长字符串让你使用 StringBuilder 而不是 String 一个道理。 ","date":"2023-07-15","objectID":"/posts/php/%E9%AB%98%E6%95%88%E5%9C%B0%E4%BD%BF%E7%94%A8php/:1:0","tags":["php","高效"],"title":"教你高效地使用PHP","uri":"/posts/php/%E9%AB%98%E6%95%88%E5%9C%B0%E4%BD%BF%E7%94%A8php/"},{"categories":["PHP提高"],"content":"过长 SQL 定义尽量使用 heredoc ","date":"2023-07-15","objectID":"/posts/php/%E9%AB%98%E6%95%88%E5%9C%B0%E4%BD%BF%E7%94%A8php/:2:0","tags":["php","高效"],"title":"教你高效地使用PHP","uri":"/posts/php/%E9%AB%98%E6%95%88%E5%9C%B0%E4%BD%BF%E7%94%A8php/"},{"categories":["PHP提高"],"content":"区别 Heredoc 类似双引号，解析变量 $userId = 123; $sql = \u003c\u003c\u003cEOT select id from user where user_id = $userId limit 1 EOT; // PHP 5.3.0 开始支持双引号 $userId = 123; $sql = \u003c\u003c\u003c\"EOT\" select id from user where user_id = $userId limit 1 EOT; 输出结果： select id from user where user_id = 123 limit 1 Nowdoc 类似单引号，不解析变量 PHP 5.3.0 版本开始增加 Nowdoc $userId = 123; $sql = \u003c\u003c\u003c'EOT' select id from user where user_id = $userId limit 1 EOT; 输出结果： select id from user where user_id = $userId limit 1 ","date":"2023-07-15","objectID":"/posts/php/%E9%AB%98%E6%95%88%E5%9C%B0%E4%BD%BF%E7%94%A8php/:2:1","tags":["php","高效"],"title":"教你高效地使用PHP","uri":"/posts/php/%E9%AB%98%E6%95%88%E5%9C%B0%E4%BD%BF%E7%94%A8php/"},{"categories":["PHP提高"],"content":"PHP 内置 Web 服务器 // 监听 ipv4 地址 php -S 0.0.0.0:80 -t web服务器目录 // 监听 ipv6 地址 php -S [::0]:80 -t web服务器目录 ","date":"2023-07-15","objectID":"/posts/php/%E9%AB%98%E6%95%88%E5%9C%B0%E4%BD%BF%E7%94%A8php/:3:0","tags":["php","高效"],"title":"教你高效地使用PHP","uri":"/posts/php/%E9%AB%98%E6%95%88%E5%9C%B0%E4%BD%BF%E7%94%A8php/"},{"categories":["PHP提高"],"content":"参考 https://www.php.net/manual/zh/features.commandline.webserver.php ","date":"2023-07-15","objectID":"/posts/php/%E9%AB%98%E6%95%88%E5%9C%B0%E4%BD%BF%E7%94%A8php/:3:1","tags":["php","高效"],"title":"教你高效地使用PHP","uri":"/posts/php/%E9%AB%98%E6%95%88%E5%9C%B0%E4%BD%BF%E7%94%A8php/"},{"categories":["Java基础"],"content":"反射真是无所不能，不仅能修改类常量，还能修改对象属性的访问权限。 ","date":"2023-07-12","objectID":"/posts/java%E5%9F%BA%E7%A1%80/java%E5%8F%8D%E5%B0%84/:0:0","tags":["java","反射"],"title":"Java反射应用","uri":"/posts/java%E5%9F%BA%E7%A1%80/java%E5%8F%8D%E5%B0%84/"},{"categories":["Java基础"],"content":"功能 反射有如下功能。 修改类常量，但是不能修改被基本类型类常量 引用类型类常量也不是全能修改，比如被字符串常量池初始化的字符串类常量，反射也不能修改。 修改对象属性的访问权限 ","date":"2023-07-12","objectID":"/posts/java%E5%9F%BA%E7%A1%80/java%E5%8F%8D%E5%B0%84/:1:0","tags":["java","反射"],"title":"Java反射应用","uri":"/posts/java%E5%9F%BA%E7%A1%80/java%E5%8F%8D%E5%B0%84/"},{"categories":["Java基础"],"content":"代码验证 // AppTest.java @Getter class User { // 被字符串常量池初始化的字符串常量，不可被反射修改 public final String name1 = \"maria\"; // 反射可修改 public final String name2 = new String(\"maria\"); // 反射可修改 public final String name3 = null; // 基本类型常量，反射不可修改 public final int age1 = 23; // 基本类型常量，反射可修改 public final int age2 = Integer.valueOf(23); // 被整型常量池初始化的整型常量，可被反射修改 public final Integer age3 = Integer.valueOf(23); // 整型常量，反射不可修改 public final Integer age4 = 23; // 反射不可改 public final char sex1 = 'm'; // 反射可修改 public final char sex2 = Character.valueOf('m'); // 反射可修改 public final Character sex3 = 'm'; // 反射可修改 public final Character sex4 = Character.valueOf('m'); } public class AppTest { @Test public void testReflect() throws NoSuchFieldException, IllegalAccessException { User user = new User(); Class\u003c? extends User\u003e aClass = user.getClass(); // 反射无法修改字符串常量池 Field name1 = aClass.getDeclaredField(\"name1\"); name1.setAccessible(true); name1.set(user, \"tom\"); Assert.assertEquals(\"maria\", user.getName1()); // 反射可修改非常量池初始化的字符串常量 Field name2 = aClass.getDeclaredField(\"name2\"); name2.setAccessible(true); name2.set(user, \"tom\"); Assert.assertEquals(\"tom\", user.getName2()); // 反射可修改被 null 初始化的常量 Field name3 = aClass.getDeclaredField(\"name3\"); name3.setAccessible(true); name3.set(user, \"tom\"); Assert.assertEquals(\"tom\", user.getName3()); // 反射不可修改基本类型常量 Field age1 = aClass.getDeclaredField(\"age1\"); age1.setAccessible(true); age1.set(user, 24); Assert.assertEquals(23, user.getAge1()); // 反射可以修改整型常量池初始化的常量 Field age2 = aClass.getDeclaredField(\"age2\"); age2.setAccessible(true); age2.set(user, 24); Assert.assertEquals(24, user.getAge2()); // 反射不可修改整型常量池初始化的基本类型常量 Field age3 = aClass.getDeclaredField(\"age3\"); age3.setAccessible(true); age3.set(user, 24); Assert.assertEquals(24, (int) user.getAge3()); // 可修改 Field age4 = aClass.getDeclaredField(\"age4\"); age3.setAccessible(true); age3.set(user, 24); Assert.assertEquals(23, (int) user.getAge4()); } } 看了是不是晕了，我来总结下。 直接赋值的，反射无法修改 public final Character sex3 = 'm'; 是个特例 ","date":"2023-07-12","objectID":"/posts/java%E5%9F%BA%E7%A1%80/java%E5%8F%8D%E5%B0%84/:1:1","tags":["java","反射"],"title":"Java反射应用","uri":"/posts/java%E5%9F%BA%E7%A1%80/java%E5%8F%8D%E5%B0%84/"},{"categories":["Java基础"],"content":"ChatGPT有话说 问：Java反射能修改被基本类型常量吗 答：在 Java 中，基本类型的变量是按值传递的，而不是按引用传递的。基本类型的常量是不可变的，它们的值在初始化后不能被修改。因此，Java 的反射机制无法直接修改基本类型的常量。 反射机制主要用于操作类的结构和对象的属性，包括访问和修改对象的字段、方法和构造函数等。但基本类型的常量不属于对象的属性，因此无法通过反射来修改它们的值。 如果你想修改一个常量的值，它应该是一个引用类型的常量，而不是基本类型的常量。对于引用类型的常量，可以使用反射来修改它们的属性值。但需要注意的是，修改常量的值可能会违反常量的定义和设计初衷，因此应该谨慎使用反射来修改常量的值。 问：Java反射能修改被字符串常量池初始化的字符串常量吗 答：在 Java 中，字符串常量池是一个特殊的内存区域，用于存储字符串常量。字符串常量池中的字符串是不可变的，一旦被初始化，它们的值不能被修改。 由于字符串常量池的特性，Java 的反射机制无法直接修改被字符串常量池初始化的字符串常量的值。无论是通过反射访问字段还是调用方法，都无法改变字符串常量的值。 需要注意的是，通过反射机制修改字符串常量的值是不被推荐的做法，因为字符串常量的不可变性是 Java 语言设计的一部分，它具有重要的语言特性和性能优化。修改字符串常量的值可能会导致意料之外的行为，并且违背了字符串常量的设计初衷。 如果你需要修改字符串的内容，可以使用可变的字符串类（如 StringBuilder 或 StringBuffer）来操作字符串，并根据需要进行修改。 ","date":"2023-07-12","objectID":"/posts/java%E5%9F%BA%E7%A1%80/java%E5%8F%8D%E5%B0%84/:2:0","tags":["java","反射"],"title":"Java反射应用","uri":"/posts/java%E5%9F%BA%E7%A1%80/java%E5%8F%8D%E5%B0%84/"},{"categories":["框架"],"content":"命令使用 ","date":"2023-07-11","objectID":"/posts/framework/%E6%95%B0%E6%8D%AE%E5%BA%93/redistemplate%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/:1:0","tags":["redis","数据库"],"title":"RedisTemplate框架使用","uri":"/posts/framework/%E6%95%B0%E6%8D%AE%E5%BA%93/redistemplate%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/"},{"categories":["框架"],"content":"查询哈希表 import org.springframework.data.redis.core.RedisTemplate; @Service @RequiredArgsConstructor public class UserService { private final RedisTemplate\u003cString, String\u003e redisTemplate; public getUserName(int userId) { // hashKey String hashKey = String.format(\"user_id_%d\", userId); String fieldName = \"name\"; Object userName = redisTemplate.opsForHash().get(hashKey, fieldName); return userName.toString(); } } ","date":"2023-07-11","objectID":"/posts/framework/%E6%95%B0%E6%8D%AE%E5%BA%93/redistemplate%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/:1:1","tags":["redis","数据库"],"title":"RedisTemplate框架使用","uri":"/posts/framework/%E6%95%B0%E6%8D%AE%E5%BA%93/redistemplate%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/"},{"categories":["Spring"],"content":"注解 @Autowired/@Resource 注入 @Autowired 默认按类型查找，当一个类型多个实现时，按名字找。按名字查找时，配合 @Qualifier 注解。 @Resource 默认按名字找，找不到时，按类型找。 public class IndexController { @Autowired private UserService userService; } 这种注入方式不容易理解，属性的可访问性是私有的，即无 set 方法，也无有参构造，那是如何从外部注入的呢？ Spring 再怎么玩的花，也不能脱离 Java 的语法限制。它在注入前，修改了私有属性的可访问性，然后再注入。 userService.setAccessible(true); ","date":"2023-07-11","objectID":"/posts/framework/spring/spring%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F/:1:0","tags":["spring","依赖注入","IOC"],"title":"Spring常见的3种自动注入方式","uri":"/posts/framework/spring/spring%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F/"},{"categories":["Spring"],"content":"setXXX方法注入 public class IndexController { private UserService userService; @Autowired public void setUserService(UserService userService) { this.userService = userService; } } ","date":"2023-07-11","objectID":"/posts/framework/spring/spring%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F/:2:0","tags":["spring","依赖注入","IOC"],"title":"Spring常见的3种自动注入方式","uri":"/posts/framework/spring/spring%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F/"},{"categories":["Spring"],"content":"有参构造方法注入 ","date":"2023-07-11","objectID":"/posts/framework/spring/spring%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F/:3:0","tags":["spring","依赖注入","IOC"],"title":"Spring常见的3种自动注入方式","uri":"/posts/framework/spring/spring%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F/"},{"categories":null,"content":"建立博客的目的 笔记留存和大家分享学习。 ","date":"2023-07-10","objectID":"/about/:1:0","tags":null,"title":"关于我","uri":"/about/"},{"categories":["规约"],"content":"数据库 枚举字段 枚举字段尽量使用能够描述业务，短小精悍的词语，不要为了那点性能使用 tinyint ，否则后面你就要识记那些 1，2，3，4，5 各代表什么业务含义了。 ","date":"2023-07-10","objectID":"/posts/java%E8%80%81%E5%8F%B8%E6%9C%BA/%E6%95%99%E8%AE%AD%E8%A7%84%E7%BA%A6/:1:0","tags":["教训","经验"],"title":"教训规约","uri":"/posts/java%E8%80%81%E5%8F%B8%E6%9C%BA/%E6%95%99%E8%AE%AD%E8%A7%84%E7%BA%A6/"},{"categories":["重构驱动学习"],"content":"今天阅读了他人代码，作者应该是想封装一个统一的错误码枚举类。这种需求大家应该都遇到过。 ","date":"2023-07-08","objectID":"/posts/java%E8%80%81%E5%8F%B8%E6%9C%BA/%E9%87%8D%E6%9E%84%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0/%E7%BB%9F%E4%B8%80%E9%94%99%E8%AF%AF%E7%A0%81%E7%9A%84%E9%94%99%E8%AF%AF%E6%B6%88%E6%81%AF%E8%8E%B7%E5%8F%96/:0:0","tags":["错误码","错误描述"],"title":"统一错误码如何追加具体业务错误描述","uri":"/posts/java%E8%80%81%E5%8F%B8%E6%9C%BA/%E9%87%8D%E6%9E%84%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0/%E7%BB%9F%E4%B8%80%E9%94%99%E8%AF%AF%E7%A0%81%E7%9A%84%E9%94%99%E8%AF%AF%E6%B6%88%E6%81%AF%E8%8E%B7%E5%8F%96/"},{"categories":["重构驱动学习"],"content":"常见封装 package com.baidu; import lombok.AllArgsConstructor; import lombok.Getter; @AllArgsConstructor public enum ErrorCode { OK(\"0\", \"ok\"), FAIL(\"1\", \"failed\"); @Getter private final String code; @Getter private final String msg; } 使用： ErrorCode.FAIL.getMsg(); 这种是最基本的错误统一码，但是不足以描述具体的错误异常。 ","date":"2023-07-08","objectID":"/posts/java%E8%80%81%E5%8F%B8%E6%9C%BA/%E9%87%8D%E6%9E%84%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0/%E7%BB%9F%E4%B8%80%E9%94%99%E8%AF%AF%E7%A0%81%E7%9A%84%E9%94%99%E8%AF%AF%E6%B6%88%E6%81%AF%E8%8E%B7%E5%8F%96/:1:0","tags":["错误码","错误描述"],"title":"统一错误码如何追加具体业务错误描述","uri":"/posts/java%E8%80%81%E5%8F%B8%E6%9C%BA/%E9%87%8D%E6%9E%84%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0/%E7%BB%9F%E4%B8%80%E9%94%99%E8%AF%AF%E7%A0%81%E7%9A%84%E9%94%99%E8%AF%AF%E6%B6%88%E6%81%AF%E8%8E%B7%E5%8F%96/"},{"categories":["重构驱动学习"],"content":"同事改造版 鉴于上面的统一错误异常同事对他进行了改造。 package com.baidu; import lombok.AllArgsConstructor; import lombok.Getter; @AllArgsConstructor public enum ErrorCode { OK(\"0\", \"ok\"), FAIL(\"1\", \"failed：%s\"); @Getter private final String code; @Getter private final String msg; } 使用： String.format(ErrorCode.FAIL.getMsg(), \"具体的业务错误描述\"); ","date":"2023-07-08","objectID":"/posts/java%E8%80%81%E5%8F%B8%E6%9C%BA/%E9%87%8D%E6%9E%84%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0/%E7%BB%9F%E4%B8%80%E9%94%99%E8%AF%AF%E7%A0%81%E7%9A%84%E9%94%99%E8%AF%AF%E6%B6%88%E6%81%AF%E8%8E%B7%E5%8F%96/:2:0","tags":["错误码","错误描述"],"title":"统一错误码如何追加具体业务错误描述","uri":"/posts/java%E8%80%81%E5%8F%B8%E6%9C%BA/%E9%87%8D%E6%9E%84%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0/%E7%BB%9F%E4%B8%80%E9%94%99%E8%AF%AF%E7%A0%81%E7%9A%84%E9%94%99%E8%AF%AF%E6%B6%88%E6%81%AF%E8%8E%B7%E5%8F%96/"},{"categories":["重构驱动学习"],"content":"优化版 看了他的代码，我觉得写的不够优雅，虽然功能实现了。 写了大量的 String.format。 package com.baidu; import lombok.Getter; public enum ErrorCode { OK(\"0\", \"ok\"), FAIL(\"1\", \"failed\"); @Getter private final String code; @Getter private final StringBuilder msg; ErrorCode(String code, String msg) { this.code = code; this.msg = new StringBuilder(msg); } } 使用： ErrorCode.FAIL.getMsg().append(\"：具体的业务错误描述\"); ","date":"2023-07-08","objectID":"/posts/java%E8%80%81%E5%8F%B8%E6%9C%BA/%E9%87%8D%E6%9E%84%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0/%E7%BB%9F%E4%B8%80%E9%94%99%E8%AF%AF%E7%A0%81%E7%9A%84%E9%94%99%E8%AF%AF%E6%B6%88%E6%81%AF%E8%8E%B7%E5%8F%96/:3:0","tags":["错误码","错误描述"],"title":"统一错误码如何追加具体业务错误描述","uri":"/posts/java%E8%80%81%E5%8F%B8%E6%9C%BA/%E9%87%8D%E6%9E%84%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0/%E7%BB%9F%E4%B8%80%E9%94%99%E8%AF%AF%E7%A0%81%E7%9A%84%E9%94%99%E8%AF%AF%E6%B6%88%E6%81%AF%E8%8E%B7%E5%8F%96/"},{"categories":["重构驱动学习"],"content":"对比 package com.baidu; import lombok.AllArgsConstructor; import lombok.Getter; import java.util.Objects; @AllArgsConstructor enum ErrorCode1 { OK(\"0\", \"ok\"), FAIL_PARAM(\"110\", \"参数缺失：%s\"); @Getter private final String code; @Getter private final String msg; } enum ErrorCode2 { OK(\"0\", \"ok\"), FAIL_PARAM(\"110\", \"参数缺失\"); ErrorCode2(String code, String msg) { this.code = code; this.msg = new StringBuilder(msg); } @Getter private final String code; @Getter private final StringBuilder msg; } public class ErrorCode { public static void main(String[] args) { String name = null; Integer age = null; // msg 使用占位符 if (Objects.isNull(name)) { String msg = String.format(ErrorCode1.FAIL_PARAM.getMsg(), \"姓名不能为空\"); System.out.println(msg); } if (Objects.isNull(age)) { String msg = String.format(ErrorCode1.FAIL_PARAM.getMsg(), \"年龄不能为空\"); System.out.println(msg); } // msg 使用 SB if (Objects.isNull(name)) { String msg = ErrorCode2.FAIL_PARAM.getMsg().append(\"：姓名不能为空\").toString(); System.out.println(msg); } if (Objects.isNull(age)) { String msg = ErrorCode2.FAIL_PARAM.getMsg().append(\"：年龄不能为空\").toString(); System.out.println(msg); } } } ","date":"2023-07-08","objectID":"/posts/java%E8%80%81%E5%8F%B8%E6%9C%BA/%E9%87%8D%E6%9E%84%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0/%E7%BB%9F%E4%B8%80%E9%94%99%E8%AF%AF%E7%A0%81%E7%9A%84%E9%94%99%E8%AF%AF%E6%B6%88%E6%81%AF%E8%8E%B7%E5%8F%96/:4:0","tags":["错误码","错误描述"],"title":"统一错误码如何追加具体业务错误描述","uri":"/posts/java%E8%80%81%E5%8F%B8%E6%9C%BA/%E9%87%8D%E6%9E%84%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0/%E7%BB%9F%E4%B8%80%E9%94%99%E8%AF%AF%E7%A0%81%E7%9A%84%E9%94%99%E8%AF%AF%E6%B6%88%E6%81%AF%E8%8E%B7%E5%8F%96/"},{"categories":["重构驱动学习"],"content":"输出结果有点问题 参数缺失：姓名不能为空 参数缺失：年龄不能为空 参数缺失：姓名不能为空 参数缺失：姓名不能为空：年龄不能为空 这个粘连错误消息的问题，可能需要解决。 ","date":"2023-07-08","objectID":"/posts/java%E8%80%81%E5%8F%B8%E6%9C%BA/%E9%87%8D%E6%9E%84%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0/%E7%BB%9F%E4%B8%80%E9%94%99%E8%AF%AF%E7%A0%81%E7%9A%84%E9%94%99%E8%AF%AF%E6%B6%88%E6%81%AF%E8%8E%B7%E5%8F%96/:4:1","tags":["错误码","错误描述"],"title":"统一错误码如何追加具体业务错误描述","uri":"/posts/java%E8%80%81%E5%8F%B8%E6%9C%BA/%E9%87%8D%E6%9E%84%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0/%E7%BB%9F%E4%B8%80%E9%94%99%E8%AF%AF%E7%A0%81%E7%9A%84%E9%94%99%E8%AF%AF%E6%B6%88%E6%81%AF%E8%8E%B7%E5%8F%96/"},{"categories":["工具"],"content":"常见报错 ","date":"2023-07-05","objectID":"/posts/%E5%B7%A5%E5%85%B7/hugo/:1:0","tags":["静态博客","hugo"],"title":"Hugo使用手册","uri":"/posts/%E5%B7%A5%E5%85%B7/hugo/"},{"categories":["工具"],"content":"you need the extended version to build SCSS/SASS 由于你使用了 hugo_0.114.1_windows-amd64，但是他不支持编译 SCSS/SASS，应该下载使用 hugo_extended_0.114.1_windows-amd64。 参考 Warning “you need the extended version to build SCSS/SASS“ not triggered when it should 的解决办法 ","date":"2023-07-05","objectID":"/posts/%E5%B7%A5%E5%85%B7/hugo/:1:1","tags":["静态博客","hugo"],"title":"Hugo使用手册","uri":"/posts/%E5%B7%A5%E5%85%B7/hugo/"},{"categories":["HTTP 协议"],"content":"常见状态码 ","date":"2023-07-04","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/http%E5%8D%8F%E8%AE%AE/:1:0","tags":["http","协议","计算机网络"],"title":"HTTP 协议","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/http%E5%8D%8F%E8%AE%AE/"},{"categories":["HTTP 协议"],"content":"499 Client Closed Request 这种情况通常是，服务端处理时间过长，超出客户端设置的最大等待时间，客户端主动关闭了连接。 ","date":"2023-07-04","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/http%E5%8D%8F%E8%AE%AE/:1:1","tags":["http","协议","计算机网络"],"title":"HTTP 协议","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/http%E5%8D%8F%E8%AE%AE/"},{"categories":["Java"],"content":"Java推荐操作 ","date":"2023-06-27","objectID":"/posts/java%E8%80%81%E5%8F%B8%E6%9C%BA/%E4%BC%98%E7%A7%80%E6%93%8D%E4%BD%9C/:0:0","tags":["java","新特性"],"title":"Java推荐操作","uri":"/posts/java%E8%80%81%E5%8F%B8%E6%9C%BA/%E4%BC%98%E7%A7%80%E6%93%8D%E4%BD%9C/"},{"categories":["Java"],"content":"判空 ","date":"2023-06-27","objectID":"/posts/java%E8%80%81%E5%8F%B8%E6%9C%BA/%E4%BC%98%E7%A7%80%E6%93%8D%E4%BD%9C/:1:0","tags":["java","新特性"],"title":"Java推荐操作","uri":"/posts/java%E8%80%81%E5%8F%B8%E6%9C%BA/%E4%BC%98%E7%A7%80%E6%93%8D%E4%BD%9C/"},{"categories":["Java"],"content":"不推荐用法 不推荐的原因是，不够语义化。 @Test public void npeMap() { HashMap\u003cString, HashMap\u003cString, String\u003e\u003e map = new HashMap\u003c\u003e(2); HashMap\u003cString, String\u003e hashMap = new HashMap\u003c\u003e(1); hashMap.put(\"country\", \"china\"); map.put(\"shali\", hashMap); if (null != map.get(\"shali\")) { HashMap\u003cString, String\u003e shali = map.get(\"shali\"); if (null != shali.get(\"country\")) { Assertions.assertEquals(\"china\", shali.get(\"country\")); } } } ","date":"2023-06-27","objectID":"/posts/java%E8%80%81%E5%8F%B8%E6%9C%BA/%E4%BC%98%E7%A7%80%E6%93%8D%E4%BD%9C/:1:1","tags":["java","新特性"],"title":"Java推荐操作","uri":"/posts/java%E8%80%81%E5%8F%B8%E6%9C%BA/%E4%BC%98%E7%A7%80%E6%93%8D%E4%BD%9C/"},{"categories":["Java"],"content":"推荐用法 @Test public void npeMap() { HashMap\u003cString, HashMap\u003cString, String\u003e\u003e map = new HashMap\u003c\u003e(2); HashMap\u003cString, String\u003e hashMap = new HashMap\u003c\u003e(1); hashMap.put(\"country\", \"china\"); map.put(\"shali\", hashMap); if (Objects.nonNull(map.get(\"shali\"))) { HashMap\u003cString, String\u003e shali = map.get(\"shali\"); if (Objects.nonNull(shali.get(\"country\"))) { Assertions.assertEquals(\"china\", shali.get(\"country\")); } } } ","date":"2023-06-27","objectID":"/posts/java%E8%80%81%E5%8F%B8%E6%9C%BA/%E4%BC%98%E7%A7%80%E6%93%8D%E4%BD%9C/:1:2","tags":["java","新特性"],"title":"Java推荐操作","uri":"/posts/java%E8%80%81%E5%8F%B8%E6%9C%BA/%E4%BC%98%E7%A7%80%E6%93%8D%E4%BD%9C/"},{"categories":["Java"],"content":"链式调用空指针检查Optional ","date":"2023-06-27","objectID":"/posts/java%E8%80%81%E5%8F%B8%E6%9C%BA/%E4%BC%98%E7%A7%80%E6%93%8D%E4%BD%9C/:2:0","tags":["java","新特性"],"title":"Java推荐操作","uri":"/posts/java%E8%80%81%E5%8F%B8%E6%9C%BA/%E4%BC%98%E7%A7%80%E6%93%8D%E4%BD%9C/"},{"categories":["Java"],"content":"错误用法 链式调用，存在 NullPointerException 的危险。 @Test(expected = NullPointerException.class) public void npeMap() { HashMap\u003cString, HashMap\u003cString, String\u003e\u003e map = new HashMap\u003c\u003e(2); HashMap\u003cString, String\u003e hashMap = new HashMap\u003c\u003e(1); hashMap.put(\"country\", \"china\"); map.put(\"shali\", hashMap); Assertions.assertEquals(\"china\", map.get(\"shali\").get(\"country\")); // 注解断言抛出空指针异常 NullPointerException Assertions.assertEquals(\"china\", map.get(\"tony\").get(\"country\")); } ","date":"2023-06-27","objectID":"/posts/java%E8%80%81%E5%8F%B8%E6%9C%BA/%E4%BC%98%E7%A7%80%E6%93%8D%E4%BD%9C/:2:1","tags":["java","新特性"],"title":"Java推荐操作","uri":"/posts/java%E8%80%81%E5%8F%B8%E6%9C%BA/%E4%BC%98%E7%A7%80%E6%93%8D%E4%BD%9C/"},{"categories":["Java"],"content":"正确用法 @Test public void npeMap() { HashMap\u003cString, HashMap\u003cString, String\u003e\u003e map = new HashMap\u003c\u003e(2); HashMap\u003cString, String\u003e hashMap = new HashMap\u003c\u003e(1); hashMap.put(\"country\", \"china\"); map.put(\"shali\", hashMap); Assertions.assertEquals(\"china\", Optional.ofNullable(map).map(mapper -\u003e mapper.get(\"shali\")).map(mapper -\u003e mapper.get(\"country\")).orElse(null)); // 此处不会抛 NullPointerException Assertions.assertNull(Optional.ofNullable(map).map(mapper -\u003e mapper.get(\"tony\")).map(mapper -\u003e mapper.get(\"country\")).orElse(null)); } ","date":"2023-06-27","objectID":"/posts/java%E8%80%81%E5%8F%B8%E6%9C%BA/%E4%BC%98%E7%A7%80%E6%93%8D%E4%BD%9C/:2:2","tags":["java","新特性"],"title":"Java推荐操作","uri":"/posts/java%E8%80%81%E5%8F%B8%E6%9C%BA/%E4%BC%98%E7%A7%80%E6%93%8D%E4%BD%9C/"},{"categories":["Java"],"content":"其他语言的链式判空操作 PHP8.0 PHP 8.0 引入了1个新特性，指针安全运算符。 string name = shali()?-\u003einfo()?-\u003ename(); ?-\u003e 就是指针安全运算符 null safe。 Kotlin kotlin 定义了 2 个语法糖，?. 不为 null 时的处理，?: 为 null 时的处理。 ?: 这个 PHP 使用者很熟悉，就是为空时的处理语法糖。 // 不为 null 时的操作 val files = File(\"Test\").listFiles() println(files?.size) // 不为 null 时的操作和为 null 时的操作 val files = File(\"Test\").listFiles() println(files?.size ?: \"empty\") Swift 跟 kotlin 很像，但是他还支持数组的元素的判断。 ","date":"2023-06-27","objectID":"/posts/java%E8%80%81%E5%8F%B8%E6%9C%BA/%E4%BC%98%E7%A7%80%E6%93%8D%E4%BD%9C/:2:3","tags":["java","新特性"],"title":"Java推荐操作","uri":"/posts/java%E8%80%81%E5%8F%B8%E6%9C%BA/%E4%BC%98%E7%A7%80%E6%93%8D%E4%BD%9C/"},{"categories":["Java"],"content":"返回值为集合的方法正确返回方式 ","date":"2023-06-27","objectID":"/posts/java%E8%80%81%E5%8F%B8%E6%9C%BA/%E4%BC%98%E7%A7%80%E6%93%8D%E4%BD%9C/:3:0","tags":["java","新特性"],"title":"Java推荐操作","uri":"/posts/java%E8%80%81%E5%8F%B8%E6%9C%BA/%E4%BC%98%E7%A7%80%E6%93%8D%E4%BD%9C/"},{"categories":["Java"],"content":"返回值List public List\u003cString\u003e getNumbers() { // 不建议 // return new ArrayList\u003c\u003e(); return Collections.emptyList(); } ","date":"2023-06-27","objectID":"/posts/java%E8%80%81%E5%8F%B8%E6%9C%BA/%E4%BC%98%E7%A7%80%E6%93%8D%E4%BD%9C/:3:1","tags":["java","新特性"],"title":"Java推荐操作","uri":"/posts/java%E8%80%81%E5%8F%B8%E6%9C%BA/%E4%BC%98%E7%A7%80%E6%93%8D%E4%BD%9C/"},{"categories":["Java"],"content":"返回Map public Map\u003cObject, Object\u003e getNumbers() { // 不建议 // return new HashMap\u003c\u003e(); return Collections.emptyMap(); } ","date":"2023-06-27","objectID":"/posts/java%E8%80%81%E5%8F%B8%E6%9C%BA/%E4%BC%98%E7%A7%80%E6%93%8D%E4%BD%9C/:3:2","tags":["java","新特性"],"title":"Java推荐操作","uri":"/posts/java%E8%80%81%E5%8F%B8%E6%9C%BA/%E4%BC%98%E7%A7%80%E6%93%8D%E4%BD%9C/"},{"categories":["Java"],"content":"返回Set public Set\u003cString\u003e getNumbers() { // 不建议 // return new HashSet\u003c\u003e(); return Collections.emptySet(); } ","date":"2023-06-27","objectID":"/posts/java%E8%80%81%E5%8F%B8%E6%9C%BA/%E4%BC%98%E7%A7%80%E6%93%8D%E4%BD%9C/:3:3","tags":["java","新特性"],"title":"Java推荐操作","uri":"/posts/java%E8%80%81%E5%8F%B8%E6%9C%BA/%E4%BC%98%E7%A7%80%E6%93%8D%E4%BD%9C/"},{"categories":["PHP"],"content":"?? $name = null; $name = isset($name) ? $name : ''; 等效： $name = null; $name = $name ?? ''; ","date":"2023-06-27","objectID":"/posts/php/php8%E6%96%B0%E7%89%B9%E6%80%A7/:1:0","tags":["PHP8.0","空指针异常"],"title":"PHP8.0引入nullsafe","uri":"/posts/php/php8%E6%96%B0%E7%89%B9%E6%80%A7/"},{"categories":["PHP"],"content":"?: $name = ' '; $name = empty($name) ? '' : $name; 等效： $name = ' '; $name = $name ?: ''; ","date":"2023-06-27","objectID":"/posts/php/php8%E6%96%B0%E7%89%B9%E6%80%A7/:2:0","tags":["PHP8.0","空指针异常"],"title":"PHP8.0引入nullsafe","uri":"/posts/php/php8%E6%96%B0%E7%89%B9%E6%80%A7/"},{"categories":["PHP"],"content":"问 chatgpt ","date":"2023-06-25","objectID":"/posts/php/array_multisort/:1:0","tags":["array","数组排序","集合排序"],"title":"PHP二维数组排序","uri":"/posts/php/array_multisort/"},{"categories":["PHP"],"content":"实践出真知 public function testArrayMultiSort() { $data1 = array( array('id' =\u003e 1, 'name' =\u003e 'Tom', 'age' =\u003e 25), array('id' =\u003e 2, 'name' =\u003e 'Alice', 'age' =\u003e 22), array('id' =\u003e 3, 'name' =\u003e 'Bob', 'age' =\u003e 27), ); $data2 = array( array('id' =\u003e 1, 'name' =\u003e 'Tom', 'age' =\u003e 25), array('id' =\u003e 2, 'name' =\u003e 'Alice', 'age' =\u003e 22), array('id' =\u003e 4, 'name' =\u003e 'Alice', 'age' =\u003e null), array('id' =\u003e 3, 'name' =\u003e 'Bob', 'age' =\u003e 27) ); $data3 = array( array('id' =\u003e 1, 'name' =\u003e 'Tom', 'age' =\u003e 25), array('id' =\u003e 2, 'name' =\u003e 'Alice', 'age' =\u003e 22), array('id' =\u003e 4, 'name' =\u003e 'Alice',), array('id' =\u003e 3, 'name' =\u003e 'Bob', 'age' =\u003e 27) ); $ages = array_column($data1, 'age'); array_multisort($ages, SORT_DESC, $data1); self::assertSame(27, $data1[0]['age']); $ages = array_column($data2, 'age'); array_multisort($ages, SORT_DESC, $data2); self::assertSame(27, $data2[0]['age']); $ages = array_column($data3, 'age'); array_multisort($ages, SORT_DESC, $data3); self::assertSame(25, $data3[0]['age']); self::assertSame(22, $data3[1]['age']); self::assertSame(27, $data3[3]['age']); } 使用 array_multisort 需要注意安全，当二维数组中没有指定的排序字段时，排序功能就失效了。 ","date":"2023-06-25","objectID":"/posts/php/array_multisort/:2:0","tags":["array","数组排序","集合排序"],"title":"PHP二维数组排序","uri":"/posts/php/array_multisort/"},{"categories":["PHP"],"content":"目录结构 ","date":"2023-06-13","objectID":"/posts/php/phpdephar/:1:0","tags":["php","phar","jar"],"title":"php工程归档文件phar的打包和运行","uri":"/posts/php/phpdephar/"},{"categories":["PHP"],"content":"phar归档文件构建脚本 \u003c?php // build.php // 打包的文件名 $pharFileName = 'hellophar.phar'; // 打包是追加模式，为了保证打包里内容最新，先删除之前的包 file_exists($pharFileName) \u0026\u0026 unlink($pharFileName); $phar = new Phar($pharFileName, 0, $pharFileName); $dir = dirname(__FILE__); // 打包 src 目录里面的内容，不包含 src 目录本身 $phar-\u003ebuildFromDirectory($dir . '/src'); // main.php 执行 .phar 文件时执行的，index.php web 服务器入口文件 $phar-\u003esetDefaultStub('main.php', 'index.php'); ","date":"2023-06-13","objectID":"/posts/php/phpdephar/:2:0","tags":["php","phar","jar"],"title":"php工程归档文件phar的打包和运行","uri":"/posts/php/phpdephar/"},{"categories":["PHP"],"content":"phar运行时的入口文件 入口文件类似我们 C 语言的 main.c ，Java 中的 main 方法。 \u003c?php // main.php // 加载工具方法文件 require 'function.php'; // phar 其实是一个压缩包，要执行必须解压，定义解压的目录 $path = sprintf('%s/pharextract/%s', Extract_Phar::tmpdir(), 'hellophar'); // 通常的解压路径：C:\\Users\\用户名\\AppData\\Local\\Temp\\pharextract\\phar项目名称 $path = realpath($path); // 为了方便了解应用被解压的目录，我们打印出来 echo sprintf(\"Application Dir: %s\\n\", $path); // 解压目录不存在，则解压 hellophar.phar is_dir($path) || Extract_Phar::go(false); // 解析命令 $host = parse_cmd($argv, ['-h', '--host'], '127.0.0.1'); $port = intval(parse_cmd($argv, ['-p', '--port'], 80)); // 在解压目录里运行 php 内置 http 服务器 $cmd = sprintf('php -S %s:%d -t %s', $host, $port, $path); exec($cmd); // echo shell_exec($cmd), PHP_EOL; ","date":"2023-06-13","objectID":"/posts/php/phpdephar/:3:0","tags":["php","phar","jar"],"title":"php工程归档文件phar的打包和运行","uri":"/posts/php/phpdephar/"},{"categories":["PHP"],"content":"提交表单 \u003c!doctype html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"\u003e \u003clink rel=\"stylesheet\" href=\"resources/css/bootstrap.min.css\"\u003e \u003ctitle\u003ehome\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv class=\"container\"\u003e \u003cdiv class=\"row\"\u003e \u003ch1\u003ephp app\u003c/h1\u003e \u003cdiv class=\"row\"\u003e \u003cform method=\"post\" action=\"post.php\"\u003e \u003cdiv class=\"mb-3\"\u003e \u003clabel for=\"username\" class=\"form-label\"\u003eUsername\u003c/label\u003e \u003cinput type=\"text\" class=\"form-control\" id=\"username\"\u003e \u003cdiv id=\"emailHelp\" class=\"form-text\"\u003eplease input your name.\u003c/div\u003e \u003c/div\u003e \u003cbutton type=\"submit\" class=\"btn btn-primary\" onclick=\"return;\"\u003eSubmit\u003c/button\u003e \u003c/form\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2023-06-13","objectID":"/posts/php/phpdephar/:4:0","tags":["php","phar","jar"],"title":"php工程归档文件phar的打包和运行","uri":"/posts/php/phpdephar/"},{"categories":["PHP"],"content":"post文件 \u003c?php date_default_timezone_set('Asia/Shanghai'); $now = date('Y-m-d H:i:s'); exit($now); ","date":"2023-06-13","objectID":"/posts/php/phpdephar/:5:0","tags":["php","phar","jar"],"title":"php工程归档文件phar的打包和运行","uri":"/posts/php/phpdephar/"},{"categories":["Java框架"],"content":"参考 idea专业版创建maven项目使用archetype在项目结构上的区别 Idea archetype介绍 ","date":"2023-05-11","objectID":"/posts/framework/createfromarchetype/:1:0","tags":["idea","archetype"],"title":"maven骨架archetype","uri":"/posts/framework/createfromarchetype/"},{"categories":["PHP框架","ThinkPHP"],"content":"ThinkPHP3.2.3手册笔记 ","date":"2023-05-09","objectID":"/posts/framework/tp3.2biji/:0:0","tags":["tp","tp3.2","thinkphp"],"title":"ThinkPHP3.2.3手册笔记","uri":"/posts/framework/tp3.2biji/"},{"categories":["Java基础"],"content":"Java日期时间 ","date":"2023-05-05","objectID":"/posts/java%E5%9F%BA%E7%A1%80/time/:0:0","tags":["time","Java日期时间"],"title":"Java日期时间","uri":"/posts/java%E5%9F%BA%E7%A1%80/time/"},{"categories":["Java基础"],"content":"JDK1.8之前 格式化时间： import cn.hutool.core.date.DatePattern; import java.text.SimpleDateFormat; import java.time.Instant; import java.util.Date; Instant instant = Instant.now(); Date date = Date.from(instant); SimpleDateFormat simpleDateFormat = new SimpleDateFormat(DatePattern.NORM_DATETIME_PATTERN); System.out.println(simpleDateFormat.format(date)); // 2023-05-05 22:02:582023-05-05 22:02:58 ","date":"2023-05-05","objectID":"/posts/java%E5%9F%BA%E7%A1%80/time/:1:0","tags":["time","Java日期时间"],"title":"Java日期时间","uri":"/posts/java%E5%9F%BA%E7%A1%80/time/"},{"categories":["Java基础"],"content":"JDK1.8之后 格式化时间： import cn.hutool.core.date.DatePattern; import java.time.LocalDateTime; import java.time.format.DateTimeFormatter; DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(DatePattern.NORM_DATETIME_PATTERN); LocalDateTime localDateTime = LocalDateTime.now(); System.out.println(localDateTime.format(dateTimeFormatter)); // 2023-05-05 22:36:27 ","date":"2023-05-05","objectID":"/posts/java%E5%9F%BA%E7%A1%80/time/:2:0","tags":["time","Java日期时间"],"title":"Java日期时间","uri":"/posts/java%E5%9F%BA%E7%A1%80/time/"},{"categories":["Java基础"],"content":"时间戳 @Test void test() { // 获取时区 String zoneId = ZoneId.systemDefault().getId(); DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\"); assertEquals(\"Asia/Shanghai\", zoneId); // 时间戳转 java.time.LocalDateTime ZonedDateTime zonedDateTime = Instant.now().atZone(ZoneId.systemDefault()); LocalDateTime localDateTime1 = zonedDateTime.toLocalDateTime(); // java.time.LocalDateTime 转 java.util.Date LocalDateTime localDateTime = LocalDateTimeUtil.now(); assertEquals(localDateTime.format(dateTimeFormatter), localDateTime1.format(dateTimeFormatter)); Date date = Date.from(localDateTime.atZone(ZoneId.systemDefault()).toInstant()); // 获取时间戳 long nanoSecond; long millSecond; long second; // 方式一： millSecond = System.currentTimeMillis(); System.out.printf(\"毫秒 System.currentTimeMillis ：%s%n\", millSecond); nanoSecond = System.nanoTime(); System.out.printf(\"纳秒 System.nanoTime() ：%s%n\", nanoSecond); // 方式二： Instant instant = Instant.now(); millSecond = instant.toEpochMilli(); System.out.printf(\"毫秒 instant.toEpochMilli ：%s%n\", millSecond); // instant.getNano() 返回的是时间戳的纳秒部分，可不是纳秒 assertNotEquals(nanoSecond, instant.getNano()); // 方式三： millSecond = new Date().getTime(); // second = millSecond / 1000; second = instant.getEpochSecond(); System.out.printf(\"秒 instant.getEpochSecond() ：%s%n\", second); } ","date":"2023-05-05","objectID":"/posts/java%E5%9F%BA%E7%A1%80/time/:3:0","tags":["time","Java日期时间"],"title":"Java日期时间","uri":"/posts/java%E5%9F%BA%E7%A1%80/time/"},{"categories":["Java基础"],"content":"2种时间的格式化方式 ","date":"2023-05-05","objectID":"/posts/java%E5%9F%BA%E7%A1%80/time/:4:0","tags":["time","Java日期时间"],"title":"Java日期时间","uri":"/posts/java%E5%9F%BA%E7%A1%80/time/"},{"categories":["Java基础"],"content":"格式化时间 import java.text.SimpleDateFormat; import java.util.Date; String pattern = \"yyyy-MM-dd\"; SimpleDateFormat simpleDateFormat = new SimpleDateFormat(pattern); // 格式化时间 System.out.println(simpleDateFormat.format(new Date())); ","date":"2023-05-05","objectID":"/posts/java%E5%9F%BA%E7%A1%80/time/:4:1","tags":["time","Java日期时间"],"title":"Java日期时间","uri":"/posts/java%E5%9F%BA%E7%A1%80/time/"},{"categories":["Java基础"],"content":"时间被格式化 import java.time.format.DateTimeFormatter; import java.time.LocalDateTime; // 时间被格式化 String pattern = \"yyyy-MM-dd\"; System.out.println(LocalDateTime.now().format(DateTimeFormatter.ofPattern(pattern))); ","date":"2023-05-05","objectID":"/posts/java%E5%9F%BA%E7%A1%80/time/:4:2","tags":["time","Java日期时间"],"title":"Java日期时间","uri":"/posts/java%E5%9F%BA%E7%A1%80/time/"},{"categories":["Java基础"],"content":"可见性 ","date":"2023-05-05","objectID":"/posts/java%E5%9F%BA%E7%A1%80/package/:1:0","tags":["package","包"],"title":"Java中的包","uri":"/posts/java%E5%9F%BA%E7%A1%80/package/"},{"categories":["Java基础"],"content":"web 常用功能： 出/入参格式化： paja 转 json 序列化时，定义格式，com.fasterxml.jackson.annotation.@JsonFormat(pattern = DatePattern.NORM_DATETIME_PATTERN, timezone = \"GMT+8\") 指定了序列化格式以及时区。 格式化控制器请求参数，org.springframework.format.annotation.@DateTimeFormat(pattern = DatePattern.NORM_DATETIME_PATTERN) ","date":"2023-05-05","objectID":"/posts/framework/web/:0:0","tags":["web","j2ee"],"title":"Web","uri":"/posts/framework/web/"},{"categories":["Java基础"],"content":"内部类 ","date":"2023-05-05","objectID":"/posts/java%E5%9F%BA%E7%A1%80/class/:1:0","tags":["类","多态"],"title":"类","uri":"/posts/java%E5%9F%BA%E7%A1%80/class/"},{"categories":["Java基础"],"content":"静态内部类 内部类和静态内部类有何区别，什么场景下用什么？ Java 的内部类和静态内部类都是定义在另一个类的内部的类。 区别： 内部类可以访问外部类的成员变量和方法（包括私有成员），而静态内部类不能访问外部类的非静态成员变量和方法，只能访问静态成员变量和方法。 内部类的实例依赖于外部类的实例，而静态内部类的实例不依赖于外部类的实例。 内部类不能定义静态成员，而静态内部类可以定义静态成员。 内部类可以访问外部类的 private 构造方法，而静态内部类不能。 场景： 若需要访问外部类的非静态成员变量或方法，应该使用内部类。 若不需要访问外部类的非静态成员变量或方法，或者需要定义静态成员，应该使用静态内部类。 如果内部类对象需要访问其外部类对象，或者需要访问非静态的外部类的成员，就应该使用内部类。 如果不需要访问外部类的实例，那么就可以使用静态内部类，这样可以减少内存的使用。同时使用静态内部类可以避免内存泄漏问题。 ","date":"2023-05-05","objectID":"/posts/java%E5%9F%BA%E7%A1%80/class/:1:1","tags":["类","多态"],"title":"类","uri":"/posts/java%E5%9F%BA%E7%A1%80/class/"},{"categories":["工具"],"content":"编辑器 ","date":"2023-04-29","objectID":"/posts/tools/mytool/:1:0","tags":["tool","工具","入职第一天"],"title":"劳动工具","uri":"/posts/tools/mytool/"},{"categories":["工具"],"content":"PhpStorm 最强 PHP IDE ","date":"2023-04-29","objectID":"/posts/tools/mytool/:1:1","tags":["tool","工具","入职第一天"],"title":"劳动工具","uri":"/posts/tools/mytool/"},{"categories":["工具"],"content":"Idea ","date":"2023-04-29","objectID":"/posts/tools/mytool/:1:2","tags":["tool","工具","入职第一天"],"title":"劳动工具","uri":"/posts/tools/mytool/"},{"categories":["工具"],"content":"Sublime 正则操作文本方便 小巧精悍 ","date":"2023-04-29","objectID":"/posts/tools/mytool/:1:3","tags":["tool","工具","入职第一天"],"title":"劳动工具","uri":"/posts/tools/mytool/"},{"categories":["工具"],"content":"图文工具 ","date":"2023-04-29","objectID":"/posts/tools/mytool/:2:0","tags":["tool","工具","入职第一天"],"title":"劳动工具","uri":"/posts/tools/mytool/"},{"categories":["工具"],"content":"Snipaste https://zh.snipaste.com/ 截图好工具 ","date":"2023-04-29","objectID":"/posts/tools/mytool/:2:1","tags":["tool","工具","入职第一天"],"title":"劳动工具","uri":"/posts/tools/mytool/"},{"categories":["工具"],"content":"FastStone Capture https://www.faststone.org/FSCaptureDownload.htm 屏幕取色，截图，滚动截图，录屏压缩比高。 ","date":"2023-04-29","objectID":"/posts/tools/mytool/:2:2","tags":["tool","工具","入职第一天"],"title":"劳动工具","uri":"/posts/tools/mytool/"},{"categories":["工具"],"content":"数据库软件 ","date":"2023-04-29","objectID":"/posts/tools/mytool/:3:0","tags":["tool","工具","入职第一天"],"title":"劳动工具","uri":"/posts/tools/mytool/"},{"categories":["工具"],"content":"Navicat 数据库操作客户端软件 ","date":"2023-04-29","objectID":"/posts/tools/mytool/:3:1","tags":["tool","工具","入职第一天"],"title":"劳动工具","uri":"/posts/tools/mytool/"},{"categories":["工具"],"content":"PhpMyAdmin ","date":"2023-04-29","objectID":"/posts/tools/mytool/:3:2","tags":["tool","工具","入职第一天"],"title":"劳动工具","uri":"/posts/tools/mytool/"},{"categories":["工具"],"content":"Another Redis Desktop Manager https://goanother.com/cn/ https://github.com/qishibo/AnotherRedisDesktopManager 更快、更好、更稳定的 Redis 桌面(GUI)管理客户端，兼容 Windows、Mac、Linux，性能出众，轻松加载海量键值。 ","date":"2023-04-29","objectID":"/posts/tools/mytool/:3:3","tags":["tool","工具","入职第一天"],"title":"劳动工具","uri":"/posts/tools/mytool/"},{"categories":["工具"],"content":"笔记软件 ","date":"2023-04-29","objectID":"/posts/tools/mytool/:4:0","tags":["tool","工具","入职第一天"],"title":"劳动工具","uri":"/posts/tools/mytool/"},{"categories":["工具"],"content":"印象笔记 主要是剪藏网页 ","date":"2023-04-29","objectID":"/posts/tools/mytool/:4:1","tags":["tool","工具","入职第一天"],"title":"劳动工具","uri":"/posts/tools/mytool/"},{"categories":["工具"],"content":"小米笔记 多端的同步，以及使用代办事项功能。 ","date":"2023-04-29","objectID":"/posts/tools/mytool/:4:2","tags":["tool","工具","入职第一天"],"title":"劳动工具","uri":"/posts/tools/mytool/"},{"categories":["工具"],"content":"飞书 问卷表单收集 在线文档 打卡 机器人 ","date":"2023-04-29","objectID":"/posts/tools/mytool/:4:3","tags":["tool","工具","入职第一天"],"title":"劳动工具","uri":"/posts/tools/mytool/"},{"categories":["工具"],"content":"Typora windows 系统方便 办公室环境写笔记，生成静态站点博客 ","date":"2023-04-29","objectID":"/posts/tools/mytool/:4:4","tags":["tool","工具","入职第一天"],"title":"劳动工具","uri":"/posts/tools/mytool/"},{"categories":["工具"],"content":"MWeb Pro 家里环境写笔记 支持同步博客园 主要是我开了会员 ","date":"2023-04-29","objectID":"/posts/tools/mytool/:4:5","tags":["tool","工具","入职第一天"],"title":"劳动工具","uri":"/posts/tools/mytool/"},{"categories":["工具"],"content":"浏览器 ","date":"2023-04-29","objectID":"/posts/tools/mytool/:5:0","tags":["tool","工具","入职第一天"],"title":"劳动工具","uri":"/posts/tools/mytool/"},{"categories":["工具"],"content":"Microsoft Edge 支持多端同步 网上冲浪 共享标签 ","date":"2023-04-29","objectID":"/posts/tools/mytool/:5:1","tags":["tool","工具","入职第一天"],"title":"劳动工具","uri":"/posts/tools/mytool/"},{"categories":["工具"],"content":"Google Chrome 调试用 ","date":"2023-04-29","objectID":"/posts/tools/mytool/:5:2","tags":["tool","工具","入职第一天"],"title":"劳动工具","uri":"/posts/tools/mytool/"},{"categories":["工具"],"content":"Postman 接口调试 ","date":"2023-04-29","objectID":"/posts/tools/mytool/:5:3","tags":["tool","工具","入职第一天"],"title":"劳动工具","uri":"/posts/tools/mytool/"},{"categories":["工具"],"content":"云盘 ","date":"2023-04-29","objectID":"/posts/tools/mytool/:6:0","tags":["tool","工具","入职第一天"],"title":"劳动工具","uri":"/posts/tools/mytool/"},{"categories":["工具"],"content":"百度网盘 免费空间大，但是限速难受 已经转移资料不用了 ","date":"2023-04-29","objectID":"/posts/tools/mytool/:6:1","tags":["tool","工具","入职第一天"],"title":"劳动工具","uri":"/posts/tools/mytool/"},{"categories":["工具"],"content":"腾讯微云 QQ自带，无需注册，聊天记录文件方便同步 免费空间小 之前开过会员，文件还丢失，跟 TAPD 一样，bug 一堆 ","date":"2023-04-29","objectID":"/posts/tools/mytool/:6:2","tags":["tool","工具","入职第一天"],"title":"劳动工具","uri":"/posts/tools/mytool/"},{"categories":["工具"],"content":"天翼云盘 2016 年免费送 10T 不限速 可领电信云盘定向流量 ","date":"2023-04-29","objectID":"/posts/tools/mytool/:6:3","tags":["tool","工具","入职第一天"],"title":"劳动工具","uri":"/posts/tools/mytool/"},{"categories":["工具"],"content":"中国移动云盘 会员好领 会员定向流量不限 会员便宜 ","date":"2023-04-29","objectID":"/posts/tools/mytool/:6:4","tags":["tool","工具","入职第一天"],"title":"劳动工具","uri":"/posts/tools/mytool/"},{"categories":["工具"],"content":"小米云盘 单价虽然比运营商云盘贵，但是好在手机同步方便 免费空间小，跟苹果学的，免费空间只有 5 GB ","date":"2023-04-29","objectID":"/posts/tools/mytool/:6:5","tags":["tool","工具","入职第一天"],"title":"劳动工具","uri":"/posts/tools/mytool/"},{"categories":["工具"],"content":"视频播放与编辑 ","date":"2023-04-29","objectID":"/posts/tools/mytool/:7:0","tags":["tool","工具","入职第一天"],"title":"劳动工具","uri":"/posts/tools/mytool/"},{"categories":["工具"],"content":"完美解码 http://potplayer.tv/ ","date":"2023-04-29","objectID":"/posts/tools/mytool/:7:1","tags":["tool","工具","入职第一天"],"title":"劳动工具","uri":"/posts/tools/mytool/"},{"categories":["服务器"],"content":"问 ","date":"2023-04-28","objectID":"/posts/framework/tomcat/:1:0","tags":["tomcat"],"title":"Tomcat","uri":"/posts/framework/tomcat/"},{"categories":["服务器"],"content":"Tomcat 与 Catalina 的关系 ","date":"2023-04-28","objectID":"/posts/framework/tomcat/:1:1","tags":["tomcat"],"title":"Tomcat","uri":"/posts/framework/tomcat/"},{"categories":["服务器"],"content":"中文乱码 ","date":"2023-04-28","objectID":"/posts/framework/tomcat/:2:0","tags":["tomcat"],"title":"Tomcat","uri":"/posts/framework/tomcat/"},{"categories":["服务器"],"content":"tomcat框架打印的中文不乱码，业务代码输出的乱码 只需要添加红框内的参数，即可解决自行输出的中文乱码问题。 ","date":"2023-04-28","objectID":"/posts/framework/tomcat/:2:1","tags":["tomcat"],"title":"Tomcat","uri":"/posts/framework/tomcat/"},{"categories":["服务器"],"content":"日志文件位置 ","date":"2023-04-28","objectID":"/posts/framework/tomcat/:3:0","tags":["tomcat"],"title":"Tomcat","uri":"/posts/framework/tomcat/"},{"categories":["服务器"],"content":"idea外挂tomcat日志文件路径 06-May-2023 17:04:36.219 信息 [main] org.apache.catalina.startup.VersionLoggerListener.log CATALINA_BASE: C:\\Users\\Shali\\AppData\\Local\\JetBrains\\IntelliJIdea2021.2\\tomcat\\d80e4829-06ff-4802-b054-c68a1428377f 06-May-2023 17:04:36.219 信息 [main] org.apache.catalina.startup.VersionLoggerListener.log CATALINA_HOME: C:\\Users\\Shali\\Downloads\\apache-tomcat-8.5.64 C:\\Users\\Shali\\AppData\\Local\\JetBrains\\IntelliJIdea2021.2\\tomcat\\d80e4829-06ff-4802-b054-c68a1428377f\\logs ","date":"2023-04-28","objectID":"/posts/framework/tomcat/:3:1","tags":["tomcat"],"title":"Tomcat","uri":"/posts/framework/tomcat/"},{"categories":["设计模式"],"content":"chatgpt 的回答： Java中有很多设计模式，每个模式都有不同的接口。以下是一些常见的设计模式接口： 工厂模式接口：Factory 抽象工厂模式接口：AbstractFactory 单例模式接口：Singleton 建造者模式接口：Builder 原型模式接口：Prototype 适配器模式接口：Adapter 桥接模式接口：Bridge 组合模式接口：Composite 装饰器模式接口：Decorator 外观模式接口：Facade 享元模式接口：Flyweight 代理模式接口：Proxy 观察者模式接口：Observer 迭代器模式接口：Iterator 访问者模式接口：Visitor 策略模式接口：Strategy 模板方法模式接口：TemplateMethod 命令模式接口：Command 职责链模式接口：ChainOfResponsibility 中介者模式接口：Mediator 备忘录模式接口：Memento 解释器模式接口：Interpreter 状态模式接口：State 空对象模式接口：NullObject 并发模式接口：Concurrency 以上是一些常见的设计模式接口，但并不是全部。不同的设计模式有不同的接口，具体实现需要根据具体的模式来确定。 Java的设计模式接口没有固定的包，它们可以在不同的包中找到。常见的设计模式接口包括： java.util.Observer 和 java.util.Observable：观察者模式 java.util.Iterator：迭代器模式 java.util.Map.Entry：迭代器模式中的迭代元素 java.lang.Cloneable：原型模式 java.io.Serializable：原型模式和备忘录模式 java.util.concurrent.Callable：命令模式 java.util.concurrent.Future：命令模式和代理模式 java.util.concurrent.Executor：命令模式和责任链模式 javax.servlet.Filter：责任链模式 除了以上常见的接口外，还有许多其他的接口可以用于实现不同的设计模式。 ","date":"2023-04-20","objectID":"/posts/designpatterns/interface/:0:0","tags":["接口","java设计模式"],"title":"设计模式接口","uri":"/posts/designpatterns/interface/"},{"categories":["Spring"],"content":"@Bean搭配@Configuration和@Component 背景： @org.springframework.stereotype.Component public @interface Configuration { } 我们都知道 @Bean 需要搭配 @Configuration 注解才能使得定义的配置类被扫描到。 但是我们发现 @Configuration 注解也被 @Component 修饰，那么就能替换，达到被扫描的效果，还真是。 ","date":"2023-04-18","objectID":"/posts/framework/spring/@bean/:0:0","tags":["java","框架","注解"],"title":"Bean搭配Configuration和Component","uri":"/posts/framework/spring/@bean/"},{"categories":["Spring"],"content":"不同 @Bean 搭配 @Component 使用，被 @Bean 修饰的方法不能彼此调用 局限性，@Configuration 注解的类不能被 final 修饰，因为 Spring 要使用 CGLIB 子类化注解的类，但 final 类无子类 ","date":"2023-04-18","objectID":"/posts/framework/spring/@bean/:1:0","tags":["java","框架","注解"],"title":"Bean搭配Configuration和Component","uri":"/posts/framework/spring/@bean/"},{"categories":["Java基础"],"content":"常见用法 ","date":"2023-04-18","objectID":"/posts/java%E5%9F%BA%E7%A1%80/log/:1:0","tags":["java","log","slf4j","日志"],"title":"日志","uri":"/posts/java%E5%9F%BA%E7%A1%80/log/"},{"categories":["Java基础"],"content":"为什么每个类里都定义一个 logger，而不是单例 下面是 chatgpt 的回答： Java中的每个类都可以定义一个logger，这是因为每个类都可能需要记录不同的日志信息，而这些日志信息可能需要在不同的地方使用。如果使用单例模式，那么所有的日志信息都会被记录在同一个logger中，这样就无法区分不同的日志信息，也无法方便地对不同的日志信息进行管理和调试。 另外，Java中的logger是线程安全的，因此在多线程环境下，每个类都可以独立地使用自己的logger，避免了线程安全问题。如果使用单例模式，需要考虑线程安全问题，增加了代码的复杂度和维护成本。 因此，Java中每个类都定义一个logger是一种更加灵活和方便的做法，可以根据需要独立地记录和管理不同的日志信息。 ","date":"2023-04-18","objectID":"/posts/java%E5%9F%BA%E7%A1%80/log/:2:0","tags":["java","log","slf4j","日志"],"title":"日志","uri":"/posts/java%E5%9F%BA%E7%A1%80/log/"},{"categories":["Java基础"],"content":"final ","date":"2023-04-17","objectID":"/posts/java%E5%9F%BA%E7%A1%80/javakeywords/:1:0","tags":["java","keywords","关键字"],"title":"Java关键字","uri":"/posts/java%E5%9F%BA%E7%A1%80/javakeywords/"},{"categories":["Java基础"],"content":"修饰变量 final 修饰的变量，只能初始化，不能赋值。（即只能被赋值 1 次。） // 定义并初始化 final Integer integer = 1; // 第二次和第三次赋值都会报错 // Cannot assign a value to final variable 'integer' integer = 2; integer = 3; // 只定义未初始化 final Integer integer; // 正确 integer = 2; // 报错 // Cannot assign a value to final variable 'integer' integer = 3; ","date":"2023-04-17","objectID":"/posts/java%E5%9F%BA%E7%A1%80/javakeywords/:1:1","tags":["java","keywords","关键字"],"title":"Java关键字","uri":"/posts/java%E5%9F%BA%E7%A1%80/javakeywords/"},{"categories":["Java基础"],"content":"1. for (int i = 0; i \u003c userList.size(); i++) ","date":"2023-04-15","objectID":"/posts/java%E5%9F%BA%E7%A1%80/javafordequbie/:1:0","tags":["for","foreach","forEach","Iterator"],"title":"Java 中的三种 for 循环区别","uri":"/posts/java%E5%9F%BA%E7%A1%80/javafordequbie/"},{"categories":["Java基础"],"content":"2. for (User user : userList) ","date":"2023-04-15","objectID":"/posts/java%E5%9F%BA%E7%A1%80/javafordequbie/:2:0","tags":["for","foreach","forEach","Iterator"],"title":"Java 中的三种 for 循环区别","uri":"/posts/java%E5%9F%BA%E7%A1%80/javafordequbie/"},{"categories":["Java基础"],"content":"3. userList.forEach(user -\u003e {}) ","date":"2023-04-15","objectID":"/posts/java%E5%9F%BA%E7%A1%80/javafordequbie/:3:0","tags":["for","foreach","forEach","Iterator"],"title":"Java 中的三种 for 循环区别","uri":"/posts/java%E5%9F%BA%E7%A1%80/javafordequbie/"},{"categories":["Java基础"],"content":"总结： 别人总结了： 1w 以内数据用方式 1，for 10w 以内数据用集合的迭代器，forEach ","date":"2023-04-15","objectID":"/posts/java%E5%9F%BA%E7%A1%80/javafordequbie/:4:0","tags":["for","foreach","forEach","Iterator"],"title":"Java 中的三种 for 循环区别","uri":"/posts/java%E5%9F%BA%E7%A1%80/javafordequbie/"},{"categories":["MySQL"],"content":"数据背景： 大家都在本地创建此背景 sql： ","date":"2023-04-13","objectID":"/posts/database/100tiaosql/:0:0","tags":["mysql","sql","面试"],"title":"100条 sql","uri":"/posts/database/100tiaosql/"},{"categories":["MySQL"],"content":"一对一携带一对多数据合并 背景： 查询出班级里的所有学生，多个学生的身份信息用逗号分割 学号 姓名 身份 1 张三 三好学生,学习委员,劳动班长 2 李四 体育委员,英语课代表 select id, name, group_concat(id_tag) from user inner join user_tag utag on utag.user_id = user.id inner join tag on tag.id = utag.tag_id group by user.id ","date":"2023-04-13","objectID":"/posts/database/100tiaosql/:1:0","tags":["mysql","sql","面试"],"title":"100条 sql","uri":"/posts/database/100tiaosql/"},{"categories":["Java基础"],"content":"JDK1.8引入的Optional ","date":"2023-04-11","objectID":"/posts/java%E5%9F%BA%E7%A1%80/nullpointerexception/:1:0","tags":["判空","NPE","NullPointerException"],"title":"Java判空的常见操作","uri":"/posts/java%E5%9F%BA%E7%A1%80/nullpointerexception/"},{"categories":["2023年"],"content":"10.15.1 md5 值： certutil -hashfile “macOS Catalina 10.15.1(19B88) Installer for Clover 5098 and WEPE.dmg” md5 MD5 的 macOS Catalina 10.15.1(19B88) Installer for Clover 5098 and WEPE.dmg 哈希: 6bd732d83e66543bec3f2ac78dc3a613 CertUtil: -hashfile 命令成功完成。 ","date":"2023-04-08","objectID":"/posts/2023/t470phackinto/:1:0","tags":["t470p","黑苹果"],"title":"T470p的黑苹果之路","uri":"/posts/2023/t470phackinto/"},{"categories":["2023年"],"content":"参考 https://github.com/lohcve/EFI_T470P_CLOVER https://gitee.com/pratise/T470P-EFI/ https://blog.daliansky.net/macOS-Catalina-10.15.1-19B88-Release-version-with-Clover-5098-original-image-Double-EFI-Version.html https://mirrors.dtops.co/ISO/MacOS/10.15/ ","date":"2023-04-08","objectID":"/posts/2023/t470phackinto/:2:0","tags":["t470p","黑苹果"],"title":"T470p的黑苹果之路","uri":"/posts/2023/t470phackinto/"},{"categories":["Java基础"],"content":"接口与抽象类的区别 Java 中一个类可以实现多个接口 只能继承一个抽象类 接口约束了我们必须具备哪些行为，所以接口是对行为的抽象。 抽象类是类的抽象 ","date":"2023-04-08","objectID":"/posts/java%E5%9F%BA%E7%A1%80/interfaceandabstractclass/:1:0","tags":["接口","抽象类"],"title":"接口与抽象类的区别与使用场景","uri":"/posts/java%E5%9F%BA%E7%A1%80/interfaceandabstractclass/"},{"categories":["设计模式"],"content":"设计模式的接口和抽象类 如果一个人长时间不使用 23 种设计模式，那么他很容易遗忘设计模式的规则和用法。但是如果我们有一种工具，能够帮助我们拾起设计模式的记忆，那该多好啊。 还别说，还真有，比如 PHP 中的观察者模式接口，以及 Lombok 框架的 @Builder 注解，都是帮你快速用起来设计模式，而不是去看他如何实现。 ","date":"2023-04-08","objectID":"/posts/designpatterns/readme/:1:0","tags":["接口","设计模式"],"title":"认识设计模式","uri":"/posts/designpatterns/readme/"},{"categories":["Java基础"],"content":"认识HashMap ","date":"2023-04-06","objectID":"/posts/java%E5%9F%BA%E7%A1%80/learnmap/:1:0","tags":["map","java","集合","映射"],"title":"认识Map","uri":"/posts/java%E5%9F%BA%E7%A1%80/learnmap/"},{"categories":["问"],"content":"我们很容易理解：程序 = 变量 + 业务 ","date":"2023-04-06","objectID":"/posts/2023/whatisprogram/:0:0","tags":["算法","数据结构"],"title":"为什么说程序=算法+数据结构","uri":"/posts/2023/whatisprogram/"},{"categories":["设计模式"],"content":"命名 对一个领域建模时，要仔细考虑什么样的对象做什么样的事情，这是对象行为的设计。对对象的命名能够传达准确的业务含义，即反映通用语言。 如果我们只是关注领域模型定义属性，提供getter和setter方法，你那只是创建纯粹的数据模型（DO）。 ","date":"2023-04-05","objectID":"/posts/designpatterns/shixianlingyuqudongsheji/:1:0","tags":["领域驱动设计","DDD"],"title":"《实现领域驱动设计》读书笔记","uri":"/posts/designpatterns/shixianlingyuqudongsheji/"},{"categories":["设计模式"],"content":"领域对象的特点 要对外暴露行为，尽可能少的暴露属性，对外暴露setter和getter方法 ","date":"2023-04-05","objectID":"/posts/designpatterns/shixianlingyuqudongsheji/:2:0","tags":["领域驱动设计","DDD"],"title":"《实现领域驱动设计》读书笔记","uri":"/posts/designpatterns/shixianlingyuqudongsheji/"},{"categories":["设计模式"],"content":"问答 ","date":"2023-04-05","objectID":"/posts/designpatterns/shixianlingyuqudongsheji/:3:0","tags":["领域驱动设计","DDD"],"title":"《实现领域驱动设计》读书笔记","uri":"/posts/designpatterns/shixianlingyuqudongsheji/"},{"categories":["设计模式"],"content":"如何确定领域对象中的行为方法的正确性？ 最简单的方法就是看你封装的行为方法是否有业务交互。如果只是简单调用setter和getter方法。 ","date":"2023-04-05","objectID":"/posts/designpatterns/shixianlingyuqudongsheji/:3:1","tags":["领域驱动设计","DDD"],"title":"《实现领域驱动设计》读书笔记","uri":"/posts/designpatterns/shixianlingyuqudongsheji/"},{"categories":["设计模式"],"content":"我的思考 其实我们平时在建立领域模型时，也在可以暴露模型的行为方法，减少使用者对属性setter和getter操作的关注。但是我们的模型行为最大的缺点，就是职责不够单一。后期改动牵一发而动全身。 缺点就是封装了太多的单一职责的方法，没有面向过程式代码，一眼看下来便知道了整个业务流程执行了什么。而这种领域对象还要进入其内部才能了解具体做了什么。如果想要快速了解整个业务，流程图是必不可少的。 ","date":"2023-04-05","objectID":"/posts/designpatterns/shixianlingyuqudongsheji/:4:0","tags":["领域驱动设计","DDD"],"title":"《实现领域驱动设计》读书笔记","uri":"/posts/designpatterns/shixianlingyuqudongsheji/"},{"categories":["Java基础"],"content":"Collection 和 Map 接口都是容器接口。其实 Map 也是集合。 ","date":"2023-04-05","objectID":"/posts/java%E5%9F%BA%E7%A1%80/container/:0:0","tags":["Java","容器","container"],"title":"Java中有哪些容器","uri":"/posts/java%E5%9F%BA%E7%A1%80/container/"},{"categories":["规范"],"content":"常用版本号语义修饰词 修饰词 含义 alpha 内部版本 beta 测试版 demo 演示版 enhance 增强版 free 自由版 full version 完整版，即正式版 lts 长期维护版本 release 发行版 rc 即将作为正式版发布 standard 标准版 ultimate 旗舰版 upgrade 升级版 ","date":"2023-04-05","objectID":"/posts/tools/banbenhao/:1:0","tags":["版本号"],"title":"软件版本号","uri":"/posts/tools/banbenhao/"},{"categories":["工具"],"content":"iPadOS上使用 ","date":"2023-04-05","objectID":"/posts/tools/microsoftremotedesk/:1:0","tags":["Microsoft remote client","rdm"],"title":"微软远程桌面客户端使用笔记","uri":"/posts/tools/microsoftremotedesk/"},{"categories":["工具"],"content":"如何使用左右键 ","date":"2023-04-05","objectID":"/posts/tools/microsoftremotedesk/:1:1","tags":["Microsoft remote client","rdm"],"title":"微软远程桌面客户端使用笔记","uri":"/posts/tools/microsoftremotedesk/"},{"categories":["工具"],"content":"触摸 单指单按就是左键，单指长按跟双指触摸一样，相当于鼠标右键。 ","date":"2023-04-05","objectID":"/posts/tools/microsoftremotedesk/:1:2","tags":["Microsoft remote client","rdm"],"title":"微软远程桌面客户端使用笔记","uri":"/posts/tools/microsoftremotedesk/"},{"categories":["工具"],"content":"参考 iPad Remote Desktop right click ","date":"2023-04-05","objectID":"/posts/tools/microsoftremotedesk/:1:3","tags":["Microsoft remote client","rdm"],"title":"微软远程桌面客户端使用笔记","uri":"/posts/tools/microsoftremotedesk/"},{"categories":["框架"],"content":"安装 ","date":"2023-04-03","objectID":"/posts/framework/mybatisshouce/:1:0","tags":["MyBatis","数据库"],"title":"MyBatis使用笔记","uri":"/posts/framework/mybatisshouce/"},{"categories":["框架"],"content":"普通使用 将 mybatis-x.x.x.jar 文件置于类路径（classpath）中即可。 ","date":"2023-04-03","objectID":"/posts/framework/mybatisshouce/:1:1","tags":["MyBatis","数据库"],"title":"MyBatis使用笔记","uri":"/posts/framework/mybatisshouce/"},{"categories":["框架"],"content":"依赖管理工具 maven \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis\u003c/groupId\u003e \u003cartifactId\u003emybatis\u003c/artifactId\u003e \u003cversion\u003ex.x.x\u003c/version\u003e \u003c/dependency\u003e ","date":"2023-04-03","objectID":"/posts/framework/mybatisshouce/:1:2","tags":["MyBatis","数据库"],"title":"MyBatis使用笔记","uri":"/posts/framework/mybatisshouce/"},{"categories":["框架"],"content":"第 1 步创建 SqlSessionFactory ","date":"2023-04-03","objectID":"/posts/framework/mybatisshouce/:2:0","tags":["MyBatis","数据库"],"title":"MyBatis使用笔记","uri":"/posts/framework/mybatisshouce/"},{"categories":["问"],"content":"使用常量类还是常量接口，为什么呢 比如人类，有性别男女，你认为我们是定义到人类类里，还是性别接口里呢？孰优孰劣？ final class People { // 性别 男 public static final String GENDER_MAN = \"男\"; // 性别 女 public static final String GENDER_WOMAN = \"女\"; private People() { } } interface Gender { // 性别 男 String GENDER_MAN = \"男\"; // 性别 女 String GENDER_WOMAN = \"女\"; } ","date":"2023-04-01","objectID":"/posts/java%E5%9F%BA%E7%A1%80/javawhy/:1:0","tags":["Java"],"title":"Java之为什么呢","uri":"/posts/java%E5%9F%BA%E7%A1%80/javawhy/"},{"categories":["问"],"content":"接口 接口中的成员常量均是public final类型的，且可省略 接口中只有常量，没有变量 接口中的常量会被实现类继承，导致继承的常量可能与子类中的常量冲突 由于接口中的常量都是public，导致有些常量可能是仅内部需要，也被暴露出去了 而且常量接口中的常量，还会污染其实现类未来的子类，所以为了避免常量类中出现这种情况，我们通常用final来定义常量类。 ","date":"2023-04-01","objectID":"/posts/java%E5%9F%BA%E7%A1%80/javawhy/:1:1","tags":["Java"],"title":"Java之为什么呢","uri":"/posts/java%E5%9F%BA%E7%A1%80/javawhy/"},{"categories":["问"],"content":"类 类可以通过final修饰，使其无法被继承，故类常量不会对子类常量造成冲突 私有构造方法，防止被实例化 ","date":"2023-04-01","objectID":"/posts/java%E5%9F%BA%E7%A1%80/javawhy/:1:2","tags":["Java"],"title":"Java之为什么呢","uri":"/posts/java%E5%9F%BA%E7%A1%80/javawhy/"},{"categories":["问"],"content":"反例 Java Swing 框架中的 SwingConstants 接口中就定义了大量静态常量。 ","date":"2023-04-01","objectID":"/posts/java%E5%9F%BA%E7%A1%80/javawhy/:1:3","tags":["Java"],"title":"Java之为什么呢","uri":"/posts/java%E5%9F%BA%E7%A1%80/javawhy/"},{"categories":["问"],"content":"常量应该存在哪里？枚举类？常量类？常量接口中？ ","date":"2023-04-01","objectID":"/posts/java%E5%9F%BA%E7%A1%80/javawhy/:2:0","tags":["Java"],"title":"Java之为什么呢","uri":"/posts/java%E5%9F%BA%E7%A1%80/javawhy/"},{"categories":["问"],"content":"大家说 接口是抽象，可能常量接口里定义了很多常量，而实现者可能仅需要几个常量，却得到了更多无用的常量。 反驳：为何不把接口的粒度定小点，常量也应该分业务来管理。 ","date":"2023-04-01","objectID":"/posts/java%E5%9F%BA%E7%A1%80/javawhy/:2:1","tags":["Java"],"title":"Java之为什么呢","uri":"/posts/java%E5%9F%BA%E7%A1%80/javawhy/"},{"categories":["问"],"content":"参考 《Effective Java》作者原话 According to Joshua Bloch, author of “Effective Java”: The constant interface pattern is a poor use of interfaces. That a class uses some constants internally is an implementation detail. Implementing a constant interface causes this implementation detail to leak into the class’s exported API. It is of no consequence to the users of a class that the class implements a constant interface. In fact, it may even confuse them. Worse, it represents a commitment: if in a future release the class is modified so that it no longer needs to use the constants, it still must implement the interface to ensure binary compatibility. If a nonfinal class implements a constant interface, all of its subclasses will have their namespaces polluted by the constants in the interface. Interfaces with static fields in java for sharing ‘constants’ 下面看看，AI 是如何回答的： 作为AI语言模型，我无法给出具体建议，因为这取决于具体的应用场景和需求。但是，以下是常量类和常量接口的一些优缺点，供您参考： 常量类的优点： 可以包含非常量的成员变量和方法； 可以使用继承和实现接口的方式来扩展常量； 可以使用静态导入来方便地使用常量。 常量类的缺点： 常量类的成员变量必须是final修饰的，因此无法修改； 常量类的成员变量必须在编译时就确定，因此无法动态添加常量； 常量类的成员变量必须在类加载时就初始化，因此可能会影响性能。 常量接口的优点： 可以方便地定义大量常量； 可以使用继承和实现接口的方式来扩展常量； 可以使用静态导入来方便地使用常量。 常量接口的缺点： 常量接口的成员变量必须是public static final修饰的，因此无法修改； 常量接口的成员变量必须在编译时就确定，因此无法动态添加常量； 常量接口的成员变量必须在类加载时就初始化，因此可能会影响性能； 常量接口的成员变量可能会被其他类误用或者修改，因此不够安全。 综上所述，常量类和常量接口都有各自的优缺点，具体使用哪个取决于具体的需求和场景。 ","date":"2023-04-01","objectID":"/posts/java%E5%9F%BA%E7%A1%80/javawhy/:2:2","tags":["Java"],"title":"Java之为什么呢","uri":"/posts/java%E5%9F%BA%E7%A1%80/javawhy/"},{"categories":["问"],"content":"类常量为什么还有小写 我们看到一些优秀的代码，或者是编码规约，框架代码，都在强调类常量名称要大写，但是有些却不是。 ","date":"2023-04-01","objectID":"/posts/java%E5%9F%BA%E7%A1%80/javawhy/:3:0","tags":["Java"],"title":"Java之为什么呢","uri":"/posts/java%E5%9F%BA%E7%A1%80/javawhy/"},{"categories":["问"],"content":"没有执行类常量名称大写的情况 public final class ch.qos.logback.classic.Logger implements org.slf4j.Logger, LocationAwareLogger, AppenderAttachable\u003cILoggingEvent\u003e, Serializable { // 小驼峰类常量 private static final long serialVersionUID = 5454405123156820674L; // 8745934908040027998L; // 大写类常量 public static final String FQCN = ch.qos.logback.classic.Logger.class.getName(); } lombok 框架的 @Slf4j 注解： // 小驼峰类常量 private static final org.slf4j.Logger log; ","date":"2023-04-01","objectID":"/posts/java%E5%9F%BA%E7%A1%80/javawhy/:3:1","tags":["Java"],"title":"Java之为什么呢","uri":"/posts/java%E5%9F%BA%E7%A1%80/javawhy/"},{"categories":["问"],"content":"总结 细心的你会发现如下结论： public 类常量，常量名称全大写，多个单词下划线分割 非 public 类常量，常量名称小驼峰 哈哈，其实上面的总结也是错误的。不信你看 java.time.Year public final class Year implements Temporal, TemporalAdjuster, Comparable\u003cYear\u003e, Serializable { /** * The minimum supported year, '-999,999,999'. */ public static final int MIN_VALUE = -999_999_999; /** * The maximum supported year, '+999,999,999'. */ public static final int MAX_VALUE = 999_999_999; /** * Serialization version. */ private static final long serialVersionUID = -23038383694477807L; /** * Parser. */ private static final DateTimeFormatter PARSER = new DateTimeFormatterBuilder() .appendValue(YEAR, 4, 10, SignStyle.EXCEEDS_PAD) .toFormatter(); } 于是你又总结了，私有的类常量，基本类型小驼峰，非基本类型使用全大写。但是你又错了。你看 java.time.LocalDate public final class LocalDate implements Temporal, TemporalAdjuster, ChronoLocalDate, Serializable { /** * The minimum supported {@code LocalDate}, '-999999999-01-01'. * This could be used by an application as a \"far past\" date. */ public static final LocalDate MIN = LocalDate.of(Year.MIN_VALUE, 1, 1); /** * The maximum supported {@code LocalDate}, '+999999999-12-31'. * This could be used by an application as a \"far future\" date. */ public static final LocalDate MAX = LocalDate.of(Year.MAX_VALUE, 12, 31); /** * Serialization version. */ private static final long serialVersionUID = 2942565459149668126L; /** * The number of days in a 400 year cycle. */ private static final int DAYS_PER_CYCLE = 146097; } ","date":"2023-04-01","objectID":"/posts/java%E5%9F%BA%E7%A1%80/javawhy/:3:2","tags":["Java"],"title":"Java之为什么呢","uri":"/posts/java%E5%9F%BA%E7%A1%80/javawhy/"},{"categories":["Java基础"],"content":"Java中的数组参数与可变参数的区别 看代码： private int[] func1(int... args) { return args; } private int[] func2(int[] args) { return args; } @Test void func() { int[] args = {1, 2, 3}; assertArrayEquals(args, func1(args)); assertArrayEquals(args, func2(args)); assertArrayEquals(args, func1(1, 2, 3)); } 其实可变参数，最终进入函数内也是数组。 ","date":"2023-04-01","objectID":"/posts/java%E5%9F%BA%E7%A1%80/shuzuhekebiancan/:0:0","tags":["Java","可变参数","数组"],"title":"Java中的数组参数与可变参数的区别","uri":"/posts/java%E5%9F%BA%E7%A1%80/shuzuhekebiancan/"},{"categories":["框架"],"content":"Controller层问题 ","date":"2023-03-28","objectID":"/posts/framework/springbootwenti/:1:0","tags":["Spring","SpringBoot"],"title":"SpringBoot问题收集","uri":"/posts/framework/springbootwenti/"},{"categories":["框架"],"content":"Request method ‘GET’ not supported 使用 postman 发送请求，明明发送的是 POST 请求，却报 Request method 'GET' not supported。而且注解使用的就是 @PostMapping，有点丈二和尚摸不着头脑了。 网络搜索了解，是因为你访问的是 http，Nginx 将 http 请求 302 重定向到了 https，而且重定向发的是 GET 请求，所以报此路由不支持 GET 请求。 参考： 使用postman发送post请求，却报错不支持get请求的原因 ","date":"2023-03-28","objectID":"/posts/framework/springbootwenti/:1:1","tags":["Spring","SpringBoot"],"title":"SpringBoot问题收集","uri":"/posts/framework/springbootwenti/"},{"categories":["框架"],"content":"验证注解 ","date":"2023-03-27","objectID":"/posts/framework/springbootvalidated/:1:0","tags":["Spring","SpringBoot"],"title":"SpringBoot 参数校验","uri":"/posts/framework/springbootvalidated/"},{"categories":["框架"],"content":"@NotNull，@NotEmpty，@NotBlank 三者的区别 注意： @NotBlank 只能用来注解String @NotEmpty 只能注解字符串和集合和数组 @NotNull @NotEmpty @NotBlank String name = null; false false false String name = “”; true false false String name = \" “; true true false String name = “a”; true true true 总结： @NotNull要求字段必传，且不能为 null @NotEmpty要求字段必传，且不能为 null @NotBlank仅可修饰字符串，除了要求必传非 null，且要求字符串除了不可见字符，必须是有可见字符的 ","date":"2023-03-27","objectID":"/posts/framework/springbootvalidated/:1:1","tags":["Spring","SpringBoot"],"title":"SpringBoot 参数校验","uri":"/posts/framework/springbootvalidated/"},{"categories":["框架"],"content":"普通验证 ","date":"2023-03-27","objectID":"/posts/framework/springbootvalidated/:2:0","tags":["Spring","SpringBoot"],"title":"SpringBoot 参数校验","uri":"/posts/framework/springbootvalidated/"},{"categories":["框架"],"content":"分组验证 ","date":"2023-03-27","objectID":"/posts/framework/springbootvalidated/:3:0","tags":["Spring","SpringBoot"],"title":"SpringBoot 参数校验","uri":"/posts/framework/springbootvalidated/"},{"categories":["框架"],"content":"常见坑 ","date":"2023-03-27","objectID":"/posts/framework/springbootvalidated/:4:0","tags":["Spring","SpringBoot"],"title":"SpringBoot 参数校验","uri":"/posts/framework/springbootvalidated/"},{"categories":["框架"],"content":"参数上的校验注解只能校验 JavaBean @Data public class User { @NotNull(message = \"用户id不能为空\") private Integer id; } 仅使用@Valid和@Validated只能校验 JavaBean，无法校验List\u003cJavaBean\u003e public class UserController { public String addUser(@Valid @RequestBody List\u003cUser\u003e userList) } public class UserController { public String addUser(@Validated @RequestBody List\u003cUser\u003e userList) } 上述校验方法根本不起作用，也就是校验不生效。 控制器类加@Validated注解，控制器方法形参加@Validated也无法完成验证 @Validated public class UserController { public String addUser(@Validated @RequestBody List\u003cUser\u003e userList) } 那这里就有疑问了，不能使用@Validated，分组验证也不能用了吗？ 控制器类使用@Validated注解，控制器方法形参使用@Valid注解，方可验证集合 @Validated public class UserController { public String addUser(@Valid @RequestBody List\u003cUser\u003e userList) } ","date":"2023-03-27","objectID":"/posts/framework/springbootvalidated/:4:1","tags":["Spring","SpringBoot"],"title":"SpringBoot 参数校验","uri":"/posts/framework/springbootvalidated/"},{"categories":["框架"],"content":"参考 Validated数据校验，看这一篇就够了 使用@Validated校验List接口参数的两种方式 ","date":"2023-03-27","objectID":"/posts/framework/springbootvalidated/:5:0","tags":["Spring","SpringBoot"],"title":"SpringBoot 参数校验","uri":"/posts/framework/springbootvalidated/"},{"categories":["Java基础"],"content":"ArrayList.add报IndexOutOfBoundsException // 使用身份证号作为索引，方便直接用ID获取某个人的信息 List\u003cUser\u003e userList = new ArrayList\u003c\u003e(100); User user = new User(); user.setId(23); user.setName(\"我是张三\"); userList.add(user.getId(), user); 报错： java.lang.IndexOutOfBoundsException: Index: 23, Size: 0 ​ at java.util.ArrayList.rangeCheckForAdd(ArrayList.java:667) 明明指定了容量 100，访问 23 的位置还报数组越界。因为他检查的是数组的大小，而不是容量 看了源码，我们得出结论，只要索引值超过数组大小，或者索引值小于0，都会报索引越界。 if (index \u003e size || index \u003c 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); ","date":"2023-03-25","objectID":"/posts/java%E5%9F%BA%E7%A1%80/listshouce/:1:0","tags":["List","集合"],"title":"List常见问题","uri":"/posts/java%E5%9F%BA%E7%A1%80/listshouce/"},{"categories":["Java基础"],"content":"参考 https://blog.csdn.net/vandavidchou/article/details/104306445 ","date":"2023-03-25","objectID":"/posts/java%E5%9F%BA%E7%A1%80/listshouce/:1:1","tags":["List","集合"],"title":"List常见问题","uri":"/posts/java%E5%9F%BA%E7%A1%80/listshouce/"},{"categories":["框架"],"content":"json ","date":"2023-03-24","objectID":"/posts/framework/hutoolshouce/:1:0","tags":["framework","hutool"],"title":"hutool 框架使用笔记","uri":"/posts/framework/hutoolshouce/"},{"categories":["框架"],"content":"JSONArray转集合 String json = \"[2, 3, 5]\"; JSONArray jsonArray = JSONUtil.parseArray(json); // 转包装类型数组 List\u003cInteger\u003e integerList = jsonArray.toList(Integer.class); ","date":"2023-03-24","objectID":"/posts/framework/hutoolshouce/:1:1","tags":["framework","hutool"],"title":"hutool 框架使用笔记","uri":"/posts/framework/hutoolshouce/"},{"categories":["框架"],"content":"JSONArray转包装类型数组Integer[] 方案一，想当然地强转，报错 // Object[] objects = jsonArray.toArray(); Integer[] integers = (Integer[]) jsonArray.toArray(); 报错：java.lang.ClassCastException: [Ljava.lang.Object; cannot be cast to [Ljava.lang.Integer; 正确的方法： Object[] objects = jsonArray.toArray(); Integer[] integers = Arrays.copyOf(objects, objects.length, Integer[].class); 方案二 方案三：最笨的办法，使用逗号分割 json 串数组 String json = \"[2, 3, 5]\"; int[] ints = {2, 3, 5}; // 去除 json 数组字符串两侧的 [，] String substring = json.substring(1); String substring1 = substring.substring(0, substring.length() - 1); // 使用逗号分割字符串 String[] strings = substring1.split(\", \"); int[] ints3 = new int[strings.length]; for (int i = 0; i \u003c strings.length; i++) { ints3[i] = Integer.parseInt(strings[i]); } assertArrayEquals(ints, ints3); ","date":"2023-03-24","objectID":"/posts/framework/hutoolshouce/:1:2","tags":["framework","hutool"],"title":"hutool 框架使用笔记","uri":"/posts/framework/hutoolshouce/"},{"categories":["框架"],"content":"JSONArray转基本类型数组 方案一 // JSONArray 转基本类型数组 String json = \"[2, 3, 5]\"; JSONArray jsonArray = JSONUtil.parseArray(json); // 先转包装类型数组 List\u003cInteger\u003e integerList = jsonArray.toList(Integer.class); // 然后集合转转数组 int[] ints1 = integerList.stream().mapToInt(Integer::intValue).toArray(); int[] ints = {2, 3, 5}; assertArrayEquals(ints, ints1); 方案二 // 方法二： Object[] objects = jsonArray.toArray(); int[] ints2 = new int[objects.length]; for (int i = 0; i \u003c objects.length; i++) { ints2[i] = (int) objects[i]; } assertArrayEquals(ints, ints2); ","date":"2023-03-24","objectID":"/posts/framework/hutoolshouce/:1:3","tags":["framework","hutool"],"title":"hutool 框架使用笔记","uri":"/posts/framework/hutoolshouce/"},{"categories":["框架"],"content":"日期 ","date":"2023-03-24","objectID":"/posts/framework/hutoolshouce/:2:0","tags":["framework","hutool"],"title":"hutool 框架使用笔记","uri":"/posts/framework/hutoolshouce/"},{"categories":["框架"],"content":"常用时间格式枚举 2023-03-31 18:51:00 // 获取当前时间 String now = DateUtil.now(); // DateTime date = DateUtil.date(); Date date1 = new Date(); // 获取当前时间对象 String now2 = date.toString(); // 格式化：public static final String NORM_DATETIME_PATTERN = \"yyyy-MM-dd HH:mm:ss\"; String now3 = DateUtil.format(date1, DatePattern.NORM_DATETIME_PATTERN); String now4 = DateUtil.formatDateTime(date1); 2023-03-31 // public static final String NORM_DATE_PATTERN = \"yyyy-MM-dd\"; DateTime date = DateUtil.date(); Date date1 = new Date(); String day = DateUtil.format(date, DatePattern.NORM_DATE_FORMAT); String day1 = DateUtil.format(date1, DatePattern.NORM_DATE_FORMAT); String day2 = date.toString(DatePattern.NORM_DATE_PATTERN); assertEquals(day, day1); assertEquals(day1, day2); 18:51:00 // public static final String NORM_TIME_PATTERN = \"HH:mm:ss\"; DateTime date = DateUtil.date(); Date date1 = new Date(); String time = DateUtil.format(date, DatePattern.NORM_TIME_PATTERN); String time1 = DateUtil.format(date1, DatePattern.NORM_TIME_PATTERN); String time2 = date.toString(DatePattern.NORM_TIME_PATTERN); assertEquals(time, time1); assertEquals(time1, time2); Fri Mar 31 19:09:39 CST 2023 DateTime date = DateUtil.date(); Date date1 = new Date(); // Fri Mar 31 19:22:42 CST 2023 String now5 = date1.toString(); String now6 = date.toString(DatePattern.JDK_DATETIME_FORMAT); assertEquals(now5, now6); // 星期五 三月 31 19:22:42 CST 2023 String now7 = date.toString(DatePattern.JDK_DATETIME_PATTERN); ","date":"2023-03-24","objectID":"/posts/framework/hutoolshouce/:2:1","tags":["framework","hutool"],"title":"hutool 框架使用笔记","uri":"/posts/framework/hutoolshouce/"},{"categories":["工具"],"content":"现象 idea 的 Spring Boot 项目，使用了外置的 tomcat web 容器，跑起来就乱码了，网络上找了很多方案都未能解决。 24-Mar-2023 09:00:44.032 淇℃伅 [main] org.apache.catalina.startup.VersionLoggerListener.log Server.鏈嶅姟鍣ㄧ増鏈�: Apache Tomcat/8.5.64 ","date":"2023-03-24","objectID":"/posts/tools/ideaconsoleluanma/:1:0","tags":["idea","编辑器","乱码"],"title":"idea 控制台中文乱码","uri":"/posts/tools/ideaconsoleluanma/"},{"categories":["工具"],"content":"解决办法 编辑虚拟机配置 添加如下配置 -Dfile.encoding=UTF-8 保存并退出，重启 idea 即可。 ","date":"2023-03-24","objectID":"/posts/tools/ideaconsoleluanma/:2:0","tags":["idea","编辑器","乱码"],"title":"idea 控制台中文乱码","uri":"/posts/tools/ideaconsoleluanma/"},{"categories":["工具"],"content":"参考 https://blog.csdn.net/qq_18335837/article/details/107481963 https://www.cnblogs.com/ibigboy/p/11519412.html ","date":"2023-03-24","objectID":"/posts/tools/ideaconsoleluanma/:3:0","tags":["idea","编辑器","乱码"],"title":"idea 控制台中文乱码","uri":"/posts/tools/ideaconsoleluanma/"},{"categories":["Java基础"],"content":"基本数据类型和包装数据类型互转 ","date":"2023-03-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/javashujuleixinzhuanhuan/:1:0","tags":["java","变量"],"title":"Java数据类型转换","uri":"/posts/java%E5%9F%BA%E7%A1%80/javashujuleixinzhuanhuan/"},{"categories":["Java基础"],"content":"基本数据类型转包装数据类型 int int1 = 1; // 基本数据类型转包装数据类型：显式转换 Integer integer = Integer.valueOf(1); // 隐式转换 Integer integer1 = int1; assertEquals(integer, integer1); char a = 'a'; // 显式转换 Character character = new Character(a); // 隐式转换 Character character1 = a; assertEquals(character, character1); // 布尔 boolean b = false; Boolean b2 = new Boolean(b); Boolean b3 = b; assertEquals(b2, b3); ","date":"2023-03-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/javashujuleixinzhuanhuan/:1:1","tags":["java","变量"],"title":"Java数据类型转换","uri":"/posts/java%E5%9F%BA%E7%A1%80/javashujuleixinzhuanhuan/"},{"categories":["Java基础"],"content":"包装数据类型转基本数据类型 // 包装数据类型转基本数据类型 Integer integer1 = new Integer(123); Integer integer2 = 123; assertEquals(integer1, integer2); int i1 = integer1.intValue(); int i2 = integer2; assertTrue(i1 == i2); // 字符类型 Character character = new Character('b'); Character character1 = 'b'; assertEquals(character, character1); char c = character.charValue(); char c1 = character1.charValue(); assertEquals(c, c1); ","date":"2023-03-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/javashujuleixinzhuanhuan/:1:2","tags":["java","变量"],"title":"Java数据类型转换","uri":"/posts/java%E5%9F%BA%E7%A1%80/javashujuleixinzhuanhuan/"},{"categories":["Java基础"],"content":"基本数据类型数组和包装数据类型数组互转 ","date":"2023-03-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/javashujuleixinzhuanhuan/:2:0","tags":["java","变量"],"title":"Java数据类型转换","uri":"/posts/java%E5%9F%BA%E7%A1%80/javashujuleixinzhuanhuan/"},{"categories":["Java基础"],"content":"第三方工具库 import cn.hutool.core.util.ArrayUtil; int[] ids = {1, 2, 4}; // 基本类型数组转包装类型数组 Integer[] integers = ArrayUtil.wrap(ids); // 包装数据类型数组转基本数据类型数组 int[] ints1 = ArrayUtil.unWrap(integers); 原理看源码。 ","date":"2023-03-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/javashujuleixinzhuanhuan/:2:1","tags":["java","变量"],"title":"Java数据类型转换","uri":"/posts/java%E5%9F%BA%E7%A1%80/javashujuleixinzhuanhuan/"},{"categories":["Java基础"],"content":"stream流处理 int[] ids = {1, 2, 4}; // 基本类型数组转包装类型数组 Integer[] integers = (Integer[]) Arrays.stream(ids).boxed().toArray(); 报错了： java.lang.ClassCastException: [Ljava.lang.Object; cannot be cast to [Ljava.lang.Integer; 原因： 虽然 Integer 是 Object 的子类，但是 Integer[] 不是 Object[] 的子类，因为 Integer[] 是数组，我们都知道数组的父元素是 Object，可不是 Object[]。 所以不能有如下操作： Object[] objects; Integer[] integers = (Integer[]) objects; ","date":"2023-03-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/javashujuleixinzhuanhuan/:2:2","tags":["java","变量"],"title":"Java数据类型转换","uri":"/posts/java%E5%9F%BA%E7%A1%80/javashujuleixinzhuanhuan/"},{"categories":["Java基础"],"content":"数组转集合 ","date":"2023-03-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/javashujuleixinzhuanhuan/:3:0","tags":["java","变量"],"title":"Java数据类型转换","uri":"/posts/java%E5%9F%BA%E7%A1%80/javashujuleixinzhuanhuan/"},{"categories":["Java基础"],"content":"包装类型数组转集合 // 包装数据类型转集合 Integer[] integers = new Integer[]{1, 2}; List\u003cInteger\u003e integerList = Arrays.stream(integers).collect(Collectors.toList()); assertEquals(2, integerList.size()); assertEquals(1, (int) integerList.get(0)); assertEquals(2, (int) integerList.get(1)); ","date":"2023-03-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/javashujuleixinzhuanhuan/:3:1","tags":["java","变量"],"title":"Java数据类型转换","uri":"/posts/java%E5%9F%BA%E7%A1%80/javashujuleixinzhuanhuan/"},{"categories":["Java基础"],"content":"基本数据类型数组转集合 注意我们知道集合只能存放对象，不能存放基本数据类型，所以要将基本数据类型先转成包装数据类型。 // 基本数据类型数组转集合 int[] ints = new int[]{1, 2, 3}; List\u003cInteger\u003e integerList1 = Arrays.stream(ints).boxed().collect(Collectors.toList()); assertEquals(3, integerList1.size()); assertEquals(1, (int) integerList1.get(0)); assertEquals(3, (int) integerList1.get(2)); // 或者 String array[]= {\"hello\", \"world\"}; List\u003cString\u003e list = new ArrayList\u003cString\u003e(Arrays.asList(array)); // 这种操作，返回的一个静态内部类，少了一些方法，例如 add，remove java.util.Arrays.ArrayList\u003cString\u003e list = Arrays.asList(array); ","date":"2023-03-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/javashujuleixinzhuanhuan/:3:2","tags":["java","变量"],"title":"Java数据类型转换","uri":"/posts/java%E5%9F%BA%E7%A1%80/javashujuleixinzhuanhuan/"},{"categories":["框架"],"content":"注解 ","date":"2023-03-24","objectID":"/posts/framework/mybatisplusshouce/:1:0","tags":["MyBatisPlus","MyBatis"],"title":"MyBatisPlus使用笔记","uri":"/posts/framework/mybatisplusshouce/"},{"categories":["框架"],"content":"表实体注解 表名起别名 注解在实体类上，即此类映射库里的某个表名。 // 表 user_info 映射到实体 User @TableName(value = \"user_info\") public class User {} 表字段起别名 // 主键字段起别名 @TableId(value = \"id_number\") private Integer id; // 普通字段起别名 @TableField(value = \"xingming\") private String userName; 字段入库转 JSON 串 将注解注解在要转 json 的字段上。 import com.baomidou.mybatisplus.extension.handlers.JacksonTypeHandler; @TableField(typeHandler = FastjsonTypeHandler.class) private InnerClass innerClass; ","date":"2023-03-24","objectID":"/posts/framework/mybatisplusshouce/:1:1","tags":["MyBatisPlus","MyBatis"],"title":"MyBatisPlus使用笔记","uri":"/posts/framework/mybatisplusshouce/"},{"categories":["框架"],"content":"添加时间，更新时间使用数据字段填充功能 ","date":"2023-03-24","objectID":"/posts/framework/mybatisplusshouce/:2:0","tags":["MyBatisPlus","MyBatis"],"title":"MyBatisPlus使用笔记","uri":"/posts/framework/mybatisplusshouce/"},{"categories":["框架"],"content":"步骤 给时间字段添加填充场景，@TableField(fill = FieldFill.INSERT)或@TableField(fill = FieldFill.INSERT_UPDATE) 定义 SpringBoot 组件@Component，实现MetaObjectHandler ","date":"2023-03-24","objectID":"/posts/framework/mybatisplusshouce/:2:1","tags":["MyBatisPlus","MyBatis"],"title":"MyBatisPlus使用笔记","uri":"/posts/framework/mybatisplusshouce/"},{"categories":["框架"],"content":"参考 MyBatis-Plus事务管理 ","date":"2023-03-24","objectID":"/posts/framework/mybatisplusshouce/:3:0","tags":["MyBatisPlus","MyBatis"],"title":"MyBatisPlus使用笔记","uri":"/posts/framework/mybatisplusshouce/"},{"categories":["编辑器"],"content":"idea 报黄线，也不是报错，就是膈应你，告诉你这种做法不推荐。 import javax.servlet.http.HttpServletRequest; public class HttpMountainAop { @Autowired private HttpServletRequest httpServletRequest; } 大概意思是：这种字段注入的方式是不被推荐的。 既然不被推荐那推荐什么呢？推荐使用构造方法注入。 import javax.servlet.http.HttpServletRequest; public class HttpMountainAop { private final HttpServletRequest httpServletRequest; public HttpMountainAop(HttpServletRequest httpServletRequest) { this.httpServletRequest = httpServletRequest; } } ","date":"2023-03-17","objectID":"/posts/2023/field-injection-is-not-recommended/:0:0","tags":["工具","编辑器","idea"],"title":"field injection is not recommended","uri":"/posts/2023/field-injection-is-not-recommended/"},{"categories":["框架"],"content":"控制器请求方法里注入 HttpServletRequest import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import javax.servlet.http.HttpServletRequest; /** * @author Shali */ @RestController @RequestMapping(\"test\") public class TestController { @GetMapping(\"hello\") public String hello(HttpServletRequest httpServletRequest) { return httpServletRequest.getQueryString(); } } ","date":"2023-03-17","objectID":"/posts/2023/springmvchttpservletrequest/:1:0","tags":["Java","Java框架","SpringMVC"],"title":"SpringMVC 获取请求参数的 N 种方式","uri":"/posts/2023/springmvchttpservletrequest/"},{"categories":["框架"],"content":"利用 Spring 的依赖注入到控制器属性中 import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import javax.servlet.http.HttpServletRequest; /** * @author Shali */ @RestController @RequestMapping(\"test\") public class TestController { @Autowired private HttpServletRequest httpServletRequest; @GetMapping(\"hello\") public String hello() { return httpServletRequest.getQueryString(); } } ","date":"2023-03-17","objectID":"/posts/2023/springmvchttpservletrequest/:2:0","tags":["Java","Java框架","SpringMVC"],"title":"SpringMVC 获取请求参数的 N 种方式","uri":"/posts/2023/springmvchttpservletrequest/"},{"categories":["框架"],"content":"利用请求上下文获取 HttpServletRequest import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import org.springframework.web.context.request.RequestContextHolder; import org.springframework.web.context.request.ServletRequestAttributes; import javax.servlet.http.HttpServletRequest; import java.util.Objects; /** * @author Shali */ @RestController @RequestMapping(\"test\") public class TestController { @GetMapping(\"hello\") public String hello() { HttpServletRequest httpServletRequest = ((ServletRequestAttributes) Objects.requireNonNull(RequestContextHolder.getRequestAttributes())).getRequest(); return httpServletRequest.getQueryString(); } } ","date":"2023-03-17","objectID":"/posts/2023/springmvchttpservletrequest/:3:0","tags":["Java","Java框架","SpringMVC"],"title":"SpringMVC 获取请求参数的 N 种方式","uri":"/posts/2023/springmvchttpservletrequest/"},{"categories":["问"],"content":"背景： 有一次跟一个前端同事对接的时候，他传来的第一页 page 竟然是 0。我当时很惊讶，跟他理论了一番，他说公司某位领导告诉他页码从 0 开始传。 我回答他，业务逻辑层你可以像数组一样从 0 开始，但是界面展示，接口层，你就要按用户容易理解的常识从 1 开始。 ","date":"2023-03-04","objectID":"/posts/java%E5%9F%BA%E7%A1%80/fenye/:0:0","tags":["分页","http"],"title":"分页从0开始还是从1开始","uri":"/posts/java%E5%9F%BA%E7%A1%80/fenye/"},{"categories":["问"],"content":"参考 分页从0开始还是从1开始？ 分页工具-PageUtil ","date":"2023-03-04","objectID":"/posts/java%E5%9F%BA%E7%A1%80/fenye/:1:0","tags":["分页","http"],"title":"分页从0开始还是从1开始","uri":"/posts/java%E5%9F%BA%E7%A1%80/fenye/"},{"categories":["设计模式"],"content":"数据库 ","date":"2023-02-07","objectID":"/posts/designpatterns/sishierzhangjing/:1:0","tags":["四十二章经"],"title":"四十二章经","uri":"/posts/designpatterns/sishierzhangjing/"},{"categories":["设计模式"],"content":"建表 类型字段表，推荐使用名字枚举，而不是使用整型，虽然整型效率高，但是真的不适合观看和记忆 ","date":"2023-02-07","objectID":"/posts/designpatterns/sishierzhangjing/:1:1","tags":["四十二章经"],"title":"四十二章经","uri":"/posts/designpatterns/sishierzhangjing/"},{"categories":["设计模式"],"content":"接口对接 ","date":"2023-02-07","objectID":"/posts/designpatterns/sishierzhangjing/:2:0","tags":["四十二章经"],"title":"四十二章经","uri":"/posts/designpatterns/sishierzhangjing/"},{"categories":["设计模式"],"content":"日志 跟三方或二方接口交互时，一定要打印完整的上下行日志，否则出问题了只能互相扯皮。 ","date":"2023-02-07","objectID":"/posts/designpatterns/sishierzhangjing/:2:1","tags":["四十二章经"],"title":"四十二章经","uri":"/posts/designpatterns/sishierzhangjing/"},{"categories":["数据库"],"content":"语句 ","date":"2022-10-01","objectID":"/posts/database/sqlde100wen/:1:0","tags":["MySQL"],"title":"SQL一百问","uri":"/posts/database/sqlde100wen/"},{"categories":["数据库"],"content":"BETWEEN字句有顺序区别吗 # 语句 1 select id form t1 between '2022-10-01' and '2022-10-07'; # 语句 2 select id form t1 between '2022-10-07' and '2022-10-01'; 语句 1 与语句 2 有区别吗？ 有，语句 2 只会返回 null。 between 是闭区间吗？ 闭区间。 ","date":"2022-10-01","objectID":"/posts/database/sqlde100wen/:1:1","tags":["MySQL"],"title":"SQL一百问","uri":"/posts/database/sqlde100wen/"},{"categories":["编辑器"],"content":"常用替换正则 中文排版指北 多个空格替换成一个空格 在中文和英文之间增加空格 // 搜索 ([\\x{4e00}-\\x{9fa5}]{1})([0-9a-zA-Z]{1}) // 替换 $1 $2 // 搜索 ([0-9a-zA-Z]{1})([\\x{4e00}-\\x{9fa5}]{1}) // 替换 $1 $2 去除中文之间的空格 // 搜索 ([\\x{4e00}-\\x{9fa5}]{1}) ([\\x{4e00}-\\x{9fa5}]{1}) // 替换 $1$2 ","date":"2022-10-01","objectID":"/posts/tools/sublime/:0:1","tags":["sublime","工具","正则"],"title":"Sublime","uri":"/posts/tools/sublime/"},{"categories":["编辑器"],"content":"插件开发 开发文档 ","date":"2022-10-01","objectID":"/posts/tools/sublime/:1:0","tags":["sublime","工具","正则"],"title":"Sublime","uri":"/posts/tools/sublime/"},{"categories":["编辑器"],"content":"API view对象 ","date":"2022-10-01","objectID":"/posts/tools/sublime/:1:1","tags":["sublime","工具","正则"],"title":"Sublime","uri":"/posts/tools/sublime/"},{"categories":["设计模式"],"content":"微内核架构 微内核架构(Microkernel Architecture)，也称为插件化架构（Plug-in Architecture）。核心系统提供通用能力，由插件去实现业务功能。 基础库 + 微内核 + 系统插件 + 应用插件（分官方和第三方的） ","date":"2022-10-01","objectID":"/posts/designpatterns/hook/:1:0","tags":["钩子","标签","插件"],"title":"钩子插件标签","uri":"/posts/designpatterns/hook/"},{"categories":["设计模式"],"content":"插件的设计思想 插件的设计基本上可以归纳划分为三个部分：钩子声明、钩子注册、钩子调用。如图： 微内核框架声明钩子 插件将自己注册到特定场景的钩子中 微内核框架执行注册到钩子中的插件 框架在执行的过程中，在不同的业务场景，注册特定场景的钩子。而插件为了达到不同业务场景的定制，只需要将插件挂载到 specify 场景的钩子上。当框架执行到 specify 场景时，就会拽出挂载到此场景钩子下的插件，进而执行插件中的业务代码。 ==微内核+插件架构，就是分离应用的稳定和不稳定部分。框架内核业务相关性弱，稳定。而实现具体业务功能的插件，业务相关性强，且经常改动，不稳定。所以微内核插件架构，分离稳定代码和不稳定代码。同时不同插件实现不同业务，相关性弱，实现了业务解耦。== 基于插件构建的框架应用的能力是十分强大的，一个具有丰富的钩子接口的复杂应用，可以基于钩子产生无数的插件，甚至产生一个社区。 高中时期，我的物理老师曾说过一句话：“一流的学生学思想，二流的学生学方法，三流的学生学题目”，这句话让我印象十分深刻。学习一类事物，学习思想往往才是捷径。思想掌握了，往往也就会举一反三，触类旁通。 ","date":"2022-10-01","objectID":"/posts/designpatterns/hook/:2:0","tags":["钩子","标签","插件"],"title":"钩子插件标签","uri":"/posts/designpatterns/hook/"},{"categories":["设计模式"],"content":"参考 谈谈如何设计一个插件（Plugin）体系 ","date":"2022-10-01","objectID":"/posts/designpatterns/hook/:3:0","tags":["钩子","标签","插件"],"title":"钩子插件标签","uri":"/posts/designpatterns/hook/"},{"categories":null,"content":"应用站点 菜鸟教程 奥巴马 ","date":"2022-10-01","objectID":"/posts/opensource/wordpress/:1:0","tags":["CMS","WordPress"],"title":"开源应用Word Press","uri":"/posts/opensource/wordpress/"},{"categories":["数据库"],"content":"keys 命令与 scan 命令的区别 相同点和不同点： 操作 相同点 不同点 scan 时间复杂度O(n) 迭代扫描，消耗内存少 keys 时间复杂度O(n) 消耗内存大 ","date":"2022-09-26","objectID":"/posts/database/redisdescan/:1:0","tags":["Redis","Keys","Scan"],"title":"Redis 的使用讨论","uri":"/posts/database/redisdescan/"},{"categories":["数据库"],"content":"Q\u0026A ","date":"2022-09-26","objectID":"/posts/database/redisdescan/:2:0","tags":["Redis","Keys","Scan"],"title":"Redis 的使用讨论","uri":"/posts/database/redisdescan/"},{"categories":["数据库"],"content":"keys性能低，keys操作会锁整个库 还多少人看了网上的博客或者笔记，得出 keys 性能低，会锁整个库。那一定是你对底层不了解，或者网络文章的作者对底层一知半解。 我先把结论抛给你，然后再慢慢给你解释。 执行 Redis 的任何操作命令都会锁库，准确的说是锁整个服务器上的所有的 DB。 原因很简单，Redis 的 IO 操作是单线程的，执行任何一个操作命令都会其他操作命令无法得到执行。想要执行也要等前一个命令执行完成。 Redis 数据操作之所以 IO 单线程，是因为他认为多线程不过是为了提高效率，但是由于 Redis 操作的是内存，速度很快，反而引入了多线程，多线程的上下文切换，环境变量的保存与恢复反而降低了其效率。 其实现实应用中使用单线程的应用还是有很多的，例如 Nginx，NodeJS。 那为何大家实际使用中，没有感受到其他操作命令锁库，而是感觉到了 keys 锁库呢？ Redis 底层使用的哈希表结构，其查找时间复杂度是 O(1)。然而 keys 是使用正则遍历整个库中的所有 keys ，其时间复杂度是 O(n)。随着库里 key 的增多，keys 的执行时间变长，所以让大家明显感觉到其锁库。其实大家都锁库。 ","date":"2022-09-26","objectID":"/posts/database/redisdescan/:2:1","tags":["Redis","Keys","Scan"],"title":"Redis 的使用讨论","uri":"/posts/database/redisdescan/"},{"categories":["数据库"],"content":"项目使用了 key 做队列，使用 scan 获取队列，如何优化 首先说下你使用 key 做队列的缺点，队列中的元素位置是随机的，scan 获取出来的元素也是随机的，所以在消费任务的时候，不符合队列的 FIFO 准则。 其次如果你每次 scan 获取的元素数量有限，而 DB 中的 key 过多，就大大地增加了网络 IO 的次数。==我们知道 Redis 的性能瓶颈在网络 IO==，如果这样倒不如使用 keys 来的痛快。 如果这样说大家可能糊涂了，明明为了解决 keys 的低性能，引入的 scan，你这里又说 keys 比 scan 来的痛快，那么二者该如何取舍呢？ 操作 使用场景 使用原因 keys DB 中 key 多，但是目标 key 少的情况 避免 scan 过多的网络 IO 请求，却命中率不高 scan DB 中目标 key 多，非目标 key 少的情况 避免 keys 返回的目标数据量过大，造成内存溢出。 二者的使用是为了达到一个均衡的效率。以上讨论仅限于在 keys 和 scan 二者中间的取舍。毕竟其他数据结构优于他们。 ","date":"2022-09-26","objectID":"/posts/database/redisdescan/:2:2","tags":["Redis","Keys","Scan"],"title":"Redis 的使用讨论","uri":"/posts/database/redisdescan/"},{"categories":null,"content":"SQL优化 ","date":"2022-09-25","objectID":"/posts/database/youhua/:1:0","tags":["Redis","NoSQL","Scan"],"title":"MySQL优化","uri":"/posts/database/youhua/"},{"categories":null,"content":"Using index condition 与 Using index 的区别 using index 代表使用覆盖索引，不用回表。 而 using index condition 表示仅靠索引返回的数据还不够，还需要回表，不过回表前会过滤 where 条件。 ","date":"2022-09-25","objectID":"/posts/database/youhua/:1:1","tags":["Redis","NoSQL","Scan"],"title":"MySQL优化","uri":"/posts/database/youhua/"},{"categories":null,"content":"索引 ","date":"2022-09-25","objectID":"/posts/database/youhua/:2:0","tags":["Redis","NoSQL","Scan"],"title":"MySQL优化","uri":"/posts/database/youhua/"},{"categories":null,"content":"指导 MySQL 使用索引 force index(索引名称) 强制 mysql 优化器使用索引，没有商量余地。 use index(索引名称) 建议 mysql 优化器，使用我们建议的索引，只是建议不代表真的使用。 ignore index(索引名称) 强制 mysql 优化器不使用某个索引，即忽略此索引。 ","date":"2022-09-25","objectID":"/posts/database/youhua/:2:1","tags":["Redis","NoSQL","Scan"],"title":"MySQL优化","uri":"/posts/database/youhua/"},{"categories":null,"content":"分库 ","date":"2022-09-25","objectID":"/posts/database/youhua/:3:0","tags":["Redis","NoSQL","Scan"],"title":"MySQL优化","uri":"/posts/database/youhua/"},{"categories":null,"content":"逻辑分库 根据群里讨论，逻辑分库是指单服务器上，创建多个 database 的分库。 关于逻辑分库的性能讨论 ","date":"2022-09-25","objectID":"/posts/database/youhua/:3:1","tags":["Redis","NoSQL","Scan"],"title":"MySQL优化","uri":"/posts/database/youhua/"},{"categories":null,"content":"物理分库 ","date":"2022-09-25","objectID":"/posts/database/youhua/:3:2","tags":["Redis","NoSQL","Scan"],"title":"MySQL优化","uri":"/posts/database/youhua/"},{"categories":["工具"],"content":"常见问题 ","date":"2022-09-25","objectID":"/posts/tools/nginx/:1:0","tags":["web服务器","nginx"],"title":"Nginx","uri":"/posts/tools/nginx/"},{"categories":["工具"],"content":"nginx 用 root 用户启动,仍然遇到 403 /usr/sbin/sestatus -v 解决办法,关闭 setenforce 0 ","date":"2022-09-25","objectID":"/posts/tools/nginx/:1:1","tags":["web服务器","nginx"],"title":"Nginx","uri":"/posts/tools/nginx/"},{"categories":["工具"],"content":"数据库 ","date":"2022-09-25","objectID":"/posts/framework/online/:1:0","tags":["在线工具","免费在线工具"],"title":"分享最好用的100个免费在线工具","uri":"/posts/framework/online/"},{"categories":["工具"],"content":"SQLAdvisor 一个连接你的 MySQL 服务器，并对你的 sql 给出优化建议的开源工具。 美团点评SQL优化工具SQLAdvisor开源 Github仓库 ","date":"2022-09-25","objectID":"/posts/framework/online/:1:1","tags":["在线工具","免费在线工具"],"title":"分享最好用的100个免费在线工具","uri":"/posts/framework/online/"},{"categories":["工具"],"content":"JSON ","date":"2022-09-25","objectID":"/posts/tools/manual/:1:0","tags":["在线工具","手册"],"title":"官方在线手册","uri":"/posts/tools/manual/"},{"categories":["工具"],"content":"JSON官方在线手册 ","date":"2022-09-25","objectID":"/posts/tools/manual/:1:1","tags":["在线工具","手册"],"title":"官方在线手册","uri":"/posts/tools/manual/"},{"categories":["工具"],"content":"JavaScript ","date":"2022-09-25","objectID":"/posts/tools/manual/:2:0","tags":["在线工具","手册"],"title":"官方在线手册","uri":"/posts/tools/manual/"},{"categories":["工具"],"content":"IBM 官方手册 ","date":"2022-09-25","objectID":"/posts/tools/manual/:2:1","tags":["在线工具","手册"],"title":"官方在线手册","uri":"/posts/tools/manual/"},{"categories":["工具"],"content":"微软 MSDN 官方手册 ","date":"2022-09-25","objectID":"/posts/tools/manual/:2:2","tags":["在线工具","手册"],"title":"官方在线手册","uri":"/posts/tools/manual/"},{"categories":["工具"],"content":"火狐社区 ","date":"2022-09-25","objectID":"/posts/tools/manual/:2:3","tags":["在线工具","手册"],"title":"官方在线手册","uri":"/posts/tools/manual/"},{"categories":["数据库"],"content":"要求 由于使用有序集合的 score 充当延时时间，要求所有客户端时钟保持一致 ","date":"2022-09-25","objectID":"/posts/database/redisdelaymq/:1:0","tags":["Redis","NoSQL","延时消息队列","消息队列"],"title":"基于Redis有序集合的延时消息队列实现","uri":"/posts/database/redisdelaymq/"},{"categories":["数据库"],"content":"特点 延时队列基于 Redis 的有序集合，底层是 Hash 表，所以查找和删除的时间复杂度是 O(1)。 持久化，基于 Redis 的内存持久化。 任务支持超时释放 ","date":"2022-09-25","objectID":"/posts/database/redisdelaymq/:2:0","tags":["Redis","NoSQL","延时消息队列","消息队列"],"title":"基于Redis有序集合的延时消息队列实现","uri":"/posts/database/redisdelaymq/"},{"categories":["数据库"],"content":"注意 Redis 的 Lua 脚本，返回 true 实际返回 int(1)，0，1，false 都会原样返回。 ","date":"2022-09-25","objectID":"/posts/database/redisdelaymq/:3:0","tags":["Redis","NoSQL","延时消息队列","消息队列"],"title":"基于Redis有序集合的延时消息队列实现","uri":"/posts/database/redisdelaymq/"},{"categories":["Java基础"],"content":" 约定大于配置，配置大于代码。 ","date":"2022-09-25","objectID":"/posts/yueding/duijie/:0:0","tags":["对接","接口","前端"],"title":"前后端对接中的问题","uri":"/posts/yueding/duijie/"},{"categories":["Java基础"],"content":"0 和空字符串也是有意义的 ==很多前后端在对接搜索接口时，总喜欢将字段传空字符串或者传 0 代表所有类型。这是不合适的。== 如果后端开发主导这么干，我认为是不合格的。 如果是前端主导这么做，我站在前端的位置是能够理解的他的想法的。因为他定义好了一个 model 数据表单对象，当用户选择全部时，他又需要从对象中剃掉一个属性，这无形中增加了他的工作量。 ","date":"2022-09-25","objectID":"/posts/yueding/duijie/:1:0","tags":["对接","接口","前端"],"title":"前后端对接中的问题","uri":"/posts/yueding/duijie/"},{"categories":["Java基础"],"content":"为何不能这么做 因为容易产生歧义。 因为在我们表字段中，0 有时候是有特殊含义的，他有可能代表某种状态。例如 0 在表中代表停用状态，你传来个 0 ，到底是让我输出所有状态的用户给你，还是仅返回停用状态的用户列表呢。这不就产生歧义了吗。 对于空字符串，新建表的时候，表中很多字符串字段，都喜欢配置一个默认值，即空字符串。如果这个字段使用了空字符串默认值，那么表中此字段必然会有很多空字符串。如果你给这个字段提交一个空字符串，那么我是返回表中所有列表给你还是仅返回此字段为空字符串的列表集合给你呢。 ","date":"2022-09-25","objectID":"/posts/yueding/duijie/:1:1","tags":["对接","接口","前端"],"title":"前后端对接中的问题","uri":"/posts/yueding/duijie/"},{"categories":["Java基础"],"content":"如何解决 那能不能不使用空字符串和 0 ，又能减少前端工作量呢？ 可以，前后端可以自行定义其他类型代替全部即可。 ","date":"2022-09-25","objectID":"/posts/yueding/duijie/:1:2","tags":["对接","接口","前端"],"title":"前后端对接中的问题","uri":"/posts/yueding/duijie/"},{"categories":["PHP"],"content":"PHP 易错点 ","date":"2022-09-17","objectID":"/posts/php/php%E6%98%93%E9%94%99%E7%82%B9/:0:0","tags":["PHP高级"],"title":"PHP易错点","uri":"/posts/php/php%E6%98%93%E9%94%99%E7%82%B9/"},{"categories":["PHP"],"content":"PHP 内置回调事件 # 程序结束（包含正常结束和异常结束）时，触发此回调 register_shutdown_function(function () { // 获取上一个错误，如果是正常结束返回的是 NULL $error = error_get_last(); }); # 注册 \\Exception 抛出时的回调处理 set_exception_handler(function (\\Exception $exception) { }); # 注册 \\Error 抛出时的回调处理 set_error_handler(function ($iErrNo, $sErrStr, $sErrFile, $iErrLine) { }); # 注册类加载 spl_autoload_register(function ($sClassName) { }); ","date":"2022-09-17","objectID":"/posts/php/php%E6%98%93%E9%94%99%E7%82%B9/:1:0","tags":["PHP高级"],"title":"PHP易错点","uri":"/posts/php/php%E6%98%93%E9%94%99%E7%82%B9/"},{"categories":["PHP"],"content":"注册完，支持运行时移除的回调 restore_error_handler function a() {} function b() {} // 注册错误处理函数 a set_error_handler('a'); // 修改错误处理函数为 b set_error_handler('b'); // 恢复为原来错误处理函数 a restore_error_handler(); restore_exception_handler \u003c?php function exception_handler_1(Exception $e) { echo '[' . __FUNCTION__ . '] ' . $e-\u003egetMessage(); } function exception_handler_2(Exception $e) { echo '[' . __FUNCTION__ . '] ' . $e-\u003egetMessage(); } set_exception_handler('exception_handler_1'); set_exception_handler('exception_handler_2'); restore_exception_handler(); throw new Exception('This triggers the first exception handler...'); // 输出结果：[exception_handler_1] This triggers the first exception handler... ?\u003e ","date":"2022-09-17","objectID":"/posts/php/php%E6%98%93%E9%94%99%E7%82%B9/:1:1","tags":["PHP高级"],"title":"PHP易错点","uri":"/posts/php/php%E6%98%93%E9%94%99%E7%82%B9/"},{"categories":["PHP"],"content":"高手擅长回避的问题 ","date":"2022-09-17","objectID":"/posts/php/php%E6%98%93%E9%94%99%E7%82%B9/:2:0","tags":["PHP高级"],"title":"PHP易错点","uri":"/posts/php/php%E6%98%93%E9%94%99%E7%82%B9/"},{"categories":["PHP"],"content":"非 0 即真 self::assertSame(7, 7 ?: 1); self::assertSame(1, 0 ?: 1); // 你是不是以为下面的结果是 1 啊 self::assertSame(-2, -2 ?: 1); 总结： $var3 = (非 0 即真) ? $va1 : $val2; 知道了非 0 即真，那么下面的答案就简单了。 if (-1) { var_dump(1); } else { var_dump(0); } 输出：int(1) ","date":"2022-09-17","objectID":"/posts/php/php%E6%98%93%E9%94%99%E7%82%B9/:2:1","tags":["PHP高级"],"title":"PHP易错点","uri":"/posts/php/php%E6%98%93%E9%94%99%E7%82%B9/"},{"categories":["PHP"],"content":"PHP 8.0 终于对了 ","date":"2022-09-17","objectID":"/posts/php/php%E6%98%93%E9%94%99%E7%82%B9/:2:2","tags":["PHP高级"],"title":"PHP易错点","uri":"/posts/php/php%E6%98%93%E9%94%99%E7%82%B9/"},{"categories":["PHP"],"content":"OPcache 和 OPcode 的关系 最近你是不是也被这个问题困惑，那我们一起来翻阅 PHP 手册来需求解答。 在 PHP 手册的 函数参考 \u003e 影响 PHP 行为的扩展 \u003e OPcache 有专业的解答。 OPcache 通过将 PHP 脚本预编译的字节码存储到共享内存中来提升 PHP 的性能， 存储预编译字节码的好处就是 省去了每次加载和解析 PHP 脚本的开销。 那么 OPcode 是什么？你还没解释。 什么，不是说了吗？ OPcode 就是字节码，相当于 Java 开发中的 xxx.class，PHP 的 Zend VM 解析引擎就类似 Java 的 VM 说白了就是，用 OPcache 这个扩展来缓存 OPcode 到内存，从而来提高 PHP 的解析速度。 更多使用技巧请参考: 使用 OpCache 提升 PHP 性能 ","date":"2022-09-17","objectID":"/posts/php/php%E6%98%93%E9%94%99%E7%82%B9/:3:0","tags":["PHP高级"],"title":"PHP易错点","uri":"/posts/php/php%E6%98%93%E9%94%99%E7%82%B9/"},{"categories":["PHP"],"content":"内存中的堆栈区别 很多是否还是会碰到堆栈，那堆栈是什么，区别又是什么，是时候花时间弄明白了。 栈 堆 大小 不大，最大也就10M 手动释放内存 不需要，临时空间 函数退出后系统释放 存放数据 方法调用，所有局部变量和函数的参数 ","date":"2022-09-17","objectID":"/posts/php/php%E6%98%93%E9%94%99%E7%82%B9/:4:0","tags":["PHP高级"],"title":"PHP易错点","uri":"/posts/php/php%E6%98%93%E9%94%99%E7%82%B9/"},{"categories":["PHP"],"content":"const 与 define 有何区别 我们知道 const 和 define 都可以定义全局常量，那么他们有和区别呢？ \u003c?php const VERSION = '3.2.3'; defined('ADDON_PATH') or define('ADDON_PATH', APP_PATH . 'Addon'); 总结一下，就是，如果定义的常量没有其他常量条件限制，就使用const常量定义语法，如果有条件限制，则使用宏定义define来定义常量。 ","date":"2022-09-17","objectID":"/posts/php/php%E6%98%93%E9%94%99%E7%82%B9/:5:0","tags":["PHP高级"],"title":"PHP易错点","uri":"/posts/php/php%E6%98%93%E9%94%99%E7%82%B9/"},{"categories":["PHP"],"content":"var_export 高级用法 高级应用，代码压缩。 ","date":"2022-09-17","objectID":"/posts/php/php%E6%98%93%E9%94%99%E7%82%B9/:6:0","tags":["PHP高级"],"title":"PHP易错点","uri":"/posts/php/php%E6%98%93%E9%94%99%E7%82%B9/"},{"categories":["PHP"],"content":"字符串方法使用 ","date":"2022-09-17","objectID":"/posts/php/php%E6%98%93%E9%94%99%E7%82%B9/:7:0","tags":["PHP高级"],"title":"PHP易错点","uri":"/posts/php/php%E6%98%93%E9%94%99%E7%82%B9/"},{"categories":["PHP"],"content":"strpos 字符串匹配 不推荐的用法 \u003c?php if (!strpos('hello', 'h')) { exit('不存在 h'); } else { exit('存在 h'); } 结果：不存在 h 原因：strpos('hello', 'h') 返回的索引是 0，由于弱类型，被当作 false 处理了。 推荐用法 \u003c?php if (false === strpos('hello', 'h')) { exit('不存在 h'); } else { exit('存在 h'); } 结果：存在 h ","date":"2022-09-17","objectID":"/posts/php/php%E6%98%93%E9%94%99%E7%82%B9/:7:1","tags":["PHP高级"],"title":"PHP易错点","uri":"/posts/php/php%E6%98%93%E9%94%99%E7%82%B9/"},{"categories":["PHP"],"content":"如何获取方法调用处的文件名，行号？ ","date":"2022-09-17","objectID":"/posts/php/fileandline/:0:0","tags":["PHP高级"],"title":"如何获得方法/函数调用处的文件名和行号","uri":"/posts/php/fileandline/"},{"categories":["PHP"],"content":"需求 很多时候我们打印日志的时候，需要获取日志被打印的位置，具体来说就是文件名和行号。或者类的完整限定名和行号也行。只要能让我们精准定位打印的位置即可。 ","date":"2022-09-17","objectID":"/posts/php/fileandline/:1:0","tags":["PHP高级"],"title":"如何获得方法/函数调用处的文件名和行号","uri":"/posts/php/fileandline/"},{"categories":["PHP"],"content":"实现 在 PHP 中我们知道有 2 个魔术常量，真的很好用，__FILE__和__LINE__。很多时候我们使用他获取当前的文件名和行号。 ","date":"2022-09-17","objectID":"/posts/php/fileandline/:2:0","tags":["PHP高级"],"title":"如何获得方法/函数调用处的文件名和行号","uri":"/posts/php/fileandline/"},{"categories":["PHP"],"content":"错误实现 class Test { /** * @param $message */ private function log($message) { echo sprintf('File: %s Line: %d Info: %s', __FILE__, __LINE__, $message); } public function testLog() { $this-\u003elog('进入业务方法中了'); } } 打印的行号不是调用处的行号，而是 __LINE__ 所处的行号。 曲线救国： class Test { /** * @param $message */ private function log($file, $line, $message) { echo sprintf('File: %s Line: %d Info: %s', $file, $line, $message); } public function testLog() { $this-\u003elog(__FILE__, __LINE__, '进入业务方法中了'); } } 上面的实现确实能够精准定位调用处的文件和行号，但是方法的调用不好用。每次都需要带上形参文件名和行号。重复啰嗦。 能不能优化？ ","date":"2022-09-17","objectID":"/posts/php/fileandline/:2:1","tags":["PHP高级"],"title":"如何获得方法/函数调用处的文件名和行号","uri":"/posts/php/fileandline/"},{"categories":["PHP"],"content":"PHP PHP 获取调用堆栈位置。 我们知道代码的执行是先压栈，然后再弹栈，依次执行调用关系。那我们完全可以借助调用栈里的信息来解决上面问题。 class Test { /** * @param $message */ private function log($message) { $debug_backtrace = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 1); echo sprintf('File: %s Line: %d Info: %s', $debug_backtrace[0]['file'], $debug_backtrace[0]['line'], $message); } public function testLog() { $this-\u003elog('进入业务方法中了'); } } 改良后，打印的行号和文件号就不再是定义处而是调用处，符合要去。 关于 debug_backtrace() 函数的参数使用，DEBUG_BACKTRACE_IGNORE_ARGS 获取调用栈数组，不包含参数，这样能够节省运行时内存，1 表示仅返回调用栈的栈顶元素，也就是仅返回 1 条，节省运行时内存。如果是 0 代表返回整个调用栈。 ","date":"2022-09-17","objectID":"/posts/php/fileandline/:2:2","tags":["PHP高级"],"title":"如何获得方法/函数调用处的文件名和行号","uri":"/posts/php/fileandline/"},{"categories":["PHP"],"content":"Java package com.shali.ruby.bean; import org.slf4j.Logger; import org.slf4j.LoggerFactory; public class Test { private static final Logger log = LoggerFactory.getLogger(Test.class); public void testLog() { this.log.info('进入业务方法中了'); } } 打印日志： 行号 27 2022-09-14 21:09:00.743 DEBUG 22356 --- [http-nio-80-exec-2] com.shali.ruby.bean.Test : 进入业务方法中了 上面日志打印了日志打印调用处的行号，时间，进程号，线程号，包名，日志信息。 ","date":"2022-09-17","objectID":"/posts/php/fileandline/:2:3","tags":["PHP高级"],"title":"如何获得方法/函数调用处的文件名和行号","uri":"/posts/php/fileandline/"},{"categories":["PHP"],"content":"原理 ","date":"2022-09-17","objectID":"/posts/php/fileandline/:3:0","tags":["PHP高级"],"title":"如何获得方法/函数调用处的文件名和行号","uri":"/posts/php/fileandline/"},{"categories":["工具"],"content":"命令手册 ","date":"2022-09-16","objectID":"/posts/tools/git/:1:0","tags":["git"],"title":"Git使用命令手册大全","uri":"/posts/tools/git/"},{"categories":["工具"],"content":"分支操作 查看分支 查看本地分支 git branch 查看远程分支 git branch -r 查看所有分支，包含本地和远程 git branch -a 切换分支 git checkout branchName 创建并切换分支 git checkout -b newBranchName 推送本地创建的分支到远程仓库 git push origin newBranchName 推送本地分支代码到远程分支 也就是将当前本地分支与远程仓库分支建立关联关系。 git push --set-upstream origin newBranchName 删除本地分支 git branch -d branchName 创建远程分支 git push origin --set-upstream newBranchName 删除远程分支 git push origin --delete branchName ","date":"2022-09-16","objectID":"/posts/tools/git/:1:1","tags":["git"],"title":"Git使用命令手册大全","uri":"/posts/tools/git/"},{"categories":["数据库"],"content":"Scan使用中存在的问题 public function scan(\u0026$iterator, $pattern = null, $count = 0) 游标 $iterator 初始值为 null，当其返回值为 0 时表示整个迭代结束。 $count 是每次迭代遍历字典槽的数量（约等于），可认为是每次迭代返回元素的最大个数，并不是指定返回元素的数量 存在的问题： 如果指定的 COUNT 过小，整个迭代过程会很长。 ","date":"2022-09-16","objectID":"/posts/database/rediscuowu/:1:0","tags":["redis","nosql"],"title":"Redis使用过程中存在的问题","uri":"/posts/database/rediscuowu/"},{"categories":["工具"],"content":"网络工具 ","date":"2022-09-15","objectID":"/posts/tools/100onlinegongju/:1:0","tags":["在线工具"],"title":"100个实用的开发者在线工具","uri":"/posts/tools/100onlinegongju/"},{"categories":["工具"],"content":"HTTP Echo服务器 方便 HTTP 协议调试，服务器返回请求的数据。 Getman HttpBin HttpBinGo ","date":"2022-09-15","objectID":"/posts/tools/100onlinegongju/:1:1","tags":["在线工具"],"title":"100个实用的开发者在线工具","uri":"/posts/tools/100onlinegongju/"},{"categories":["工具"],"content":"图片在线识别 图片转文字 - 图片转Excel表格 - PDF转Word - 白描网页版 ","date":"2022-09-15","objectID":"/posts/tools/100onlinegongju/:1:2","tags":["在线工具"],"title":"100个实用的开发者在线工具","uri":"/posts/tools/100onlinegongju/"},{"categories":["工具"],"content":"离线下载 ","date":"2022-09-15","objectID":"/posts/tools/100onlinegongju/:2:0","tags":["在线工具"],"title":"100个实用的开发者在线工具","uri":"/posts/tools/100onlinegongju/"},{"categories":["工具"],"content":"Chrome扩展离线下载 Getman ","date":"2022-09-15","objectID":"/posts/tools/100onlinegongju/:2:1","tags":["在线工具"],"title":"100个实用的开发者在线工具","uri":"/posts/tools/100onlinegongju/"},{"categories":["工具"],"content":"脚手架工具 ","date":"2022-09-15","objectID":"/posts/tools/100onlinegongju/:3:0","tags":["在线工具"],"title":"100个实用的开发者在线工具","uri":"/posts/tools/100onlinegongju/"},{"categories":["工具"],"content":"Java工程脚手架 阿里云 - Java工程脚手架（不推荐，版本过旧） Spring 官方脚手架 - Spring Initializr ","date":"2022-09-15","objectID":"/posts/tools/100onlinegongju/:3:1","tags":["在线工具"],"title":"100个实用的开发者在线工具","uri":"/posts/tools/100onlinegongju/"},{"categories":["四十二章经"],"content":"Double Checked Locking，双重检测锁，DCL 我们知道加锁的代价是昂贵的，因为加锁了才能检查，那为何不在加锁前检查一次呢，如果存在，都不需要走到带锁代码，这样即安全，又提高了性能，唯一的缺点就是检查了 2 次。 ","date":"2022-09-07","objectID":"/posts/yueding/gaodashang/:0:1","tags":["基础","Java"],"title":"高大上的技术","uri":"/posts/yueding/gaodashang/"},{"categories":["四十二章经"],"content":"内存可见性 ","date":"2022-09-07","objectID":"/posts/yueding/gaodashang/:0:2","tags":["基础","Java"],"title":"高大上的技术","uri":"/posts/yueding/gaodashang/"},{"categories":["四十二章经"],"content":"指令重排序 ","date":"2022-09-07","objectID":"/posts/yueding/gaodashang/:0:3","tags":["基础","Java"],"title":"高大上的技术","uri":"/posts/yueding/gaodashang/"},{"categories":["四十二章经"],"content":"busy-waiting 忙等待 进程/线程执行到一段循环程序的时候，由于循环判断条件不能满足而导致处理器反复循环，处于繁忙状态，该进程/线程虽然繁忙但无法前进。 ","date":"2022-09-07","objectID":"/posts/yueding/gaodashang/:0:4","tags":["基础","Java"],"title":"高大上的技术","uri":"/posts/yueding/gaodashang/"},{"categories":["四十二章经"],"content":"重入Reentrant 为什么中断处理函数不能直接调用不可重入函数？ 在多任务系统下，中断可能在任务执行的任何时间发生；如果一个函数的执行期间被中断后，到重新恢复到断点进行执行的过程中，函数所依赖的环境没有发生改变，那么这个函数就是可重入的，否则就不可重入。 在中断前后不都要保存和恢复上下文吗，怎么会出现函数所依赖的环境发生改变了呢？我们知道中断时确实保存一些上下文，但是仅限于返回地址，cpu 寄存器等之类的少量上下文，而函数内部使用的诸如全局或静态变量，buffer 等并不在保护之列，所以如果这些值在函数被中断期间发生了改变，那么当函数回到断点继续执行时，其结果就不可预料了。 在中断处理函数中调用有互斥锁保护的全局变量，如果恰好该变量正在被另一个线程调用，会导致中断处理函数不能及时返回，导致中断丢失等严重问题。 并且在多线程环境中使用，在没有加锁的情况下，对同一段内存块进行并发读写，就会造成 segmentfault/coredump 之类的问题。 总而言之，中断处理函数做的事情越简单越好。 ","date":"2022-09-07","objectID":"/posts/yueding/gaodashang/:0:5","tags":["基础","Java"],"title":"高大上的技术","uri":"/posts/yueding/gaodashang/"},{"categories":["四十二章经"],"content":"如何解决缓存一致性 我们的程序太快，如果直接与数据库交互，数据库太慢，CPU 总是在等待，不要说什么多线程，IO 太慢时，线程频繁调度也没用。 为了解决上述问题，在程序和数据库中间加上缓存，那么又来了新的问题，更新数据时存在，存在数据不一致问题。 大咖秀 现代 CPU 中，如果 CPU 直接与内存交互，则存在内存速度太慢，CPU 太快总是在等待的问题。即内存拉低了 CPU 的效率。 为了解决上述问题，在 CPU 与内存之间加入很多寄存器，和多级缓存。可是这样又引发了新的问题。 由于 CPU 与内存之间加入了缓存，在进行数据操作时，先将数据从内存拷贝到缓存中，CPU 直接操作的是缓存中的数据。但在多处理器下，将可能导致各自的缓存数据不一致（这也是可见性问题的由来），为了保证各个处理器的缓存是一致的，就要实现==缓存一致性协议==，而==嗅探==是实现缓存一致性的常见机制。 ","date":"2022-09-07","objectID":"/posts/yueding/gaodashang/:0:6","tags":["基础","Java"],"title":"高大上的技术","uri":"/posts/yueding/gaodashang/"},{"categories":["四十二章经"],"content":"OOD OOD 是一种解决软件问题的设计范式（paradigm），一种抽象的范式。 使用 OOD 这种设计范式，我们可以用对象（object）来表现问题领域（problem domain）的实体，每个对象都有相应的状态和行为。 ","date":"2022-09-07","objectID":"/posts/yueding/gaodashang/:0:7","tags":["基础","Java"],"title":"高大上的技术","uri":"/posts/yueding/gaodashang/"},{"categories":["四十二章经"],"content":"自旋和挂起 自旋也叫忙等（busy-wait），采用这种方式的线程不会被挂起，而是会消耗一定的 CPU 资源去循环 check 是否可以执行了。 挂起就是把你从 CPU 的使用中换出，当可用的时候再让你运行。这种换进换出叫着上下文切换，上下文是需要 CPU 调度开销的，一般是相当于 5000~10000 个时钟周期，对于主频为 1GHz 的 CPU 来说，也就是需要 1 到 2 个微秒。 大概的意思是，如果自旋开销小于上下文切换开销，则推荐使用自旋，反之使用挂起。也就是说如果竞争不激励，自旋高效；竞争激励，线程等待时间长，挂起更高效。同样的道理同样适用其它领域：交通信号灯在拥堵的交通状况下能带来更好的吞吐量，但是环岛在低拥堵的情况下能够带来更好的吞吐量。 ———————————————— 版权声明：本文为CSDN博主「张建飞（Frank）」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/significantfrank/article/details/80399179 ","date":"2022-09-07","objectID":"/posts/yueding/gaodashang/:0:8","tags":["基础","Java"],"title":"高大上的技术","uri":"/posts/yueding/gaodashang/"},{"categories":["工具"],"content":"茴香豆的茴的写法有以下几种，分别是茴，回，囘，囬。 ","date":"2022-09-07","objectID":"/posts/framework/huixiangdouxiefa/:0:0","tags":["工具","技巧"],"title":"茴香豆的茴有几种写法","uri":"/posts/framework/huixiangdouxiefa/"},{"categories":["工具"],"content":"单例有几种实现方法 8种，有一种懒汉单例使用了 DCL。 单例的指令重排。volatile 可以在单例双重检查中实现可见性和禁止指令重排序，从而保证安全性。 ","date":"2022-09-07","objectID":"/posts/framework/huixiangdouxiefa/:1:0","tags":["工具","技巧"],"title":"茴香豆的茴有几种写法","uri":"/posts/framework/huixiangdouxiefa/"},{"categories":["工具"],"content":"静态内部类，线程安全 ","date":"2022-09-07","objectID":"/posts/framework/huixiangdouxiefa/:1:1","tags":["工具","技巧"],"title":"茴香豆的茴有几种写法","uri":"/posts/framework/huixiangdouxiefa/"},{"categories":["工具"],"content":"饿汉，线程安全 ","date":"2022-09-07","objectID":"/posts/framework/huixiangdouxiefa/:1:2","tags":["工具","技巧"],"title":"茴香豆的茴有几种写法","uri":"/posts/framework/huixiangdouxiefa/"},{"categories":["工具"],"content":"创建一个线程有几种方式 import org.junit.Test; import java.util.List; import java.util.concurrent.*; public class ThreadTest { class ThreadA extends Thread { public ThreadA(String name) { super(name); } @Override public void run() { super.run(); System.out.println(\"我是继承Thread的线程：\" + this.getName()); } } class ThreadB implements Runnable { @Override public void run() { System.out.println(\"我是实现Runnable接口的线程\"); } } class ThreadD implements Callable\u003cList\u003cInteger\u003e\u003e { @Override public List\u003cInteger\u003e call() throws Exception { System.out.println(\"我是实现Callable接口的线程\"); return null; } } /** * 测试线程的实现方式 */ @Test public void newThread() { // 方式一 new ThreadA(\"线程A\").start(); // 方式二 new Thread(new ThreadB()).start(); // 方式三： Thread threadC = new Thread() { @Override public void run() { super.run(); System.out.println(\"我是匿名线程：\" + this.getName()); } }; threadC.setName(\"线程C\"); threadC.start(); // 方式四：FutureTask 实现了 Runnable 接口 ThreadD threadD = new ThreadD(); FutureTask\u003cList\u003cInteger\u003e\u003e futureTask = new FutureTask\u003c\u003e(threadD); new Thread(futureTask).start(); // 方式五：利用线程池，配置线程创建后的回调对象 ExecutorService executorService = Executors.newFixedThreadPool(1); executorService.submit(new Runnable() { @Override public void run() { System.out.println(\"我是线程池的 Runnable 实现\"); } }); // 方式六：也是线程池，不过配置的对象实现接口不同 executorService.submit(new Callable\u003cObject\u003e() { @Override public Object call() throws Exception { System.out.println(\"我是线程池的 Callable 实现\"); return null; } }); System.out.printf(\"主线程：%s%n\", Thread.currentThread().getName()); } } 执行结果： 我是继承Thread的线程：线程A 我是实现Runnable接口的线程 我是匿名线程：线程C 我是实现Callable接口的线程 我是线程池的 Runnable 实现 主线程：main 我是线程池的 Callable 实现 ","date":"2022-09-07","objectID":"/posts/framework/huixiangdouxiefa/:2:0","tags":["工具","技巧"],"title":"茴香豆的茴有几种写法","uri":"/posts/framework/huixiangdouxiefa/"},{"categories":["工具"],"content":"继承java.lang.Thread类 ","date":"2022-09-07","objectID":"/posts/framework/huixiangdouxiefa/:2:1","tags":["工具","技巧"],"title":"茴香豆的茴有几种写法","uri":"/posts/framework/huixiangdouxiefa/"},{"categories":["工具"],"content":"实现Runnable接口的java.lang.Runnable#run方法 ","date":"2022-09-07","objectID":"/posts/framework/huixiangdouxiefa/:2:2","tags":["工具","技巧"],"title":"茴香豆的茴有几种写法","uri":"/posts/framework/huixiangdouxiefa/"},{"categories":["工具"],"content":"Thread的匿名类 ","date":"2022-09-07","objectID":"/posts/framework/huixiangdouxiefa/:2:3","tags":["工具","技巧"],"title":"茴香豆的茴有几种写法","uri":"/posts/framework/huixiangdouxiefa/"},{"categories":["工具"],"content":"Java有几种内部类 4种，成员，匿名，局部，静态。 ","date":"2022-09-07","objectID":"/posts/framework/huixiangdouxiefa/:3:0","tags":["工具","技巧"],"title":"茴香豆的茴有几种写法","uri":"/posts/framework/huixiangdouxiefa/"},{"categories":["工具"],"content":"获取 Class 类实例的方法有几种 3种 /** * 获取 Class 类实例有几种方式：3种 */ @Test public void severalInstance() { // 方式一：类常量 Class\u003cClassTest\u003e classTestClass = ClassTest.class; // 方式二：getClass() 方法 Class\u003c? extends ClassTest\u003e aClass = this.getClass(); Class\u003c?\u003e classTest = null; try { // 方式三：forName classTest = Class.forName(\"shali.tdl.lang.ClassTest\"); } catch (ClassNotFoundException e) { e.printStackTrace(); } // 方式四：类加载器 ClassLoader classLoader = ClassTest.class.getClassLoader(); Class\u003c?\u003e aClass1 = null; try { aClass1 = classLoader.loadClass(\"shali.tdl.lang.ClassTest\"); } catch (ClassNotFoundException e) { e.printStackTrace(); } Assert.assertSame(aClass, classTestClass); Assert.assertSame(aClass, classTest); Assert.assertSame(aClass, aClass1); } ","date":"2022-09-07","objectID":"/posts/framework/huixiangdouxiefa/:4:0","tags":["工具","技巧"],"title":"茴香豆的茴有几种写法","uri":"/posts/framework/huixiangdouxiefa/"},{"categories":["工具"],"content":"常用命令 几个很常用的命令表 命令 描述 docker images 等同于 docker image ls 查看下载的镜像列表 docker ps -a 已安装的容器列表 docker ps 当前运行的容器列表 ","date":"2022-09-06","objectID":"/posts/2022/docker/:1:0","tags":["docker","容器"],"title":"Docker 使用笔记","uri":"/posts/2022/docker/"},{"categories":["工具"],"content":"操作镜像 搜索镜像 docker search redis NAME 镜像的名字 STARS 就是这个镜像获得的小星星数 OFFICIAL 是否为官方镜像，为了安全起见，还是下载官方镜像吧。我曾经拉取的 PHP 镜像里有矿机 下载镜像 docker pull 镜像名称:镜像版本号 latest 版本号代表最新的 演示 E:\\\u003edocker pull redis:latest latest: Pulling from library/redis 7a6db449b51b: Pull complete 05b1f5f3b2c0: Pull complete f0036f71a6fe: Pull complete cd7ddcecb993: Pull complete 8cfc9a467ed7: Pull complete 2a9998409df9: Pull complete Digest: sha256:495732ba570db6a3626370a1fb949e98273a13d41eb3e26f7ecb1f6e31ad4041 Status: Downloaded newer image for redis:latest docker.io/library/redis:latest 删除镜像 docker rmi 镜像名称 ","date":"2022-09-06","objectID":"/posts/2022/docker/:1:1","tags":["docker","容器"],"title":"Docker 使用笔记","uri":"/posts/2022/docker/"},{"categories":["工具"],"content":"操作容器 命令 描述 docker start 容器id 启动容器 docker stop 容器id 停止容器 docker restart 容器id 重启容器 利用镜像创建容器 其实安装镜像，就是创建容器。 docker run 各种参数 镜像文件命令的参数比较丰富。 参数 描述 -d 等同 –detach Run container in background and print container ID 就是让容器以后启动了在后台运行而不是前台 –name 容器名称 给容器起个名字，最好带上版本号，因为可能安装多个版本镜像 -e “name=tony” 设置环境变量 -p 宿主机端口:容器端口 端口映射 演示 docker run -d --name redis -p 6379:6378 redis:latest 删除容器 docker rm 容器id 进入容器 docker exec -it 容器名称 /bin/bash ","date":"2022-09-06","objectID":"/posts/2022/docker/:1:2","tags":["docker","容器"],"title":"Docker 使用笔记","uri":"/posts/2022/docker/"},{"categories":["工具"],"content":"构建自己的镜像 ","date":"2022-09-06","objectID":"/posts/2022/docker/:2:0","tags":["docker","容器"],"title":"Docker 使用笔记","uri":"/posts/2022/docker/"},{"categories":["工具"],"content":"日期时间 ","date":"2022-09-06","objectID":"/posts/framework/top100tools/:1:0","tags":["框架","framework"],"title":"流行的100个常用Java工具库","uri":"/posts/framework/top100tools/"},{"categories":["工具"],"content":"字符串数组处理 ","date":"2022-09-06","objectID":"/posts/framework/top100tools/:2:0","tags":["框架","framework"],"title":"流行的100个常用Java工具库","uri":"/posts/framework/top100tools/"},{"categories":["工具"],"content":"集合框架 ","date":"2022-09-06","objectID":"/posts/framework/top100tools/:3:0","tags":["框架","framework"],"title":"流行的100个常用Java工具库","uri":"/posts/framework/top100tools/"},{"categories":["工具"],"content":"Apache 的 commons-collections4 \u003c!-- https://mvnrepository.com/artifact/org.apache.commons/commons-collections4 --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.apache.commons\u003c/groupId\u003e \u003cartifactId\u003ecommons-collections4\u003c/artifactId\u003e \u003cversion\u003e4.4\u003c/version\u003e \u003c/dependency\u003e 工具列表 工具 功能描述 使用方法 LRUMap，最近最少使用 Map 这个 Map 固定大小 容量不够时，会删除最近最少使用的元素 ","date":"2022-09-06","objectID":"/posts/framework/top100tools/:3:1","tags":["框架","framework"],"title":"流行的100个常用Java工具库","uri":"/posts/framework/top100tools/"},{"categories":["工具"],"content":"消息队列 ","date":"2022-09-06","objectID":"/posts/framework/top100tools/:4:0","tags":["框架","framework"],"title":"流行的100个常用Java工具库","uri":"/posts/framework/top100tools/"},{"categories":["工具"],"content":"基于数据库的消息队列 xxl-mq-client 下载地址 \u003cdependency\u003e \u003cgroupId\u003ecom.xuxueli\u003c/groupId\u003e \u003cartifactId\u003exxl-mq-client\u003c/artifactId\u003e \u003cversion\u003e1.3.0\u003c/version\u003e \u003c/dependency\u003e ","date":"2022-09-06","objectID":"/posts/framework/top100tools/:4:1","tags":["框架","framework"],"title":"流行的100个常用Java工具库","uri":"/posts/framework/top100tools/"},{"categories":["异常"],"content":"java.lang ","date":"2022-09-01","objectID":"/posts/framework/cuocuocuo/:1:0","tags":["ClassNotFoundException"],"title":"送你100个异常","uri":"/posts/framework/cuocuocuo/"},{"categories":["异常"],"content":"java.lang.IllegalStateException 状态异常。 ","date":"2022-09-01","objectID":"/posts/framework/cuocuocuo/:1:1","tags":["ClassNotFoundException"],"title":"送你100个异常","uri":"/posts/framework/cuocuocuo/"},{"categories":["异常"],"content":"Spring ","date":"2022-09-01","objectID":"/posts/framework/cuocuocuo/:2:0","tags":["ClassNotFoundException"],"title":"送你100个异常","uri":"/posts/framework/cuocuocuo/"},{"categories":["异常"],"content":"org.springframework.beans.factory.NoSuchBeanDefinitionException 当你从 Spring 容器（）中获取 bean 时，如果这个 bean 不存在，他并不会返回 null，而是直接抛未定义 bean 异常。 出现这种问题一般 2 种： Spring 容器里就没有这个 bean 或者获取方式不对，bean 按名称注入，但是按类型获取，也会造成不存在。 ","date":"2022-09-01","objectID":"/posts/framework/cuocuocuo/:2:1","tags":["ClassNotFoundException"],"title":"送你100个异常","uri":"/posts/framework/cuocuocuo/"},{"categories":["异常"],"content":"org.springframework.beans.BeanInstantiationException Spring Bean 初始化异常。 ","date":"2022-09-01","objectID":"/posts/framework/cuocuocuo/:2:2","tags":["ClassNotFoundException"],"title":"送你100个异常","uri":"/posts/framework/cuocuocuo/"},{"categories":["异常"],"content":"org.springframework.beans.factory.UnsatisfiedDependencyException org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'com.shali.ruby.test.AutowiredTest': Unsatisfied dependency expressed through field 'people'; nested exception is org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type 'com.shali.ruby.bean.People' available: expected single matching bean but found 2: maria,tony 大概意思是说根据你要注入的 com.shali.ruby.bean.People bean，但是按类型注入，发现了 2 个此类的 bean，他不知道该注入哪个实现 bean。 ","date":"2022-09-01","objectID":"/posts/framework/cuocuocuo/:2:3","tags":["ClassNotFoundException"],"title":"送你100个异常","uri":"/posts/framework/cuocuocuo/"},{"categories":["异常"],"content":"org.springframework.boot.loader.thin.ThinJarLauncher Exception in thread \"main\" java.lang.ClassNotFoundException: org.springframework.boot.loader.thin.ThinJarLauncher 很多同学学习了 SpringBoot 减肥打包法，屡试不爽。 出现这个原因是，仓库里找不到spring-boot-thin-launcher-1.0.28.RELEASE-exec.jar文件，于是跑到仓库C:\\Users\\用户名\\.m2\\repository\\org\\springframework\\boot\\experimental\\spring-boot-thin-launcher\\1.0.28.RELEASE目录下，发现存在阿。其实是你网络的不好，下载的文件不全，大小都不对。 建议删除spring-boot-thin-launcher-1.0.28.RELEASE-exec.jar，重新跑下java -jar 项目.jar命令，他会检查并安装依赖的。 ","date":"2022-09-01","objectID":"/posts/framework/cuocuocuo/:2:4","tags":["ClassNotFoundException"],"title":"送你100个异常","uri":"/posts/framework/cuocuocuo/"},{"categories":["异常"],"content":"java.lang.IllegalMonitorStateException 字面意思：非法监控状态异常 出现这种问题，多是你在非同步代码中调用了Object.wait()或Object.notify()或Object.notifyAll()方法。 正确调用上述方法的姿势是，首先拿到锁。 ","date":"2022-09-01","objectID":"/posts/framework/cuocuocuo/:3:0","tags":["ClassNotFoundException"],"title":"送你100个异常","uri":"/posts/framework/cuocuocuo/"},{"categories":["异常"],"content":"java.lang.IndexOutOfBoundsException 数组越界异常 ","date":"2022-09-01","objectID":"/posts/framework/cuocuocuo/:4:0","tags":["ClassNotFoundException"],"title":"送你100个异常","uri":"/posts/framework/cuocuocuo/"},{"categories":["异常"],"content":"MyBatis ","date":"2022-09-01","objectID":"/posts/framework/cuocuocuo/:5:0","tags":["ClassNotFoundException"],"title":"送你100个异常","uri":"/posts/framework/cuocuocuo/"},{"categories":["异常"],"content":"org.apache.ibatis.binding.BindingException org.apache.ibatis.binding.BindingException: Invalid bound statement (not found): 无效绑定异常，即提示你，XxxMapper 接口与 XxxMapper.xml 文件没有绑定成功。 ","date":"2022-09-01","objectID":"/posts/framework/cuocuocuo/:5:1","tags":["ClassNotFoundException"],"title":"送你100个异常","uri":"/posts/framework/cuocuocuo/"},{"categories":["异常"],"content":"常见提示 ","date":"2022-09-01","objectID":"/posts/framework/cuocuocuo/:6:0","tags":["ClassNotFoundException"],"title":"送你100个异常","uri":"/posts/framework/cuocuocuo/"},{"categories":["异常"],"content":"Raw use of parameterized class ‘FutureTask’ 翻译过来就是，参数类 FutureTask 的原始使用，就是说你使用泛型类 FutrueTask 却不指定泛型，提示你存在数据类型丢失的风险，我们知道指定泛型就是避免数据类型丢失的风险。 ","date":"2022-09-01","objectID":"/posts/framework/cuocuocuo/:6:1","tags":["ClassNotFoundException"],"title":"送你100个异常","uri":"/posts/framework/cuocuocuo/"},{"categories":["框架"],"content":"在旧的开发模式下，一个组件如果要使用另一个组件，必须先知道如何正确地创建它。于是引入IoC。 IoC又称为依赖注入（DI：Dependency Injection），它解决了一个最主要的问题：将组件的创建+配置与组件的使用相分离，并且，由IoC容器负责管理组件的生命周期。 ","date":"2022-08-30","objectID":"/posts/framework/spring/:0:0","tags":["spring"],"title":"Spring","uri":"/posts/framework/spring/"},{"categories":["框架"],"content":"常用注解 注解 功能描述 搭档注解 @Component 通常用来注解类，声明此类是一个 Spring Bean，Spring 启动后要交给 Spring 创建和托管的类。 ==JSR-330 标准推荐使用 @Named== @Autowired @Autowired 让 Spring 按照变量类型，从 Spring 容器中获取对应的实例进行绑定。 即按类型注入，如果UserServiceI接口存在多个实现类时，就不知道注入哪个了，报错。 ==JSR-330 标准推荐使用 @Inject== @Qualifier @Component @Qualifier 按具体的实现类类名注入，@Qualifier(“UserServiceImpl”) ==JSR-330 标准推荐使用 @Named== @Resource 同 @Autowired，@Qualifier 功能相同，都是属性注入。 不同点就是他们的注入依据不同，@Resource(name=“UserServiceImpl”) 按类名 Java 内置注解 @Controller 声明此类是 Web 层的一个控制器 @Service 注解这是 Service 层的一个类 @Repository 注解这是 Dao 层的一个类 @PostConstruct 注解方法，说这是一个执行类构造方法的时候执行的方法，就是一个钩子方法，或者说标签。 类似 PHPUnit 中的setUp()方法 @PreDestory @PreDestory 注解方法，说这是一个执行类的析构方法finalize()时执行的方法，也是一个钩子方法。 类似 PHPUnit 中的tearDown()方法 @Component，@Controller，@Service，@Repository，这几个注解的作用都是生产 bean，都是注解在类上，将类注解成 spring 的 bean 工厂中一个一个的 bean。 其实 @Controller，@Service，@Repository 就是语义更加细化的 @Component。不仅能说明此类是 bean，还能说明此 bean 用于哪一层。 ","date":"2022-08-30","objectID":"/posts/framework/spring/:1:0","tags":["spring"],"title":"Spring","uri":"/posts/framework/spring/"},{"categories":["框架"],"content":"搭配使用的注解 ","date":"2022-08-30","objectID":"/posts/framework/spring/:2:0","tags":["spring"],"title":"Spring","uri":"/posts/framework/spring/"},{"categories":["框架"],"content":"@Bean 必须搭配 @Configuration 吗 @Bean 注解在方法上，想要使用必须扫到此文件，所以类文件上必须加注解 @Component @Configuration 也实现了 @Component 之所有用 @Configuration，而不使用其他的 @Component，是因为他的语义化更强 @Import 与 @Bean 注解功能类似，注入第三方功能。 ","date":"2022-08-30","objectID":"/posts/framework/spring/:2:1","tags":["spring"],"title":"Spring","uri":"/posts/framework/spring/"},{"categories":["框架"],"content":"通过名称获取 Spring Bean 时，@Autowired 必须搭配 @Qualifier ","date":"2022-08-30","objectID":"/posts/framework/spring/:2:2","tags":["spring"],"title":"Spring","uri":"/posts/framework/spring/"},{"categories":["框架"],"content":"Spring Bean 的生命周期 ","date":"2022-08-30","objectID":"/posts/framework/spring/:3:0","tags":["spring"],"title":"Spring","uri":"/posts/framework/spring/"},{"categories":["框架"],"content":"易错点 ","date":"2022-08-30","objectID":"/posts/framework/spring/:4:0","tags":["spring"],"title":"Spring","uri":"/posts/framework/spring/"},{"categories":["框架"],"content":"@Transactional注解事务使用 使用@Transactional注解事务时，务必指明什么异常回滚，否则Spring只会遇到RuntimeException和Error异常时才回滚。@Transactional(rollbackFor = Exception.class)。 @Transactional注解修饰的方法里，不要捕获异常，因为你捕获了异常，他也就无法感知异常，故无法回滚。推荐业务层方法用@Transactional修饰，统一抛出异常，控制器层统一处理异常。 ","date":"2022-08-30","objectID":"/posts/framework/spring/:4:1","tags":["spring"],"title":"Spring","uri":"/posts/framework/spring/"},{"categories":["操作系统"],"content":"select select 和 Java1.8 的 HashMap 一样，底层存储都是红黑树。 ","date":"2022-08-30","objectID":"/posts/os/shijian/:1:0","tags":["epoll","select"],"title":"事件","uri":"/posts/os/shijian/"},{"categories":["操作系统"],"content":"poll ","date":"2022-08-30","objectID":"/posts/os/shijian/:2:0","tags":["epoll","select"],"title":"事件","uri":"/posts/os/shijian/"},{"categories":["操作系统"],"content":"epoll ","date":"2022-08-30","objectID":"/posts/os/shijian/:3:0","tags":["epoll","select"],"title":"事件","uri":"/posts/os/shijian/"},{"categories":["计划填充"],"content":"Servlet ","date":"2022-08-28","objectID":"/posts/framework/2022/:1:0","tags":["日子","计划"],"title":"2022.8","uri":"/posts/framework/2022/"},{"categories":["计划填充"],"content":"JSP ","date":"2022-08-28","objectID":"/posts/framework/2022/:2:0","tags":["日子","计划"],"title":"2022.8","uri":"/posts/framework/2022/"},{"categories":["计划填充"],"content":"MyBatis ","date":"2022-08-28","objectID":"/posts/framework/2022/:3:0","tags":["日子","计划"],"title":"2022.8","uri":"/posts/framework/2022/"},{"categories":["计划填充"],"content":"Sping ","date":"2022-08-28","objectID":"/posts/framework/2022/:4:0","tags":["日子","计划"],"title":"2022.8","uri":"/posts/framework/2022/"},{"categories":["计划填充"],"content":"SpingMVC ","date":"2022-08-28","objectID":"/posts/framework/2022/:5:0","tags":["日子","计划"],"title":"2022.8","uri":"/posts/framework/2022/"},{"categories":["计划填充"],"content":"SpringBoot ","date":"2022-08-28","objectID":"/posts/framework/2022/:6:0","tags":["日子","计划"],"title":"2022.8","uri":"/posts/framework/2022/"},{"categories":["三省吾身"],"content":"上周给同事讲 Java 基础，有 2 个地方是错误的，特此纠正。 ","date":"2022-08-28","objectID":"/posts/2022/20220828/:0:0","tags":null,"title":"2022年8月28日","uri":"/posts/2022/20220828/"},{"categories":["三省吾身"],"content":"地址值赋值 我给人讲的是： Integer a = 1; Integer b = a; b = 2; assert a == 2;// 错了，其实是 1 b = null; assert b == null; assert a = 2;// 错了，其实是 1 上面其实给人讲错了，变量a至始至终都是1，才是对的。 ","date":"2022-08-28","objectID":"/posts/2022/20220828/:1:0","tags":null,"title":"2022年8月28日","uri":"/posts/2022/20220828/"},{"categories":["三省吾身"],"content":"Object.hashCode()的用处 我给人讲，hashCode() 主要用来加速 equals() 方法的。认为两个对象的 hashcode 相同，其一定相等。 其实讲错了，仔细思考一下，==相同的对象，其 hashcode 一定相同，但是 hashcode 相同的对象，就未必是一个对象了，存在 hash 碰撞。==就能推翻上面的言论。 再者，hashCode() 是用来给 equals 服务也是错的，其主要用来服务集合的，例如 HashMap。因为其内部的 get() 和 put() 都依赖了对象的 hashCode() 方法。 ","date":"2022-08-28","objectID":"/posts/2022/20220828/:2:0","tags":null,"title":"2022年8月28日","uri":"/posts/2022/20220828/"},{"categories":["Java基础"],"content":"JSP（Java Server Pages） 优点类似 PHP 中的模板引擎，既然是模板引擎，那就要按照模板引擎的一套规范（语法）来编写页面，最后进入 Servlet 容器执行前，将其替换（有的地方说是编译）转成 Servlet 类，你要搞清楚，Servlet 容器只能运行 Servlet 类，他可不认识 JSP 语法，毕竟那都不是 Java 语言格式，你让 JVM 怎么跑。 或者你称他是 Java 开发网页的模板语言。 我认为是这样的一个运行流程。 JSP（替换成）-\u003e Servlet类（挂载到）-\u003e Servlet容器（编译成）-\u003e Java字节码 -\u003e JVM（跑起来） ","date":"2022-08-28","objectID":"/posts/java%E5%9F%BA%E7%A1%80/jsp/:0:0","tags":["模板引擎"],"title":"JSP","uri":"/posts/java%E5%9F%BA%E7%A1%80/jsp/"},{"categories":["Java基础"],"content":"疑问 为啥引入 JSP java.io.PrintWriter pw = javax.servlet.http.HttpServletResponse#getWriter(); pw.write(\"\u003chtml\u003e\u003cbody\u003e\u003ch1\u003e\"); pw.write(\"hello world\"); pw.write(\"\u003c/h1\u003e\u003c/body\u003e\u003c/html\u003e\"); pw.flush(); Java 适合写业务逻辑，可不适合拼接 HTML 格式文件给前端。就像 PHP 为了解决开发 Web 页面过慢，而引入模板引擎。 一个 Web 页面的静态内容比动态内容多，Java 适合输出动态内容，如果是动态内容多，静态内容少，就直接使用 Servlet 开发了。 为啥说页面的Servlet挂载到Servlet容器呢？ 因为我觉得页面的 Servlet 类就是一个钩子，页面只需要实现 Servlet 容器要调用的 javax.servlet.http.HttpServlet#service(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)方法即可。 ","date":"2022-08-28","objectID":"/posts/java%E5%9F%BA%E7%A1%80/jsp/:1:0","tags":["模板引擎"],"title":"JSP","uri":"/posts/java%E5%9F%BA%E7%A1%80/jsp/"},{"categories":["Java框架"],"content":"疑问 ","date":"2022-08-28","objectID":"/posts/framework/junit/:1:0","tags":["java","框架","测试","junit"],"title":"JUnit","uri":"/posts/framework/junit/"},{"categories":["Java框架"],"content":"assertSame与assertEquals的区别 /** * 公 */ class Gong { @Override public boolean equals(Object obj) { if (this == obj) { return true; } return \"男\".equals(obj.toString()); } } @Test public void sameAndEquals() { Gong gong1 = new Gong(); Gong gong2 = new Gong(); String nan1 = \"男\"; String nan2 = \"男\"; StringBuilder nan3 = new StringBuilder(\"男\"); // 比较的是地址值 Assert.assertNotSame(gong1, nan1); Assert.assertNotSame(gong1, gong2); // 字符串常量池，导致 nan1 与 nan2 的地址值相同 Assert.assertSame(nan1, nan2); // 地址值不一样 Assert.assertNotSame(nan1, nan3); // assertEquals 比较的是 gong1.equals() 方法的实现 Assert.assertEquals(gong1, nan1); // 地址值不同，由于未重写 toString() 所以也不同 Assert.assertNotEquals(gong1, gong2); // 地址值相同 Assert.assertEquals(nan1, nan2); // equals 重写，地址值不同，但是 toString() 的内容相同 Assert.assertEquals(gong1, nan3); } ==总结==： assertSame 比较的是内存地址 assertEquals 比较的是类重写的 Object.equals() 方法，如果类未重写，则与 assertSame 功能相同 ","date":"2022-08-28","objectID":"/posts/framework/junit/:1:1","tags":["java","框架","测试","junit"],"title":"JUnit","uri":"/posts/framework/junit/"},{"categories":["问"],"content":"其实也不止三问。 ","date":"2022-08-28","objectID":"/posts/java%E5%9F%BA%E7%A1%80/sanwenjava/:0:0","tags":["Java"],"title":"三问Java","uri":"/posts/java%E5%9F%BA%E7%A1%80/sanwenjava/"},{"categories":["问"],"content":"java.io.Serializable 为什么实现 interface java.io.Serializable 的类中都定义一个非大写的类常量。 private static final long serialVersionUID = 1L; ","date":"2022-08-28","objectID":"/posts/java%E5%9F%BA%E7%A1%80/sanwenjava/:1:0","tags":["Java"],"title":"三问Java","uri":"/posts/java%E5%9F%BA%E7%A1%80/sanwenjava/"},{"categories":["问"],"content":"SLF4J的日志工厂 为什么org.slf4j.LoggerFactory工厂要为每一个类都实例化一个 logger 实例。 import org.slf4j.Logger; import org.slf4j.LoggerFactory; private final static Logger logger = LoggerFactory.getLogger(getClass()); ","date":"2022-08-28","objectID":"/posts/java%E5%9F%BA%E7%A1%80/sanwenjava/:2:0","tags":["Java"],"title":"三问Java","uri":"/posts/java%E5%9F%BA%E7%A1%80/sanwenjava/"},{"categories":["问"],"content":"实例属性，类属性，Spring Bean 的 logger 区别 // 一：类属性 logger @Service class UserServiceImpl { private static final Logger log = LoggerFactory.getLogger(UserServiceImpl.class); } // 二：实例属性 logger @Service class UserServiceImpl { private final Logger log = LoggerFactory.getLogger(UserServiceImpl.class); } // 三：spring bean logger @Service class UserServiceImpl { @Autowired private Logger log; } @Configuration class MyConfig { @Bean public Logger logger() { return LoggerFactory.getLogger(\"mylogger\"); } } 区别： 方式一是单例，懒汉模式 方式二多例 方式二和方式一能够记录调用者所在类信息，文件，行号 ","date":"2022-08-28","objectID":"/posts/java%E5%9F%BA%E7%A1%80/sanwenjava/:2:1","tags":["Java"],"title":"三问Java","uri":"/posts/java%E5%9F%BA%E7%A1%80/sanwenjava/"},{"categories":["工具"],"content":"继承 子项目不继承父项目的 modules ","date":"2022-08-26","objectID":"/posts/framework/maven/:1:0","tags":["maven","tool","依赖解决"],"title":"Maven","uri":"/posts/framework/maven/"},{"categories":["工具"],"content":"properties 全局属性，只对当前工程生效。 ","date":"2022-08-26","objectID":"/posts/framework/maven/:2:0","tags":["maven","tool","依赖解决"],"title":"Maven","uri":"/posts/framework/maven/"},{"categories":["工具"],"content":"dependencys \u003cdependency\u003e \u003cgroupId\u003e公司名称/公司域名\u003c/groupId\u003e \u003cartifactId\u003e项目/模块名称\u003c/artifactId\u003e \u003cversion\u003ex.y.z格式版本号\u003c/version\u003e \u003cscope\u003e生效环境\u003c/scope\u003e \u003c/dependency\u003e 生效环境： ","date":"2022-08-26","objectID":"/posts/framework/maven/:3:0","tags":["maven","tool","依赖解决"],"title":"Maven","uri":"/posts/framework/maven/"},{"categories":["工具"],"content":"常见错误 ","date":"2022-08-26","objectID":"/posts/framework/maven/:4:0","tags":["maven","tool","依赖解决"],"title":"Maven","uri":"/posts/framework/maven/"},{"categories":["工具"],"content":"No valid Maven installation found Error running ‘bbs [clean]’: No valid Maven installation found. Either set the home directory in the configuration dialog or set the M2_HOME environment variable on your system. 从描述看，就是因为找不到mvn工具的路径，导致无法使用maven解决依赖。 ","date":"2022-08-26","objectID":"/posts/framework/maven/:4:1","tags":["maven","tool","依赖解决"],"title":"Maven","uri":"/posts/framework/maven/"},{"categories":["工具"],"content":"疑问 maven是如何解决循环依赖的？ ","date":"2022-08-26","objectID":"/posts/framework/maven/:5:0","tags":["maven","tool","依赖解决"],"title":"Maven","uri":"/posts/framework/maven/"},{"categories":["工具"],"content":"引用 廖雪峰《Maven基础》 ","date":"2022-08-26","objectID":"/posts/framework/maven/:6:0","tags":["maven","tool","依赖解决"],"title":"Maven","uri":"/posts/framework/maven/"},{"categories":["框架"],"content":"SpringBoot 与 Spring 的关系： ","date":"2022-08-26","objectID":"/posts/framework/springboot/:0:0","tags":["spring","springboot","springmvc"],"title":"SpringBoot","uri":"/posts/framework/springboot/"},{"categories":["框架"],"content":"依赖安装 ","date":"2022-08-26","objectID":"/posts/framework/springboot/:1:0","tags":["spring","springboot","springmvc"],"title":"SpringBoot","uri":"/posts/framework/springboot/"},{"categories":["框架"],"content":"配置文件加载优先级 配置文件 加载优先级 application.yml 最低 application.yaml 其次 application.properties 最高 那里能看到的这个配置文件的加载顺序呢？ \u003c!--.m2/repository/org/springframework/boot/spring-boot-starter-parent/2.7.3/spring-boot-starter-parent-2.7.3.pom--\u003e \u003cbuild\u003e \u003cresources\u003e \u003cresource\u003e \u003cdirectory\u003e${basedir}/src/main/resources\u003c/directory\u003e \u003cfiltering\u003etrue\u003c/filtering\u003e \u003cincludes\u003e \u003cinclude\u003e**/application*.yml\u003c/include\u003e \u003cinclude\u003e**/application*.yaml\u003c/include\u003e \u003cinclude\u003e**/application*.properties\u003c/include\u003e \u003c/includes\u003e \u003c/resource\u003e \u003c/resources\u003e \u003c/build\u003e 打开spring-boot-starter-parent项目的pom.xml文件即可看到其依赖的配置文件加载顺序。顺便提醒你spring-boot-starter-parent项目继承了spring-boot-dependencies。 ","date":"2022-08-26","objectID":"/posts/framework/springboot/:1:1","tags":["spring","springboot","springmvc"],"title":"SpringBoot","uri":"/posts/framework/springboot/"},{"categories":["框架"],"content":"打包 SpringBoot 打包工具是spring-boot-maven-plugin。 ","date":"2022-08-26","objectID":"/posts/framework/springboot/:2:0","tags":["spring","springboot","springmvc"],"title":"SpringBoot","uri":"/posts/framework/springboot/"},{"categories":["框架"],"content":"打的jar包过大 优点：打包了所有的依赖文件jar包，位于E:\\demo_project\\target\\demo_project-0.0.1-SNAPSHOT.jar\\BOOT-INF\\lib目录中，方便部署，服务器环境只需要提供JVM即可，不需要解决依赖问题 缺点：稍微大点的项目，肯定依赖了很多工具包，每次分发部署的jar包特别大，不利于网络传输，快速部署的特点。不能做到依赖一次性解决，次次都要打包依赖包的问题 ","date":"2022-08-26","objectID":"/posts/framework/springboot/:2:1","tags":["spring","springboot","springmvc"],"title":"SpringBoot","uri":"/posts/framework/springboot/"},{"categories":["框架"],"content":"不打包依赖包，减小jar包 如果能做到像composer那样，只需要分发composer.json和composer.lock两个文件即可，服务器部署时，只需要检查一次依赖的包又没有新增，包的版本有没有变更，如果上述都没有，则不需要再解决依赖，因为第一次解决依赖时，下载的包已经够用了。 现在要解决的问题就是，不打包依赖，但是又要让程序运行时，能在classpath中找到这些依赖包。 ","date":"2022-08-26","objectID":"/posts/framework/springboot/:2:2","tags":["spring","springboot","springmvc"],"title":"SpringBoot","uri":"/posts/framework/springboot/"},{"categories":["框架"],"content":"springboot-thin-jar 看这个工具的名字，thin 瘦的，对我们就是要打包最瘦的项目jar包。 使用方式 找到项目的pom.xml文件，给maven的打包工具spring-boot-maven-plugin添加依赖包spring-boot-thin-layout。 添加后的效果是这样的： \u003cbuild\u003e \u003cplugins\u003e \u003c!--打包插件--\u003e \u003cplugin\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-maven-plugin\u003c/artifactId\u003e \u003cconfiguration\u003e \u003cexcludes\u003e \u003cexclude\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003c/exclude\u003e \u003c/excludes\u003e \u003c/configuration\u003e \u003c!--打最小的包--\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot.experimental\u003c/groupId\u003e \u003cartifactId\u003espring-boot-thin-layout\u003c/artifactId\u003e \u003cversion\u003e1.0.28.RELEASE\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c/plugin\u003e \u003c/plugins\u003e \u003c/build\u003e 配置完了执行mvn clean package，然后就能在项目的target目录下看到一个很小的项目jar包。 ==注意==： 当我们执行java -jar 项目.jar项目时，他会使用默认仓库，如果默认仓库中不存在，他就会先下载依赖包，然后再执行我们项目.jar中的main()方法。 Windows 的本地默认仓库位置：C:\\Users\\用户名\\.m2\\repository 当然你也可以为项目指定默认仓库的位置： java -Dthin.root=仓库路径 -jar 项目.jar -Dthin.root=仓库路径 指定项目仓库的默认路径 预热，类似热车，冬天人还未上车，先把发动机开启，暖风打开。等人上车了，车内已经暖和了。 项目预热，就是不启动项目，即不执行main()方法。先把项目的依赖解决，即需要下载的提前下载好。 java -Dthin.dryrun=true -Dthin.root=仓库路径，不指定就是本地默认仓库地址 -jar 项目.jar -Dthin.dryrun=true 开启预热 -Dthin.root=. 项目的默认仓库路径 ","date":"2022-08-26","objectID":"/posts/framework/springboot/:2:3","tags":["spring","springboot","springmvc"],"title":"SpringBoot","uri":"/posts/framework/springboot/"},{"categories":["Java框架"],"content":"安装 ","date":"2022-08-25","objectID":"/posts/framework/lombok/:1:0","tags":["java","框架","lombok"],"title":"Lombok","uri":"/posts/framework/lombok/"},{"categories":["Java框架"],"content":"Maven \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003cversion\u003e1.18.24\u003c/version\u003e \u003cscope\u003eprovided\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e 官方文档 描述 https://projectlombok.org/changelog 变更日志 https://projectlombok.org/setup/maven 安装手册 https://projectlombok.org/features/ 使用说明书 下面是一些常用的注解。 ","date":"2022-08-25","objectID":"/posts/framework/lombok/:1:1","tags":["java","框架","lombok"],"title":"Lombok","uri":"/posts/framework/lombok/"},{"categories":["Java框架"],"content":"var val 等效于使用 final var。 val str = \"hello\"; final String str2 = str; // 上面 2 种方式是等效的 Assert.assertSame(str2, str); 用来修饰局部变量，相当于将变量声明为 final。 ","date":"2022-08-25","objectID":"/posts/framework/lombok/:2:0","tags":["java","框架","lombok"],"title":"Lombok","uri":"/posts/framework/lombok/"},{"categories":["Java框架"],"content":"@NonNull 修饰方法形参，如果形参为 null，则抛NullPointerException。 ","date":"2022-08-25","objectID":"/posts/framework/lombok/:3:0","tags":["java","框架","lombok"],"title":"Lombok","uri":"/posts/framework/lombok/"},{"categories":["Java框架"],"content":"@Cleanup @Cleanup 相当于 finally 模块，主要用来释放资源的。 ","date":"2022-08-25","objectID":"/posts/framework/lombok/:4:0","tags":["java","框架","lombok"],"title":"Lombok","uri":"/posts/framework/lombok/"},{"categories":["Java框架"],"content":"@Setter 帮你实现一些setXXX()方法 ","date":"2022-08-25","objectID":"/posts/framework/lombok/:5:0","tags":["java","框架","lombok"],"title":"Lombok","uri":"/posts/framework/lombok/"},{"categories":["Java框架"],"content":"@Getter 帮你实现一些getXXX()方法 ==注意==： 如果属性是基本类型boolean，则 get 方法的前缀不是 get 而是 isXXX。如果使用 boolean 的包装类型Boolean，则方法前缀依旧保持为 get。 ","date":"2022-08-25","objectID":"/posts/framework/lombok/:6:0","tags":["java","框架","lombok"],"title":"Lombok","uri":"/posts/framework/lombok/"},{"categories":["Java框架"],"content":"@ToString 见名知意，就是帮你实现toString()方法。 ","date":"2022-08-25","objectID":"/posts/framework/lombok/:7:0","tags":["java","框架","lombok"],"title":"Lombok","uri":"/posts/framework/lombok/"},{"categories":["Java框架"],"content":"排除某个字段属性被 toString import lombok.Data; @Data public class Tony { @ToString.Exclude private Integer salary; } 被@ToString.Exclude注解修饰的属性不会被添加到 toString 中。 ","date":"2022-08-25","objectID":"/posts/framework/lombok/:7:1","tags":["java","框架","lombok"],"title":"Lombok","uri":"/posts/framework/lombok/"},{"categories":["Java框架"],"content":"@EqualsAndHashCode ","date":"2022-08-25","objectID":"/posts/framework/lombok/:8:0","tags":["java","框架","lombok"],"title":"Lombok","uri":"/posts/framework/lombok/"},{"categories":["Java框架"],"content":"@NoArgsConstructor ","date":"2022-08-25","objectID":"/posts/framework/lombok/:9:0","tags":["java","框架","lombok"],"title":"Lombok","uri":"/posts/framework/lombok/"},{"categories":["Java框架"],"content":"@RequiredArgsConstructor 为类属性生成构造方法。主要为以下属性生成构造方法。 被 @NonNull 注解的属性 被 final 修饰的常量属性 ","date":"2022-08-25","objectID":"/posts/framework/lombok/:10:0","tags":["java","框架","lombok"],"title":"Lombok","uri":"/posts/framework/lombok/"},{"categories":["Java框架"],"content":"用处 配合 final 生成构造方法注入 import lombok.RequiredArgsConstructor; @RequiredArgsConstructor public class IndexController { private final UserService userService; } 我们看字节码文件。 public class IndexController { private final UserService userService; public IndexController(UserService userService) { /* compiled code */ } } 从而实现了构造方法注入依赖。 ","date":"2022-08-25","objectID":"/posts/framework/lombok/:10:1","tags":["java","框架","lombok"],"title":"Lombok","uri":"/posts/framework/lombok/"},{"categories":["Java框架"],"content":"@AllArgsConstructor ","date":"2022-08-25","objectID":"/posts/framework/lombok/:11:0","tags":["java","框架","lombok"],"title":"Lombok","uri":"/posts/framework/lombok/"},{"categories":["Java框架"],"content":"@Data All together now: A shortcut for @ToString, @EqualsAndHashCode, @Getter on all fields, and @Setter on all non-final fields, and @RequiredArgsConstructor! 大概意思就是说这个注解，1 个顶 5 个。 具体顶哪 5 个，就是上面描述的。 源码： @Data class UserInfo { private String address; } 编译完的 字节码 class 文件： class UserInfo { private java.lang.String address; public UserInfo() { /* compiled code */ } public java.lang.String getAddress() { /* compiled code */ } public void setAddress(java.lang.String address) { /* compiled code */ } public boolean equals(java.lang.Object o) { /* compiled code */ } protected boolean canEqual(java.lang.Object other) { /* compiled code */ } public int hashCode() { /* compiled code */ } public java.lang.String toString() { /* compiled code */ } } 从字节码中看，补充了getXXX，setXXX，equals，canEqual，hashCode，toString。 ","date":"2022-08-25","objectID":"/posts/framework/lombok/:12:0","tags":["java","框架","lombok"],"title":"Lombok","uri":"/posts/framework/lombok/"},{"categories":["Java框架"],"content":"排除某个方法 @Data 默认帮我们实现了多个方法，如果我们不想实现其中的某个方法，如何排除掉呢，不支持。 ","date":"2022-08-25","objectID":"/posts/framework/lombok/:12:1","tags":["java","框架","lombok"],"title":"Lombok","uri":"/posts/framework/lombok/"},{"categories":["Java框架"],"content":"@Value 相当于 @Data，且给属性加上 final ，但是没有setXXX方法。 ","date":"2022-08-25","objectID":"/posts/framework/lombok/:13:0","tags":["java","框架","lombok"],"title":"Lombok","uri":"/posts/framework/lombok/"},{"categories":["Java基础"],"content":"Java语言基础 ==声明==：下文可能涉及到一些词，他们是等价的。 成员属性 == 实例属性 == 成员变量 成员方法 == 实例方法 == 普通方法 类属性 == 类变量 == 静态变量 类方法 == 静态方法 ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:0:0","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"概念 ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:1:0","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"原码反码补码 数字 原码 反码 补码 10 = 0000 1010（整数原码就是其二进制表示） 0000 1010 0000 1010 0000 1010 -10 = 1000 1010（负数的原码是其正数的源码，改变符号位） 1000 1010 1111 0101（原码符号位不变，其余各位按位取反） 1111 0110（反码加1） 执行：-10 + 10 0000 1010 1111 0110 = 1 0000 0000 由于我们使用 1 字节存储，导致溢出的 1 被抛弃，最终结果就是 0 ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:1:1","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"数据类型 注意：java.lang.Void是void的包装类，null对应的就是返回值void。 8 种基本数据类型，基本数据类型就是 CPU 可以直接运算的数据类型。其余是引用数据类型。但是 Java 的引用数据类型与 PHP 有区别，不是真引用，或者叫地址引用数据类型。 大小 数据类型 字节 大小 定义 默认值 适用 byte 1 -128（-2^7）~127（2^7-1） byte age = 100; 0 年龄，超过 127 岁的不多 short 2 -32768（-2^15）~32767（2^15-1） short student = 1000; 0 年级的学生 int 4 -2147483648(-2^31)~2147483647(2^31-1) int people = 140000000; 0 中国人口 14 亿 long 8 long l1 = 0L; 或者 long l2 = 0l; 0L 推荐 L ，小 l 容易跟 1 混淆 float 4 float f1 = 0.0f; 或者 float f2 = 0.0F; 0.0f double 8 double d1 = 0.0d; 或者 double d2 = 0.0D; 或者 double d3 = 0.0; 0.0d boolean ture 或 false false char 2 ‘A’ 数据类型所占字节数 ┌───┐ byte │ │ └───┘ ┌───┬───┐ short │ │ │ └───┴───┘ ┌───┬───┬───┬───┐ int │ │ │ │ │ └───┴───┴───┴───┘ ┌───┬───┬───┬───┬───┬───┬───┬───┐ long │ │ │ │ │ │ │ │ │ └───┴───┴───┴───┴───┴───┴───┴───┘ ┌───┬───┬───┬───┐ float │ │ │ │ │ └───┴───┴───┴───┘ ┌───┬───┬───┬───┬───┬───┬───┬───┐ double │ │ │ │ │ │ │ │ │ └───┴───┴───┴───┴───┴───┴───┴───┘ ┌───┬───┐ char │ │ │ └───┴───┘ boolean 占几字节 Java 语言对布尔类型的存储并没有做规定，因为理论上存储布尔类型只需要 1 bit，但是通常 JVM 内部会把 boolean 表示为 4 字节整数。 在符合 JVM 规范的虚拟机中，如果 boolean 是单独使用，boolean 占 4 个字节，如果 boolean 是以 “boolean数组” 的形式使用，boolean 占 1 个字节。 原因： 《Java虚拟机规范》一书中说 JVM 没有提供 booolean 类型专用的字节码指令，而是使用 int（4byte） 相关指令来代替。对 boolean 数组的访问与修改，会共用 byte（1byte） 数组的 baload 和 bastore 指令。 定义格式 4 种整型： // 整型：字节（-128 ~ 127），年龄一般不会超过 127 ，本着够用的原则 byte age = 23; // 整型：短整型（-32768 ~ 32767），最大值 3 万 2 short studentNum = 31000; // 整型：整型（-2147483648 ~ 2147483647），最大 21 亿，中国人口 14 亿 int chineseNum = 1400000000; // 整型：长整型（-9223372036854775808 ~ 9223372036854775807），最大 9百万万亿，定义一个 23 亿 // 长整型，必须带标识 L，不推荐使用小 l ，因为跟 1 长得太像。ipv4 42 亿 9 千万 long ipv4 = 4294967296L; assert ipv4 == (long) Math.pow(2, 32); 2 种浮点型，浮点数就是小数，由于使用科学计数法表示小数时，其小数点是可以前后浮动的，所以称之为浮点数。 // 浮点类型单精度 float score1 = 59.3f; float score2 = 59.3F; // 默认是双精度浮点数 double score3 = 59.3; 浮点数的最大值 System.out.println(Float.MAX_VALUE); // 3.4028235E38 即 3.4*10^38 System.out.println(Double.MAX_VALUE); // 1.7976931348623157E308 即 1.79*10^308 字符 char var1 = 'a'; // Java 是 Unicode 编码，char 是 2 字节，所以支持中文字符 char var2 = '中'; 布尔类型 // 布尔类型 boolean res1 = false; boolean res2 = !res1; 未初始化的变量，不能直接使用，但是有默认值 // 年龄 byte age; System.out.println(age);// java: 可能尚未初始化变量age // 月薪 short salary; System.out.println(salary); // 中国人口 int chineseNum; System.out.println(chineseNum); // ipv4 最大个数 long ipv4; System.out.println(ipv4); float f; double d; // 状态 boolean isOK; System.out.println(isOK); // 字符 char a; System.out.println(a); 常量 // 常量使用，只能初始化一次：先定义，后初始化 final double PI; PI = 3.14; // 常量使用，只能初始化一次：定义的同时进行初始化 final double PI = 3.14; 数组 数组的 3 种定义方式： class HappyCode { @Test public void testDrivenLearn() { // 定义方式一：省略类型，常用 char[] var1 = {'a', 'b', 'c'}; System.out.println(var1); // 定义方式二：定义时指定大小 char[] var2 = new char[3]; var2[0] = 'a'; var2[1] = 'b'; var2[2] = 'c'; System.out.println(var2); // 定义方式三：边定义边初始化，数组长度由编译器推算数组大小 char[] var3 = new char[]{'a', 'b', 'c'}; System.out.println(var3); } } ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:1:2","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"浮点数不靠谱 浮点数存储不靠谱，运算也不靠谱 // 十进制 0.1 的二进制是无限循环小数 System.out.println(0.1 + 0.2); // 0.30000000000000004 浮点数的正确比较相等方式 class HappyCode { @Test public void testDrivenLearn() { // 浮点数正确的比较方式 double d1 = 0.3; double d2 = 0.1 + 0.2; // 错误的比较方式 assert d1 != d2; // 正确的比较方式 assert Math.abs(d1 - d2) \u003c 0.00001; } } 整数与浮点数一起运算发生类型提升 整型提升为浮点型 class HappyCode { @Test public void testDrivenLearn() { // 类型提升，5，24 分别被提升为 5.0 和 24.0 assert 4.8 == 24.0 / 5; assert 4.8 == 24 / 5.0; assert 4 == 24 / 5; } } ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:1:3","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"除零溢出 class HappyCode { @Test public void testDrivenLearn() { // java.lang.ArithmeticException: / by zero int var1 = 4 / 0; } } ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:1:4","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"显示强转型 浮点型转成整型时，会丢弃小数部分，仅保留整数部分 如何让浮点型转整型做到四舍五入的效果，先给浮点数+0.5，在转型 不同类型运算时，低精度会提升为高精度，短会转成长的参与运算 比较两个浮点数通常比较它们的差的绝对值是否小于一个特定值 ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:1:5","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"类文件 1个类文件里有且仅有1个public类，且类名与文件名保持一致 1个类文件里可以有多个class ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:1:6","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"方法签名 方法签名仅包含：方法名，形参（形参包括参数的个数，类型，顺序），==不包含方法返回值，和各种方法修饰符== ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:1:7","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"成员属性，成员方法 成员属性 == 实例属性 == 成员变量 成员方法 == 实例方法 成员属性，成员方法，在类实例化时初始化，即 new 的时候初始化，分配在堆中。 ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:1:8","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"类属性，类方法 类属性 == 类变量 == 静态变量 类方法 == 静态方法 被static修饰的成员属性，叫做类属性。 被static修饰的成员方法，叫做类方法。 类属性和类方法在类加载的时候，初始化，分配在静态内存区，不需要做类实例化就能用。 ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:1:9","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"NO-OP 我们会发现一些接口的默认方法的 docs 中会出现 NO-OP 的描述。 大咖秀 /** * Notification that an attribute has been added to a session. Called after * the attribute is added. * The default implementation is a NO-OP. * * @param se Information about the added attribute */ public default void attributeAdded(HttpSessionBindingEvent se) { } NO-OP == No Operation，即没有任何操作，没有操作不就是一个空方法体么。 ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:1:10","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"继承 ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:1:11","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"方法重写和重载 特点 方法重写 方法重载 定制修饰符 @Override 无 可修改方法修饰符（public|final…） 可以 子类重写方法的访问权限必须比父类大。 可以 变更方法返回值类型 不可 可以 变更方法名称 不可 不可 变更形参 不可 可以 可以变更形参列表，个数，类型，顺序 ==方法签名==不同即是方法重载，方法签名和方法返回值都相同，是重写。方法签名相同但方法返回值不同，编译器会报错。 加==@Override==注解，可以让编译器帮助检查是否进行了正确的重写。如果不小心写错了方法签名，编译器会报错。 PHP 子类继承父类的有参构造方法，而 Java 只能继承父类的无参构造。 ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:1:12","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"可见性 如下操作，会打开变量可见性。 操作 原因 使用 ==volatile==修饰变量 执行 ==synchronized== 修饰的代码 执行同步代码前，会重新加载 执行 ==Thread.sleep()== 方法让出 CPU 让出 CPU 时，会重新加载变量 执行 ==System.out.println()== 方法 println 是同步方法，因为要做打印字符和打印换行符 2 个操作 由于需要保证这 2 个操作同时执行，不发生线程切换，必须同步执行。 ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:1:13","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"访问权限修饰符 ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:1:14","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"规则 ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:2:0","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"源文件规则 1 个源文件可以有多个非 public 类，但是只能有 1 个 public 类 源文件的名称要与 public 类的类名保持一致，包括大小写，因为 Java 大小写敏感 ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:2:1","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"JavaBean ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:3:0","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"特点 Java Bean 的特点，就是如果一个类满足如下特性，就可以说他是一个 Java Bean 了。 属性全私有，属性的访问和操作靠 setXXX/getXXX 方法 显式声明无参构造方法 类访问属性必须是 public class 实现 Serializable 接口，支持序列化 ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:3:1","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"作用 JavaBean 主要用来传递数据，即把一组数据组合成一个 JavaBean 便于传输。此外，JavaBean 可以方便地被 IDE 工具分析，生成读写属性的代码，主要用在图形界面的可视化设计中。 JavaBean 是一种符合命名规范的class，它通过getter和setter来定义属性。 使用Introspector.getBeanInfo()可以获取属性列表。 JavaBean 细分为：DTO，VO Bean 作用 DAO（Data Access Object）数据访问对象 VO（View Object）视图对象 ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:3:2","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"常用类 ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:4:0","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"Serializable 接口 ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:4:1","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"字符串 编码 class HappyCode { @Test public void testDrivenLearn() { char zh = '\\u4e2d'; assert '中' == zh; System.out.println(zh); // 中 } } String class HappyCode { @Test public void testDrivenLearn() { String str = \"hello world!\"; // 求字符串长度 assert 12 == str.length(); // 比较字符串是否相等 assert str.equals(\"hello world!\"); // 获取二个字符，字符是基本数据类型，可以直接使用 == 比较 assert 'e' == str.charAt(1); // 字符串转大写 assert str.toUpperCase(Locale.ROOT).equals(\"HELLO WORLD!\"); // 判断字符串中是否包含字符 d assert true == str.contains(\"d\"); // 判断字符串是否以某个字串结尾 assert true == str.endsWith(\"d!\"); assert true == str.startsWith(\"he\"); assert true == str.startsWith(\"ll\", 2); // 截取字符串 assert str.substring(0, 3).equals(\"hel\"); assert str.substring(2).equals(\"llo world!\"); // 查找字串的位置 assert 2 == str.indexOf(\"l\"); assert 9 == str.lastIndexOf(\"l\"); assert 6 == str.indexOf(\"wo\"); // 空白判断 assert true == \"\".isEmpty(); assert false == \" \".isEmpty(); // 替换 assert str.replace('l', 'L').equals(\"heLLo worLd!\"); // 字符数组，字符串互转 char[] cs = \"hello\".toCharArray(); cs[1] = 'w'; String str1 = new String(cs); assert true == str1.equals(\"hwllo\"); cs[0] = 'w'; assert true == new String(cs).equals(\"wwllo\"); assert true == str1.equals(\"hwllo\"); } } StringBuilder StringJoiner class HappyCode { @Test public void testDrivenLearn() { // 字符串拼接 String[] names = {\"tony\", \"maria\",}; assert true == \"tony,maria\".equals(String.join(\",\", names)); StringJoiner stringJoiner = new StringJoiner(\",\", \"hello \", \"!\"); for (String name : names) { stringJoiner.add(name); } assert true == \"hello tony,maria!\".equals(stringJoiner.toString()); } } 总结：拼接需要使用前后缀的，使用StringJoiner，只需要简单的拼接使用java.lang.String#join(java.lang.CharSequence, java.lang.CharSequence...)。 StringBuffer StringBuilder的线程安全版，原因使用synchronized修饰了方法。 public synchronized StringBuffer append(String str); public synchronized StringBuffer append(StringBuffer sb); public synchronized String substring(int start); // ... ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:4:2","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"数组 数组[]和Array，ArrayList区别 []是定义数组简写 Array这个类不存在，即不存在java.lang.Array ArrayList是集合，是List的子类，类似数组 数组[]转List ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:4:3","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"Map HashMap HashTable HashTable 相较于 HashMap 线程安全。 ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:4:4","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"任意大小的数 BigInteger-任意大小的整数 BigDecimal-任意大小的小数 BigDecimal可以表示一个任意大小且精度完全准确的浮点数。 方法 特点 == 比较两个对象的地址，即是否为同一个对象 java.math.BigDecimal#compareTo 相等返回 0，大于返回 1，小于返回 -1 仅比较两个数的大小，不比较精度scale 比较两个数是否相等，==推荐使用compareTo()方法== java.math.BigDecimal#equals 不仅比较两个数的大小，还比较精度 打开BigDecimal源码，发现其包含一个大整数和小数的位置。 ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:4:5","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"Math 随机数生成 // 生成随机数[min, max)：随机比例 * (max - min) + min，生成1，100的随机数 double random1 = Math.random() * (101 - 1) + 1; int random2 = (int) random1; Math.random()返回值介于[0, 1)之间，类似一个比例。 ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:4:6","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"ReentrantLock ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:4:7","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"装箱 所有的包装类型都是不变的，因为其底层都是基本类型常量private final float value; 自动装箱，自动拆箱在编译期完成 包装类型比较必须使用equals()方法 class HappyCode { @Test public void testDrivenLearn() { // 隐式装箱 Integer age1 = 23; // 显式装箱，常用隐式装箱 Integer age2 = new Integer(23); Integer age3 = Integer.valueOf(23); // 显式拆箱 int age4 = age1.intValue(); // 隐式拆箱，常用隐式拆箱 int age5 = age2; } } ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:5:0","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"BigDecimal 安全使用 2 种方式 todo ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:5:1","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"类型转换 ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:6:0","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"字符串转其他 操作 code 转字节类型 String s = new String(“hello 广州”); byte[] sBytes = s.getBytes(StandardCharsets.UTF_8); 基本数据类型转字符串 String.valueOf() 重载了支持多种基本数据类型 ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:6:1","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"整型转其他 ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:6:2","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"多态 多态是指，针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法。 class Tony implements Student { @Override public void say() { System.out.println(\"I am tony\"); } } class Maria implements Student { @Override public void say() { System.out.println(\"I am maria\"); } } class People { public static void introduce(Student student) { student.say(); } } class HappyCode { @Test public void testDrivenLearn() { People.introduce(new Tony()); // I am tony People.introduce(new Maria()); // I am maria } } ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:7:0","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"Object类 Object 是 Java 中的万类之父，类似 PHP 中的 stdClass。 ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:8:0","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"hashCode与equals 集合需要检查元素是否存在，hashCode 获得元素地址，比遍历元素比较 equals 来的快。 A.equals(B) == true 即两个值相同，其 hashCode 一定相同。但是反过来，hashCode 相同的，其值不一定相同。 equals 相同，hashCode 必须相同，要求重写 equals 的同时==必须重写 hashCode()== hashCode 相同，equals 不一定相同。说明存在==哈希冲突==，相同 hashCode 但是 equals 不同的元素，我们在同一个哈希地址上，用链表存储，检查 HashMap 上是否存在某个值时，首先计算对象的 Hash 值，找到哈希地址，O(1)，发现此哈希地址上挂载了链表，此位置存在哈希冲突，然后遍历链表逐个元素比较，O(n)。 例如： 9 个哈希值相同的英文字符串： ArrayList\u003cInteger\u003e arrayList = new ArrayList\u003c\u003e(); arrayList.add(\"3Qj\".hashCode()); arrayList.add(\"2pj\".hashCode()); arrayList.add(\"2qK\".hashCode()); arrayList.add(\"2r,\".hashCode()); arrayList.add(\"3RK\".hashCode()); arrayList.add(\"3S,\".hashCode()); arrayList.add(\"42j\".hashCode()); arrayList.add(\"43K\".hashCode()); arrayList.add(\"44,\".hashCode()); System.out.println(arrayList); // [51628, 51628, 51628, 51628, 51628, 51628, 51628, 51628, 51628] 2 个哈希值相同的中文词： equals() 方法的 4 大原则，指导我们实现 equals 方法必须遵循这个原则 特性 equals 方法必须遵循以下原则 自反性 A.equals(A) == true 一致性 没有修改 A 和 B 的情况下，永久 true == A.equals(B) 像不像幂等 传递性 如果 true == A.quals(B)，true == B.equals(C)，存在 A.equals(C) 对称性 如果 true == A.equals(B)，存在 true == B.equals(A) ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:8:1","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"Class类 Class是一个用来表示类的类，它内部可以记录类的成员、接口等信息。 Class 类也是 Object 的子类。 获取类的 Class 实例的 3 种方法 通过当前类对象的 getClass() 方法获取 Class 的实例 通过 Class.forName(当前类的完整限定名) 获取当前类的 Class 实例 当前类类名.class获取 Class 实例 A.class 即 A 类的表达类 Class 的实例。在 JVM 种，每个类的 Class 类有且仅有一个实例。 或者说 A.class 是 new A() 实例的模板。 ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:9:0","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"构造方法 class Parent { } // 下面是编译器编译生成的字节码 class Parent { Parent() { /* compiled code */ } } javac 编译器一定会为无构造方法的类，创建无参构造方法，并在所有构造方法的第一行隐式调用其父类的无参构造；定义了构造方法的类，编译器不再为其创建无参构造方法 子类所有构造方法的第一行，必须是调用父类的构造方法，父类的无参构造可以隐式调用不写，有参构造必须显示调用写出来 子类不可能重写父类的构造方法，即使子类中定义了一个与父类同名的方法，那也不叫重写，只是一个新方法 class Parent { public Parent() { System.out.println(\"父类的无参构造\"); } } class Son1 extends Parent { public void Parent() { System.out.println(\"子类的普通方法\"); } public Son1() { System.out.println(\"子类的无参构造\"); } } new Parent(); // 父类的无参构造 new Son1(); // 父类的无参构造 子类的无参构造 ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:10:0","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"初始化顺序 静态变量和静态代码块，在类加载时初始化，==至于静态变量和静态代码块初始化的顺序，取决于他们定义的顺序==。 实例变量和实例方法在类加载后，new 的时候初始化。 ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:11:0","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"静态导包 即一次性导入某个类的所有静态方法和静态属性，在本类中使用导入类的公有，私有属性和方法，不用加类名，就像使用本类的属性和方法一样容易。 有点类似 PHP 里的 use triat，在本类中，复制了一份导入类的代码。 ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:12:0","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"宏 其实 C 语言的宏定义在 Java 中是真实存在的。由于低版本的 PHP 还不支持类属性被赋值表达式，进而无法完成宏定义。 class Chinese { public static final Chinese HELLO = new Chinese().hello(); public Chinese hello() { // 宏定义任务 System.out.println(\"hello world\"); return this; } } // 执行宏 Chinese hello = Chinese.HELLO; ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:13:0","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"大咖秀 public final class Boolean implements java.io.Serializable, Comparable\u003cBoolean\u003e { /** * The {@code Boolean} object corresponding to the primitive * value {@code true}. */ public static final Boolean TRUE = new Boolean(true); /** * The {@code Boolean} object corresponding to the primitive * value {@code false}. */ public static final Boolean FALSE = new Boolean(false); } // 利用宏定义 new 一个对象 Boolean abc = Boolean.TRUE; ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:13:1","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"静态方法 静态方法不能是抽象的，因为他要在类加载的时候执行方法体 ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:14:0","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"内部类 内部静态类有静态方法，非静态方法 内部非静态类只有非静态方法 class OutClass { class InnerClass { public void say() { System.out.println(\"我是普通内部类普通方法\"); } // java 8 不支持普通内部类中定义静态方法 // public static void staticSay() { // System.out.println(\"我是普通内部类的静态方法\"); // } } static class StaticInnerClass { public void say() { System.out.println(\"我是静态内部类的普通方法\"); } public static void staticSay() { System.out.println(\"我是静态内部类的静态方法\"); } } public void say() { System.out.println(\"我是外部类的普通方法\"); } } // 调用内部静态类的，静态方法 OutClass.StaticInnerClass.staticSay(); OutClass outClass = new OutClass(); // 调用内部非静态类的，非静态方法 OutClass.InnerClass innerClass = outClass.new InnerClass(); innerClass.say(); // 那么如何调用内部静态类的，非静态方法呢 ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:15:0","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"关键字 ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:16:0","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"switch switch(变量) 不支持 Long/long 类型。 ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:16:1","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"模板类Class Class 类的实例是每个类的实例的模板，且 JVM 中有且仅有一份。 代码展示： class Student { } // 由于一个类有且仅有一个对象模板，所以下面三个 Class 对象是相同的 Student student1 = new Student(); Student student2 = new Student(); assert student1 != student2; // 获取类的模板实例方式一 == 获取类的模板实例方式二 assert Student.class == student1.getClass(); assert Student.class == student2.getClass(); assert student1.getClass() == student2.getClass(); // Object 是万类之父? assert Student.class instanceof Class; assert Student.class instanceof Object; assert Object.class instanceof Class; assert Class.class instanceof Object; // 不可比较的类型: java.lang.Class\u003cjava.lang.Class\u003e和java.lang.Class\u003cjava.lang.Object\u003e System.out.println(Class.class); // class java.lang.Class System.out.println(Object.class); // class java.lang.Object assert Class.class instanceof Class; assert Class.class.getClass() instanceof Class; assert Class.class == Class.class.getClass(); // 问 Object 跟 Class 的关系? // 必须捕获异常 try { // 获取类的模板实例：方式三 assert Class.forName(\"shali.bbs.temp.Student\") instanceof Class; } catch (ClassNotFoundException e) { e.printStackTrace(); } ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:16:2","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"Class\u003c?\u003e ==不要觉得 Class 类多么高端莫测，其实他就相当于 PHP 中的ReflectionClass类，对反射类。不知道 Java 为何不叫反射类。== public final native Class\u003c?\u003e getClass(); 说?表示未知的类型，既然是未知的类型，为何不像泛型那样，使用Class\u003cT\u003e呢？ Class 类的实例是单例 import org.junit.Assert; import org.junit.Test; public class ClassTest { class A { } @Test public void singleton() { A a1 = new A(); A a2 = new A(); Assert.assertNotSame(a1, a2); Class\u003c? extends A\u003e a1Class = a1.getClass(); Class\u003c? extends A\u003e a2Class = a2.getClass(); Class\u003cA\u003e a3Class = A.class; Assert.assertSame(a1Class, a2Class); Assert.assertSame(a1Class, a3Class); } } ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:16:3","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"volatile 作用：==打开线程间变量的可访问性==，==禁止指令重排序==。 英文的意思是很容易变的，需要你常去更新。 大咖秀 public class Thread implements Runnable { private volatile String name; } volatile 修饰的变量，线程间可访问。线程的名字用 volatile 修饰，就是为了让不同的线程，可以获取彼此的名称。 volatile 修饰的线程共享变量，存放在主内存区。 JMM（Java　Memory Model），Java 内存模型规定： 所有的共享变量都存储于主内存。这里所说的变量指的是实例变量和类变量，不包含局部变量，因为局部变量是线程私有的，因此不存在竞争问题。 各个线程自己的变量存放在本地内存。 思考开放线程中的变量的可访问性，还有什么方法？ volatile 同 synchronized 对比 指令重排 注意下面的代码不是重排序，而是 JVM 的优化。 // 源码 boolean isStop = false; while (!isStop) {} // JVM 指令重排 while (true) {} ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:16:4","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"extends 接口 extends 接口 抽象类 extends 接口 抽象类 extends 抽象类 具体类 extends 接口 具体类 extends 抽象类 不像其他语言，对泛化和实现关系使用不同的关键字进行区分，比如 PHP，extends表泛化，implements表实现。 ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:16:5","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"transient adj. 短暂的，临时的 我们知道，如果想序列化一个对象，只要其实现了java.io.Serializable接口，其属性和方法就能被自动地序列化。但是有些属性比较敏感，比如用户的密码属性，我们只想其运行时出现在内存中，不想被序列化传输和保存怎么办，那我们就需要给这个属性进行标记。 private transient String password; transient 只能修饰成员属性，不能修饰类属性，因为类属性，修饰与否，都不会被序列化 transient 一旦修饰了某个成员变量，这个实例被反序列化后，其成员变量是 null ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:16:6","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"native public native int hashCode(); 被native修饰的方法，说明这个方法不是 Java 语言实现，而是其他语言编译生成动态链接库dll给 Java 调用。 ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:16:7","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"final 被修饰者 特性 局部变量 被 final 修饰的局部变量是局部常量，只能赋值一次，不可改变 ==final 修饰局部常量，使用之前必须赋值== 成员属性 被 final 修饰的成员属性叫实例常量 ==final 修饰的成员变量声明时未赋值的，必须在构造方法/静态代码块中初始化，即保证创建对象的时候初始化。== 类属性 类常量 成员方法 不能被重写Override，==可以被重载== 类 不能被继承，final 让类变成太监类 final 修饰成员属性 class People { // 一：定义的时候初始化 private final String nationality = \"汉\"; // 二：静态代码块里初始化 private static final String country; // 三：构造方法里初始化 private final String name; static { country = \"中国\"; } People(String name) { this.name = name; } } ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:16:8","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"static 被修饰者 特点 代码块{} 被 static 修饰的代码块，在类文件加载时，就执行。 类属性 被 static 修饰的成员属性就会变成类属性，因为所有对象共享此变量 类方法 被 static 修饰的成员方法为类方法，类方法，可以不需要实例化，直接使用类名调用。 类方法中不能调用成员方法，但是成员方法中可以调用类方法。 ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:16:9","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"synchronized synchronized翻译成同步，很容易产生误解。 因为汉语中的同步是同时进行，同时发生。而synchronized刚好相反，不能同时进行，要按照顺序进行。 那线程同步是不是要让两个线程同时执行呢？ 不是的，这里的synchronized同步就不是那个意思了，而是我前面做，你后面做，我们不能同时做。即方法 A 不执行完，方法 B 不能执行。 异步就不一样了，方法 B 不需要等方法 A 执行完，就可以去执行，这是异步。 被修饰者 特点 抽象方法 synchronized 不能修饰抽象类或接口中的抽象方法 构造方法 synchronized 不能修饰构造方法 普通方法 synchronized 修饰的构造方法，子类重写时，如果需要同步，需要继续添加 synchronized 关键字 同步代码块 同步方法 同步代码块和同步方法，其实都说明了其持有的锁。只不过同步方法隐式地持有 this 对象。 注意，当同步代码（同步代码块和同步方法）使用相同的锁时，彼此不会等对方是否锁，即可进入同步代码。 由于 synchronized 是在 JVM 层面实现的，因此系统可以监控锁的释放与否； 而 ReentrantLock 是使用代码实现的，系统无法自动释放锁，需要在代码中的 finally 子句中显式释放锁 lock.unlock()。 另外，在并发量比较小的情况下，使用 synchronized 是个不错的选择； 但是在并发量比较高的情况下，其性能下降会很严重，此时 ReentrantLock 是个不错的方案。 ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:16:10","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"注解 Java1.5 开始引入注解。 注解 类型 功能描述 @Override 语言内置注解 注解方法，说这是一个被子类重写的方法 @Target 元注解 注解注解，说这个注解可以用来注解类还是类方法 ElementType.METHOD 表示可以用来注解类方法 ElementType.TYPE 表示可以用来注解类 @Retention 元注解 注解注解，用于提示注解被保留多长时间。 例如 RetentionPolicy.RUNTIME 表示注解在运行期间一直保留 @Documented 元注解 表示注解是否能被 javadoc 处理并保留在文档中 ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:17:0","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"元注解 元注解就是能够定义注解的注解。我们可以使用元注解，来定制我们自己需要的注解。 ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:17:1","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"自定义注解 下面我们要实现自己的注解。 学习元注解 可以修饰注解的注解，我们称之为元注解。 关键字 功能描述 @interface ==不是元注解==，注解类型声明关键字，类似class，interface等声明关键字 @Inherited 子类是否能从被父类继承此注解 @Target 参数是ElementType[]，指定被注解修饰的类型 @Documented 此注解是否允许被 Javadoc 工具解析成文档 @Retention 指明注解的声明周期，存于源码中，字节码中，还是 JVM 运行时。 定义注解 我们希望定义一种注解，当其注解方法时，就输出一句话。输出的话可以指定内容。 定义注解也可以理解为定义标签。 import java.lang.annotation.*; // 注解允许被 Javadoc 工具提取为文档 @Documented // 注解允许被继承 @Inherited // 仅注解方法 @Target({ElementType.METHOD}) // 声明周期到运行时 @Retention(RetentionPolicy.RUNTIME) public @interface MyAnnotation { // 可以理解为注解的属性，写成方法的形式是为了后面好调用 String say() default \"\"; } 使用注解 import java.lang.reflect.Method; public class AnnotationTest { @Test @MyAnnotation(say = \"我的注解解析器被执行了\") public void annotationProcessor() { Method method = null; try { // 反射当前方法 method = this.getClass().getMethod(\"annotationProcessor\"); } catch (NoSuchMethodException e) { e.printStackTrace(); } if (null == method) { return; } // 检查当前方法是否存在我定义的注解 MyAnnotation myAnnotation = method.getAnnotation(MyAnnotation.class); if (null != myAnnotation) { System.out.println(myAnnotation.say()); } } } 起始我们上面的代码不仅使用了注解，还解析了注解。但是这种解析是方法自己完成的，能不能交给容器来完成我们自定义注解的处理呢。 定义注解处理器 import javax.annotation.processing.AbstractProcessor; @SupportedAnnotationTypes(\"com.shali.ruby.bean.MyAnnotation\") public class MyAnnotationProcessor extends AbstractProcessor { @Override public synchronized void init(ProcessingEnvironment processingEnv) { super.init(processingEnv); } @Override public boolean process(Set\u003c? extends TypeElement\u003e annotations, RoundEnvironment roundEnv) { return false; } } ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:17:2","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"重写Override方法 ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:18:0","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"重写equals()必重写hashCode()方法 由于我们要保证相同的对象，其哈希值必定相同。 定义一个中国公民类，只要他们身份证号相同，我们就认为他们是同一个人 class People { private final String id; People(String id) { this.id = id; } @Override public boolean equals(Object o) { // 不重写 equals 方法，就没法做到，相同身份证 id，用 equals() 判断是同一个人 if (this == o) { return true; } else if (o == null || getClass() != o.getClass()) { return false; } People people = (People) o; return this.id.equals(people.id); } } class HappyCode { @Test public void testDrivenLearn() { People people1 = new People(\"123456\"); People people2 = new People(\"123456\"); assert people1.equals(people2); assert people1.hashCode() != people2.hashCode(); System.out.println(people1.hashCode()); // 22805895 System.out.println(people2.hashCode()); // 1413378318 } } 通过我们重写equals()方法，仅比较 id ，我们做到了相同 id，就是相同的人。但是我们发现相同对象，但是其 hash 值却不相同。这有点违背equals()相同的对象，其哈希值必相同的原则。看来我们需要重写hashCode()方法。 class People { private final String id; People(String id) { this.id = id; } @Override public boolean equals(Object o) { // 不重写 equals 方法，就没法做到，相同身份证 id，用 equals() 判断是同一个人 if (this == o) { return true; } else if (o == null || getClass() != o.getClass()) { return false; } People people = (People) o; return this.id.equals(people.id); } @Override public int hashCode() { // 重写了 equals 方法，必重写 hashCode 方法，不然没法确保 equals 相同，hashCode 必相同的原则 return this.id.hashCode(); } } class HappyCode { @Test public void testDrivenLearn() { People people1 = new People(\"123456\"); People people2 = new People(\"123456\"); assert people1.equals(people2); assert people1.hashCode() == people2.hashCode(); System.out.println(people1.hashCode()); // 1450575459 System.out.println(people2.hashCode()); // 1450575459 } } ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:18:1","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"泛型与通配符?的区别 通配符 ? 表示编译期不能确定的类型，但运行时其类型是确定的 T，K，V，E，A，B，C 泛型代表编译时其类型就是确定的，因为编码使用的时候已经指的了类型 ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:19:0","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"黑窗口 黑窗口，命令行运行代码 编译 javac -encoding utf8 Test.java 运行并开启断言 java -ea Test，如果不开启断言，断言失败了，是不会抛出异常的。 ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:20:0","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"线程 常用方法： 方法 特点 wait() 释放对象锁 让出 CPU 需要 notify() 唤醒，才能使用 CPU sleep() 不释放对象锁 让出 CPU 不需要任何唤醒，睡眠时间到，就可以去使用 CPU notify() 执行完 notify() 方法，当前线程并不会释放锁，需要等 synchronized 代码执行完毕 wait 让出 CPU，释放锁，暂停当前线程，后续需要唤醒，才能被 CPU 调度。 yield 类方法，让出 CPU，不释放锁，类似循环中的 continue，迎接下一轮的 CPU 调度。 sleep 类方法，让出 CPU，不释放锁，类似定时器，定时时间到了，才能被 CPU 调度。 interrupt 无实质作用的方法。 ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:21:0","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"线程空间 空间 特点 主内存 线程之间的共享变量（实例变量和类变量，不包含局部变量）存储在主内存中。 局部变量是线程私有的，是不存在竞争问题。我们平常上锁都是给共享变量上锁。 线程私有的本地内存，也叫工作内存 本地内存中存储了该线程读/写共享变量的副本。 线程不能直接读写共享变量，必须借助工作内存。 ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:21:1","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"线程内存模型 JMM（Java Memory Model）的抽象示意图： ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:21:2","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"线程变量可见性 方式 特点 volatile 使用 volatile 修饰共享变量后，每个线程要操作变量时会从主内存中将变量拷贝到本地内存作为副本，当线程操作变量副本并写回主内存后，会通过 ==CPU 总线嗅探机制==告知其他线程该变量副本已经失效，需要重新从主内存中读取。 synchronized 当一个线程进入 synchronized 代码块后，线程获取到锁，会清空本地内存，然后从主内存中拷贝共享变量的最新值到本地内存作为副本，执行代码，又将修改后的副本值刷新到主内存中，最后线程释放锁。 ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:21:3","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"池 ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:22:0","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"字符串常量池 String s1 = \"hi\"; String s2 = \"hi\"; String s3 = new String(\"hi\"); String s4 = new String(\"hi\"); assert s1 == s2; assert s3 != s2; assert s3 != s4; String s5 = s3.intern(); String s6 = s4.intern(); assert s5 == s6; assert s1 == s5; assert s5 != s3; ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:22:1","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"缓存池 Integer.valueOf() 强制使用缓存池 下面是此方法的实现源码： public static Integer valueOf(int i) { if (i \u003e= IntegerCache.low \u0026\u0026 i \u003c= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); } 在 Java 8 中，Integer 缓存池的大小默认为 -128 ~ 127。因为IntegerCache.low是-128，IntegerCache.high是127。 其实仔细看源码发现，最大值介于java.lang.Integer.IntegerCache.high~Integer.MAX_VALUE - (-low) -1之间，java.lang.Integer.IntegerCache.high是配置。 下面用代码来验证。 Integer a1 = 127; Integer a2 = 127; Integer a3 = 128; Integer a4 = 128; assert a1 == a2; assert a3 != a4; Integer a5 = -128; Integer a6 = -128; Integer a7 = -129; Integer a8 = -129; assert a5 == a6; assert a7 != a8; 那么我们如何使我们定义的变量，用到缓存池呢？ 答案是使用装箱方法，不是 new。看代码： // 定义一个缓存池常量 Integer a1 = Integer.valueOf(123); Integer a2 = new Integer(123); Integer a3 = 123; // a1 在缓存池，a2 在堆中 assert a1 != a2; // a3 会发生自动装箱操作，即调用 Integer.valueOf 方法，就是利用缓冲池 assert a3 == a1; ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:22:2","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"锁 互斥锁（mutex）只有加锁、解锁两种操作，且互斥锁的释放只能由加锁的那个线程来释放。 读写锁： 某线程对资源加读锁时，其他线程可以也可以加读锁，但是不能加写锁（意味着有人在读的时候，其他人也能读，不能写）。 某线程对资源加写锁时，其他线程什么锁都不能加（意味着有人在写的时候，其他人什么都不能干）。 读写锁有加读锁、加写锁、解锁三种操作。 排他锁：等于读写锁中的写锁，因为其他人什么都不能干，所以“排他”。 共享锁：等于读写锁中的读锁，因为其他人还可以读，所以“共享”。 自旋锁：线程在获取共享资源前先申请获取锁，如果申请不到，则一直继续申请（而不是阻塞），直到申请到为止。 循环自旋锁，递归自旋锁。 悲观锁：行锁，表锁。 乐观锁： CAS 机制：Compare And Swap 比较并替换，即修改之前现检查。 ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:23:0","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"synchronized ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:23:1","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"ReentrantLock ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:23:2","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"总结 synchronized：加锁解锁过程由 JVM 自动控制 ReentrantLock：需要手动释放锁 unlock 最后再贴一段 Doug Lea 大神在书中，关于在 synchronized 和 ReentrantLock 之间进行选择的原话，该如何选择，读者自己去思考吧。 在一些内置锁无法满足需求的情况下，ReentrantLock 可以作为一种高级工具。当需要一些高级功能时才应该使用 ReentrantLock，这些功能包括：可定时的，可轮询的与可中断的锁获取操作，公平队列，以及非块结构的锁。否则，还是应该优先使用synchronized。 ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:23:3","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"新特性 ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:24:0","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"1.8 Optional Optional 类是 Java8 的新特性，是一个可以为 null 的容器对象。用来解决空指针异常（NPE：java.lang.NullPointerException）。 UserInfo userInfo = new UserInfo(); userInfo.setAddress(\"guangzhou\"); User user = new User(); user.setUserInfo(userInfo); user = null; // 假如我们要获取 user 的地址信息，就要战战兢兢，防止 npe // 报空指针异常 System.out.println(user.getUserInfo()); // if else 检查，不报空指针异常 if (null != user) { UserInfo userInfo1 = user.getUserInfo(); if (null != userInfo1) { String address = userInfo1.getAddress(); System.out.println(address); } } // Optional 容器处理不报 npe String address = Optional.ofNullable(user).map(u -\u003e u.getUserInfo()).map(info -\u003e info.getAddress()).orElse(null); 顺便提一下PHP8.0也增加了类似的语法糖。 // 中途有一个实例是 null，则返回给 $address 的是 null $address = user?-\u003egetUserInfo()?-\u003egetAddress(); 印象中Swift语言也有此类特性，暂不记得，后面想起再补充。 接口支持定义抽象方法的默认实现 大咖秀 package javax.servlet.http; import java.util.EventListener; public interface HttpSessionListener extends EventListener { public default void sessionCreated(HttpSessionEvent se) { } public default void sessionDestroyed(HttpSessionEvent se) { } } 支持函数式编程，Lambda 函数式编程最早是数学家阿隆佐·邱奇研究的一套函数变换逻辑，又称Lambda Calculus（λ-Calculus），所以也经常把函数式编程称为Lambda计算。 Date and Time API Pipelines and Streams Type Annotations Nashhorn JavaScript Engine Concurrent Accumulators ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:24:1","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"解惑 ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:25:0","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"字符串 为什么 StringBuffer 相对于 StringBuilder 线程安全？ 因为java.lang.StringBuffer#append(java.lang.String)方法使用了同步方法。 @Override public synchronized StringBuffer append(String str) { toStringCache = null; super.append(str); return this; } 为什么 String 是不可变的？ 因为 String 类的底层使用char[]来存储的字符串的字符元素，而且这个字符数组被final修饰，即常量数组。 private final char value[]; ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:25:1","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"哈希表 为什么 Hashtable 相对于 HashMap 是线程安全的？ 因为java.util.Hashtable#put方法被synchronized修饰，即同步方法。 public synchronized V put(K key, V value) {} ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:25:2","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"Serializable 接口 为何实现 Serializable 接口时，要重写serialVersionUID属性？ public final class String implements java.io.Serializable, Comparable\u003cString\u003e, CharSequence { private static final long serialVersionUID = -6849794470754667710L; } serialVersionUID其实是用在反序列化时，验证类文件版本的一致性。 ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:25:3","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Java基础"],"content":"引用 volatile 关键字，你真的理解吗？ ","date":"2022-08-24","objectID":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/:26:0","tags":["语言","java"],"title":"Java语言基础","uri":"/posts/java%E5%9F%BA%E7%A1%80/yuyanjichu/"},{"categories":["Redis"],"content":" setnx key value setnx命令的全称是set if not exists，即当指定的 key 不存在时，设置值并返回 1，如果存在什么都不做，并返回 0。 setnx实现分布式锁 ","date":"2022-08-24","objectID":"/posts/database/setnx/:0:0","tags":["redis","分布式锁","锁"],"title":"Redis的分布式锁","uri":"/posts/database/setnx/"},{"categories":["Redis"],"content":"方式一 // 锁名词 $key = 'buy_order_lock'; // 加锁 if (false === $redis-\u003esetnx($key, time())) { var_dump('锁被其他进程拿到，且未超时'); return; } // 获得锁 // 执行业务 ... // 释放锁 if (0 === $redis-\u003edel($key)) { var_dump('任务完成，释放锁失败'); } ==存在问题==： 一旦释放锁失败，就会造成死锁。 ","date":"2022-08-24","objectID":"/posts/database/setnx/:1:0","tags":["redis","分布式锁","锁"],"title":"Redis的分布式锁","uri":"/posts/database/setnx/"},{"categories":["Redis"],"content":"方式二 // 加锁 if (false === $redis-\u003esetnx($key, time())) { var_dump('锁被其他进程拿到，且未超时'); return; } // 获得锁 // 执行业务 ... // 释放锁 if (0 === $redis-\u003edel($key)) { var_dump('任务完成，释放锁失败'); if (false === $redis-\u003eexpire($key, 0)) { var_dump('任务完成，设置锁过期时间失败'); } } ==存在问题==： 释放锁失败，再给锁加个过期时间，这种做法跟释放锁失败，再次执行释放锁没啥区别。还是没有解决死锁的问题。 这种释放锁失败的问题没法避免，不如给锁加个超时时间。 ","date":"2022-08-24","objectID":"/posts/database/setnx/:2:0","tags":["redis","分布式锁","锁"],"title":"Redis的分布式锁","uri":"/posts/database/setnx/"},{"categories":["Redis"],"content":"方式三 // 锁名词 $key = 'buy_order_lock'; // 锁超时时间 $timeout = 10; // 加锁 if (false === $redis-\u003esetnx($key, time() + $timeout)) { $t = $redis-\u003eget($key); if ($t \u003e time()) { var_dump('锁被其他进程拿到，且未超时'); return; } // 释放超时锁 if (0 === $redis-\u003edelete($key)) {// 临界区 var_dump('释放超时锁失败'); return; } // 再次加锁 if (false === $redis-\u003esetnx($key, time() + $timeout)) { var_dump('再次加锁失败'); return; } } // 获得锁 // 执行业务 ... // 释放锁 if (0 === $redis-\u003edel($key)) { var_dump('任务完成，释放锁失败'); } 解决了死锁的问题，但是又引入了新的问题。 ==存在问题==： 如果进程 P2 和 P3 同时进入临界区，进程 P2 删除了锁，并获得了锁，但是 P3 仅接着又删除了锁，再次获得了锁。 这种并发问题又出现了，因为又有多个进程获得了锁。 但是需要注意另一个问题，超时时间一定要合理，例如超时时间设置过短，任务还没执行完，锁已经被超时释放了。其他进程会获得锁。 超时时间又不能太长，因为一旦出现释放锁失败，锁又未超时，会导致锁一直无法获取。 ","date":"2022-08-24","objectID":"/posts/database/setnx/:3:0","tags":["redis","分布式锁","锁"],"title":"Redis的分布式锁","uri":"/posts/database/setnx/"},{"categories":["Redis"],"content":"改进方式四 使用getset命令 // 加锁 if (false === $redis-\u003esetnx($key, time() + $timeout)) { $t1 = $redis-\u003eget($key); if ($t1 \u003e time()) { var_dump('锁被其他进程拿到，且未超时'); return; } // 这个命令其实是两步操作：1，返回锁旧的超时时间；2，设置锁新的超时时间 $t2 = $redis-\u003egetSet($key, time() + $timeout);// 临界区 if ($t2 != $t1) { var_dump('锁虽然超时，但是刚被别人获取了'); return; } } // 获得锁 // 执行业务 ... // 释放锁 if (0 === $redis-\u003edel($key)) { var_dump('任务完成，释放锁失败'); } ==存在问题==： 例如 P1 进程释放锁失败，最后锁超时。 P2 和 P3 进程同时进入临界区，P3 进程先执行了getset命令，P2 进程后执行了getset命令，P2 进程此时获得时间是 P3 设置的超时时间，且大于当前时间，所以 P2 进程获得锁失败。 可是有没有发现一个问题，==P3 进程锁超时的时间被 P2 进程给修改了==。不过没有关系。 如果能将上面的getset命令和expire命令合成一个原子命令。那么就能解决设置过期时间失败，释放锁失败造成的死锁问题。 ","date":"2022-08-24","objectID":"/posts/database/setnx/:4:0","tags":["redis","分布式锁","锁"],"title":"Redis的分布式锁","uri":"/posts/database/setnx/"},{"categories":["Redis"],"content":"方式五 // 加锁 if (false === $redis-\u003eset($key, 1, ['nx', 'ex' =\u003e $timeout,])) { var_dump('锁被其他进程拿到，且未超时'); return; } // 获得锁 // 执行业务 ... // 释放锁 if (0 === $redis-\u003edel($key)) { var_dump('任务完成，释放锁失败'); } 这种方式简单，还好用，当然是是这个命令帮我们封装了一些操作。 ==存在问题==： 释放锁这里是一直存在的问题，P1 进程设置的锁如果超时了，P2 进程获得了锁，这时候 P1 进程去释放锁，就会将 P2 进程的锁给释放了，误删了。 那我们能不能在加锁的同时，每个进程放置 1 个 token，释放锁之前检查锁的 token 是不是自己之前设置的，以免释放了别人的锁。 ","date":"2022-08-24","objectID":"/posts/database/setnx/:5:0","tags":["redis","分布式锁","锁"],"title":"Redis的分布式锁","uri":"/posts/database/setnx/"},{"categories":["Redis"],"content":"方式六 避免 del 释放其他进程的锁，del 之前应该先检查锁的密码是否是当前进程设置的。 执行get和del又会出现临界区，可能get的时候密码正确，del的时候，锁已经因为超时其他进程抢占了，造成释放其他进程的锁。 那么如果让get和del能够原子操作就可以了。 Eedis 执行命令是单线程的，毕竟 IO 不是他的瓶颈。而且 Redis 服务器会单线程原子性执行 Lua 脚本，保证 Lua 脚本在处理的过程中不会被任意其它请求打断。 // 锁名词 $key = 'buy_order_lock'; // 锁超时时间 $timeout = 10; $password = 'abc123'; // 加锁 if (false === $redis-\u003eset($key, $password, ['nx', 'ex' =\u003e $timeout,])) { var_dump('锁被其他进程拿到，且未超时'); return; } // 获得锁 // 执行业务 ... // 释放锁 $delScript = \u003c\u003c\u003c'LUA' if ARGV[1] == redis.call(\"get\", KEYS[1]) then return redis.call(\"del\", KEYS[1]) else return -1; end LUA; // 脚本错误返回字符串 $res = $redis-\u003eeval($delScript, [$key, $password], 1); if (false === $res) { var_dump('lua 脚本有问题'); var_dump($redis-\u003egetLastError()); } elseif (-1 === $res) { var_dump('任务完成，释放锁失败，锁超时，被其他进程获得，无需释放'); } elseif (1 !== $res) { var_dump('释放锁失败'); } ","date":"2022-08-24","objectID":"/posts/database/setnx/:6:0","tags":["redis","分布式锁","锁"],"title":"Redis的分布式锁","uri":"/posts/database/setnx/"},{"categories":["Redis"],"content":"推荐方式 方式六 ","date":"2022-08-24","objectID":"/posts/database/setnx/:7:0","tags":["redis","分布式锁","锁"],"title":"Redis的分布式锁","uri":"/posts/database/setnx/"},{"categories":["Redis"],"content":"举一反三 ","date":"2022-08-24","objectID":"/posts/database/setnx/:8:0","tags":["redis","分布式锁","锁"],"title":"Redis的分布式锁","uri":"/posts/database/setnx/"},{"categories":["Redis"],"content":"线程锁 todo ","date":"2022-08-24","objectID":"/posts/database/setnx/:8:1","tags":["redis","分布式锁","锁"],"title":"Redis的分布式锁","uri":"/posts/database/setnx/"},{"categories":["Redis"],"content":"同一操作系统内的进程锁 todo ","date":"2022-08-24","objectID":"/posts/database/setnx/:8:2","tags":["redis","分布式锁","锁"],"title":"Redis的分布式锁","uri":"/posts/database/setnx/"},{"categories":["设计模式"],"content":"Test Driver Learn，测试驱动学习。 ","date":"2022-08-23","objectID":"/posts/designpatterns/tdl/:0:0","tags":["测试驱动学习"],"title":"测试驱动学习","uri":"/posts/designpatterns/tdl/"},{"categories":["设计模式"],"content":"聊聊设计模式 分类 模式 创建型 简单工厂，工厂方法，抽象工厂 建造者，原型 结构型 适配器，装饰者，代理，外观，享元 行为型 策略 ","date":"2022-08-23","objectID":"/posts/designpatterns/qianyan/:0:0","tags":["设计模式","前言"],"title":"前言","uri":"/posts/designpatterns/qianyan/"},{"categories":["设计模式"],"content":"特点 ","date":"2022-08-23","objectID":"/posts/designpatterns/qianyan/:1:0","tags":["设计模式","前言"],"title":"前言","uri":"/posts/designpatterns/qianyan/"},{"categories":["设计模式"],"content":"单例singleton 3私1公2静态： 概念 具体 3私 私有的 singleton 属性 私有的构造方法，防止 new 私钥的 clone 方法，防止对象被克隆 1公 公开的 getInstance() 方法 2静态 静态的 singleton 属性 静态的 getInstance() 方法 方式 线程安全 非线程安全 懒汉式 getInstance() 方法加同步 synchronized getInstance() 方法不加同步 synchronized 饿汉式 加载类文件时，实例化单例 private static Singleton instance = new Singleton(); 不存在非线程安全 静态内部类 private static class SingletonHolder { private static final Singleton INSTANCE = new Singleton(); } ","date":"2022-08-23","objectID":"/posts/designpatterns/qianyan/:1:1","tags":["设计模式","前言"],"title":"前言","uri":"/posts/designpatterns/qianyan/"},{"categories":["设计模式"],"content":"策略模式 算法策略接口，算法策略实现类，策略上下文类。 算法策略实现类实现算法策略接口，策略上线文类，其属性聚合算法策略，并二次实现算法策略。 ","date":"2022-08-23","objectID":"/posts/designpatterns/qianyan/:1:2","tags":["设计模式","前言"],"title":"前言","uri":"/posts/designpatterns/qianyan/"},{"categories":["设计模式"],"content":"观察者模式 2个接口，观察者接口Observer和被观察者接口Subject。被观察者属性聚合观察者。 // 观察者 Observer { /* 方法 */ abstract public update(Subject $subject): void } // 被观察者 Subject { private $observers = array(); /* 方法 */ abstract public attach(Observer $observer): void abstract public detach(Observer $observer): void abstract public notify(): void } 使用方式就是被观察者发生改变时，调用notify方法遍历$observers执行其update方法。 逻辑是一种能力，而套路是方法论、是经验。逻辑是道的东西，而方法论是术的东西。 设计模式就是套路，就是方法论。 ","date":"2022-08-23","objectID":"/posts/designpatterns/qianyan/:1:3","tags":["设计模式","前言"],"title":"前言","uri":"/posts/designpatterns/qianyan/"},{"categories":["设计模式"],"content":"前言 特点就是：一个接口，若干实现类，且每一个类的构造方法参数就是这个接口。他们互相构造，互相叠加。 ","date":"2022-08-23","objectID":"/posts/designpatterns/zhuangshizhe/:1:0","tags":["装饰者","设计模式"],"title":"装饰者模式","uri":"/posts/designpatterns/zhuangshizhe/"},{"categories":["设计模式"],"content":"代码展示 // 各种包 class Bao { private String name; public Bao() { } public Bao(String name) { this.name = name; } public void diejia() { System.out.println(name); } } // 短信包 class Duanxin extends Bao { private Bao bao; public Duanxin(Bao bao) { this.bao = bao; } @Override public void diejia() { System.out.println(\"添加短信包1个\"); this.bao.diejia(); } } // 流量包 class Liuliang extends Bao { private Bao bao; public Liuliang(Bao bao) { this.bao = bao; } @Override public void diejia() { System.out.println(\"添加流量包1个\"); this.bao.diejia(); } } // 语音包 class Yuyin extends Bao { private Bao bao; public Yuyin(Bao bao) { this.bao = bao; } @Override public void diejia() { System.out.println(\"添加语音包1个\"); this.bao.diejia(); } } 应用 // 先添加一个基本套餐：一般包含来电显示，国际漫游啥的 Bao bao = new Bao(\"中国移动神州行套餐\"); Yuyin yuyin1 = new Yuyin(bao); Yuyin yuyin2 = new Yuyin(yuyin1); Duanxin duanxin = new Duanxin(yuyin2); Liuliang liuliang = new Liuliang(duanxin); liuliang.diejia(); 执行结果，通过叠加，我们的一个神州行套餐就出来了，鉴于神州行打电话多，我们定制套餐时可以给2个语音包。这样灵活的定制便于我们定制其他套餐。 添加流量包1个 添加短信包1个 添加语音包1个 添加语音包1个 中国移动神州行套餐 ","date":"2022-08-23","objectID":"/posts/designpatterns/zhuangshizhe/:2:0","tags":["装饰者","设计模式"],"title":"装饰者模式","uri":"/posts/designpatterns/zhuangshizhe/"},{"categories":["设计模式"],"content":"常见应用 Java 中的 IO 流就使用了装饰者模式。 比如我们在设计套餐组合，优惠叠加，都是其出现的场合。 ","date":"2022-08-23","objectID":"/posts/designpatterns/zhuangshizhe/:3:0","tags":["装饰者","设计模式"],"title":"装饰者模式","uri":"/posts/designpatterns/zhuangshizhe/"},{"categories":["设计模式"],"content":"简单工厂 ","date":"2022-08-22","objectID":"/posts/designpatterns/factory/:1:0","tags":["工厂模式","设计模式"],"title":"5种结构型设计模式","uri":"/posts/designpatterns/factory/"},{"categories":["设计模式"],"content":"工厂方法 ","date":"2022-08-22","objectID":"/posts/designpatterns/factory/:2:0","tags":["工厂模式","设计模式"],"title":"5种结构型设计模式","uri":"/posts/designpatterns/factory/"},{"categories":["设计模式"],"content":"抽象工厂 ","date":"2022-08-22","objectID":"/posts/designpatterns/factory/:3:0","tags":["工厂模式","设计模式"],"title":"5种结构型设计模式","uri":"/posts/designpatterns/factory/"},{"categories":["设计模式"],"content":"建造者 ","date":"2022-08-22","objectID":"/posts/designpatterns/factory/:4:0","tags":["工厂模式","设计模式"],"title":"5种结构型设计模式","uri":"/posts/designpatterns/factory/"},{"categories":["设计模式"],"content":"原型 ","date":"2022-08-22","objectID":"/posts/designpatterns/factory/:5:0","tags":["工厂模式","设计模式"],"title":"5种结构型设计模式","uri":"/posts/designpatterns/factory/"},{"categories":["设计模式"],"content":"概念 strategy ","date":"2022-08-22","objectID":"/posts/designpatterns/celue/:1:0","tags":["策略","设计模式"],"title":"策略模式","uri":"/posts/designpatterns/celue/"},{"categories":["设计模式"],"content":"定义 策略模式：指的是定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化。 ==策略模式仅仅封装算法==，提供新的算法插入到已有系统中，策略模式并不决定在何时使用何种算法。在什么情况下使用什么算法是由客户端决定的。 上下文类：印象中，一个策略接口，若干个策略实现类，他们还要与一个上下文类配合使用。其实上下文类就是聚合了策略类，封装方法调用策略的方法。 疑惑：既然调用策略实现类的方法能完成的任务，为何需要整个上下文类来间接调用呢。因为上下文类中，容易扩展其他功能。其次上下文类能帮我们封装一些其他复杂的业务，而调用者只需要跟上下文类打交道即可。 ","date":"2022-08-22","objectID":"/posts/designpatterns/celue/:1:1","tags":["策略","设计模式"],"title":"策略模式","uri":"/posts/designpatterns/celue/"},{"categories":["设计模式"],"content":"光说不练假把式 // 手机开机策略 interface Shouji { public void kaiji(); } // 小米手机开机策略实现类 class Xiaomi implements Shouji { @Override public void kaiji() { System.out.println(\"小米手机开机：美国有苹果，中国有小米\"); } } // 苹果手机开机策略实现类 class Pingguo implements Shouji { @Override public void kaiji() { System.out.println(\"苹果手机开机：apple\"); } } 现在我们买一部手机很简单，只需要去官网买，回来开机就行了。 Xiaomi xiaomi = new Xiaomi(); xiaomi.kaiji(); // 小米手机开机：美国有苹果，中国有小米 Pingguo pingguo = new Pingguo(); pingguo.kaiji(); // 苹果手机开机：apple 开机后我们发现，我们的手机还没有流量卡，还没有贴膜。这就是去官网下单的好处，什么都不送，理由环保。下次为了省心省力，我们决定去手机店买。 // 手机店类就是一个上下文类 class ShoujiDian { private Shouji shouji; public ShoujiDian(Shouji shouji) { this.shouji = shouji; } public void kaiji() { System.out.println(\"手机贴膜完成\"); shouji.kaiji(); System.out.println(\"插入手机卡\"); } } Xiaomi xiaomi = new Xiaomi(); ShoujiDian shoujiDian = new ShoujiDian(xiaomi); shoujiDian.kaiji(); // 手机贴膜完成 // 小米手机开机：美国有苹果，中国有小米 // 插入手机卡 看完这里，应该明白为啥引入上下文类了吧，上下文类能够提供增值服务。 可能有的同学不以为然，任务手机开机策略实现类里也能实现贴膜，插流量卡啊。是的，那我今天跟你掰扯掰扯，下次不要跟我说没说哦，做人嘛，你吃肉，至少让大家有汤喝对吧。什么事你都干了，让别人怎么办？类也一样，单一职责。 ","date":"2022-08-22","objectID":"/posts/designpatterns/celue/:2:0","tags":["策略","设计模式"],"title":"策略模式","uri":"/posts/designpatterns/celue/"},{"categories":["设计模式"],"content":"应用场景 常见的策略应用场景： 对接三方支付，商户配置不同的平台，执行不同支付平台策略 对接三方发票服务商，商户配置不同的发票服务商，执行不同的平台开票策略 计算会员优惠，不同的会员等级，执行不同的优惠计算方式 ","date":"2022-08-22","objectID":"/posts/designpatterns/celue/:3:0","tags":["策略","设计模式"],"title":"策略模式","uri":"/posts/designpatterns/celue/"},{"categories":["工具"],"content":"工具类 ","date":"2022-08-22","objectID":"/posts/framework/javakuangjia/:1:0","tags":["tool"],"title":"常用框架","uri":"/posts/framework/javakuangjia/"},{"categories":["工具"],"content":"lombok 基于注解，帮你实现一些魔术方法。 ","date":"2022-08-22","objectID":"/posts/framework/javakuangjia/:1:1","tags":["tool"],"title":"常用框架","uri":"/posts/framework/javakuangjia/"},{"categories":["设计模式"],"content":" https://www.zhihu.com/question/30831266/answer/1595764766 基础的DDD四层架构： 用户界面层/接口层 👇 应用层 👇 领域层 👇 基础设施层 作者：阿里巴巴大淘宝技术 链接：https://www.zhihu.com/question/30831266/answer/1595764766 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 -- bootstrap -- BeanConfig -- application / 应用层 -- pv -- ChannelPvApplicationService -- sns -- domain / 领域层 -- abtest -- AbtestService -- address -- coupon -- entity -- Coupon -- CouponStatus -- CategoryCouponTemplate -- category -- user -- UserRepository -- service -- OneIdService -- UserService -- item -- ItemRepostory -- live -- LiveStatus -- infrastructure / 基础设施层 -- concurrent -- ThreadPoolExecutorFactory -- MonitorableCallerRunsPolicy -- dal -- IGraphDal -- TuringDal -- DefaultUserRepository -- dao -- MybatisItemDao -- util -- DateUtil -- MoneyUtil -- UriUtil -- monitor -- Event -- Timing -- TimingAspect -- TimingEvent -- Monitors -- view / 接口层、用户界面层 -- atomicwidget -- BannerWidget -- CrazySubsidyWidget -- FeedItemsWidget -- NavigateBarWidget -- LiveWidget -- page -- HomeScreenPage -- CategoryFeedsPage -- SearchCardPage -- widget -- Widget -- DispatchableWidget -- Debuggable -- AbstractWidget -- AbstractDispatchableWidget -- WidgetDispatcher -- WidgetResult -- WidgetContextIncompatibleException 总结： 层 涵盖 接口层 应用层 领域层 domain目录下按领域划分的目录， 基础设施层 事件库/工具util/dao层的模型/线程池 领域对象、值对象、DTO、Service等定义都放在子域的包下，不要有大而全的entity、service、impl等包(这里的子域是一个内聚的逻辑概念，对应的是领域设计里的子域，如上例中的item在我们的导购里就是商品这个子域) 常量定义尽量跟着相关的类走，作为类的静态字段，不要有大而全的Constant类(Switch相关的除外，但也要按职责尽量拆分开关类) 作者：阿里巴巴大淘宝技术 链接：https://www.zhihu.com/question/30831266/answer/1595764766 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 ","date":"2022-08-22","objectID":"/posts/designpatterns/ddd/:0:0","tags":["领域驱动设计","ddd"],"title":"读知乎文章","uri":"/posts/designpatterns/ddd/"},{"categories":["设计模式"],"content":"命名规范 领域对象不带后缀 DTO，RPC 接口提供的对象 VO，跟前端交互的对象 PO，跟数据库直接交互的对象 ","date":"2022-08-22","objectID":"/posts/designpatterns/ddd/:1:0","tags":["领域驱动设计","ddd"],"title":"读知乎文章","uri":"/posts/designpatterns/ddd/"},{"categories":["设计模式"],"content":"注释 注释要说明为什么这么做，而不是在做什么。毕竟看了你代码还不知道你在做什么的话，那你代码写的太烂了。 ","date":"2022-08-22","objectID":"/posts/designpatterns/ddd/:2:0","tags":["领域驱动设计","ddd"],"title":"读知乎文章","uri":"/posts/designpatterns/ddd/"},{"categories":["设计模式"],"content":"面向对象编码 遵循原则：SRP/OCP/LSP/ISP/DIP 尽量只暴露行为，不暴露数据 慎用继承，优先使用组合方式 ","date":"2022-08-22","objectID":"/posts/designpatterns/ddd/:3:0","tags":["领域驱动设计","ddd"],"title":"读知乎文章","uri":"/posts/designpatterns/ddd/"},{"categories":["设计模式"],"content":"日志 后台一定要有操作日志，数据变更日志 日志要配置异步写盘 ","date":"2022-08-22","objectID":"/posts/designpatterns/ddd/:4:0","tags":["领域驱动设计","ddd"],"title":"读知乎文章","uri":"/posts/designpatterns/ddd/"},{"categories":["设计模式"],"content":"数据结构使用 数组的使用，无随机读取需求时，使用LinkedList代替ArrayList ","date":"2022-08-22","objectID":"/posts/designpatterns/ddd/:5:0","tags":["领域驱动设计","ddd"],"title":"读知乎文章","uri":"/posts/designpatterns/ddd/"},{"categories":["设计模式"],"content":"编码 功能性代码与非功能性代码要分离 时刻警惕 NPE，多用 Optional 处理 ","date":"2022-08-22","objectID":"/posts/designpatterns/ddd/:6:0","tags":["领域驱动设计","ddd"],"title":"读知乎文章","uri":"/posts/designpatterns/ddd/"},{"categories":["设计模式"],"content":"分层 ","date":"2022-08-22","objectID":"/posts/designpatterns/ddd/:7:0","tags":["领域驱动设计","ddd"],"title":"读知乎文章","uri":"/posts/designpatterns/ddd/"},{"categories":["设计模式"],"content":"COLA 基于 DDD 的业务代码架构的最佳实践。 ","date":"2022-08-22","objectID":"/posts/designpatterns/ddd/:8:0","tags":["领域驱动设计","ddd"],"title":"读知乎文章","uri":"/posts/designpatterns/ddd/"},{"categories":["设计模式"],"content":"父类设计一个算法需要哪几步，子类则实现这些步骤。 ","date":"2022-08-22","objectID":"/posts/designpatterns/moban/:0:0","tags":["模板模式","设计模式"],"title":"模板模式","uri":"/posts/designpatterns/moban/"},{"categories":["设计模式"],"content":"大咖秀 ","date":"2022-08-22","objectID":"/posts/designpatterns/moban/:1:0","tags":["模板模式","设计模式"],"title":"模板模式","uri":"/posts/designpatterns/moban/"},{"categories":["设计模式"],"content":"javax.servlet.http.HttpServlet 抽象类 javax.servlet.http.HttpServlet 在其方法service()定义了处理 get 请求，post 请求。而我们只需要继承 HttpServlet ，并重写 doGet和doPost方法即可。 由于我们使用的请求方式主要是 GET 和 POST，所以通过继承 HttpServlet 类创建 Servlet 时，只需要重写 doGet 或者 doPost 方法 ","date":"2022-08-22","objectID":"/posts/designpatterns/moban/:1:1","tags":["模板模式","设计模式"],"title":"模板模式","uri":"/posts/designpatterns/moban/"},{"categories":["ESP32"],"content":"学习一门编程语言，第一个教程是输出hello world。而学习单片机，第一个教程通常是点灯。 ","date":"2022-08-21","objectID":"/posts/esp32/20220821blinker/:0:0","tags":["esp32","esp8266","点灯"],"title":"ESP32入门之点灯","uri":"/posts/esp32/20220821blinker/"},{"categories":["ESP32"],"content":"利用延时函数闪灯 void setup() { // 开启串口，并配置波特率 Serial.begin(115200); // 配置灯的管脚模式 pinMode(BUILTIN_LED, OUTPUT); // 高电平灯灭 digitalWrite(BUILTIN_LED, HIGH); } void loop() { delay(1000); digitalWrite(BUILTIN_LED, LOW); delay(1000); digitalWrite(BUILTIN_LED, LOW); // 任务 Serial.println(\"hello world\"); } 使用延时函数闪灯，最大的缺点是，后面的任务被阻塞了。就是说灯在延时的过程时，任务不会执行。而任务执行的时候，灯就不会闪烁，灯被任务阻塞了。 而我们希望任务一直执行，一旦闪灯的时间到了，立即闪灯。哈哈，那不就是外部中断吗？给个定时器中断不就好了吗？ ","date":"2022-08-21","objectID":"/posts/esp32/20220821blinker/:1:0","tags":["esp32","esp8266","点灯"],"title":"ESP32入门之点灯","uri":"/posts/esp32/20220821blinker/"},{"categories":["ESP32"],"content":"定时器闪灯 // 引入 esp32 定时器中断库 #include \u003cTicker.h\u003e // 定义闪灯定时器 Ticker shanTicker; void shanshuo() { uint8_t status = digitalRead(BUILTIN_LED); digitalWrite(BUILTIN_LED, !status); } void setup() { Serial.begin(115200); // 配置灯的管脚模式 pinMode(BUILTIN_LED, OUTPUT); // 高电平灯灭 digitalWrite(BUILTIN_LED, HIGH); // 开启定时器，到了 1 秒就触发外部中断，执行回调函数 shanshuo shanTicker.attach(1, shanshuo); } void loop() { // 任务 Serial.println(\"hello world\"); } 这样任务和闪灯，就能交替执行了。记住定时器中断的优先级比任务高。 esp32 是多核的，那我们能不能利用==多核==，让闪灯和任务同时执行。 ","date":"2022-08-21","objectID":"/posts/esp32/20220821blinker/:2:0","tags":["esp32","esp8266","点灯"],"title":"ESP32入门之点灯","uri":"/posts/esp32/20220821blinker/"},{"categories":["HTTP"],"content":"HTTP Headers 我们经常能看到 header 头里的 X-什么什么的头，例如X-PowerBy-PHP，目前这种格式不被推崇。 自定专用消息头可通过’X-’ 前缀来添加；但是这种用法被 IETF 在 2012 年 6 月发布的 RFC6648 中明确弃用，原因是其会在非标准字段成为标准时造成不便；其他的消息头在 IANA 注册表 中列出，其原始内容在 RFC 4229 中定义。 此外，IANA 还维护着被提议的新 HTTP 消息头注册表。 以上引用来源：https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers ","date":"2022-08-20","objectID":"/posts/http/httpxieyi/:1:0","tags":["http","协议"],"title":"HTTP协议笔记","uri":"/posts/http/httpxieyi/"},{"categories":["HTTP"],"content":"请求方法 ","date":"2022-08-20","objectID":"/posts/http/httpxieyi/:2:0","tags":["http","协议"],"title":"HTTP协议笔记","uri":"/posts/http/httpxieyi/"},{"categories":["HTTP"],"content":"HEAD HTTP HEAD 方法 请求资源的头部信息，并且这些头部与 HTTP GET 方法请求时返回的一致。该请求方法的一个使用场景是在下载一个大文件前先获取其大小再决定是否要下载，以此可以节约带宽资源。 语法： HEAD /index.html ","date":"2022-08-20","objectID":"/posts/http/httpxieyi/:2:1","tags":["http","协议"],"title":"HTTP协议笔记","uri":"/posts/http/httpxieyi/"},{"categories":["HTTP"],"content":"OPTIONS HTTP 的 OPTIONS 方法 用于获取目的资源所支持的通信选项。客户端可以对特定的 URL 使用 OPTIONS 方法，也可以对整站（通过将 URL 设置为“*”）使用该方法。 // 请求头 OPTIONS /index.html HTTP/1.1 OPTIONS * HTTP/1.1 // 响应头 HTTP/1.1 200 OK Allow: OPTIONS, GET, HEAD, POST ","date":"2022-08-20","objectID":"/posts/http/httpxieyi/:2:2","tags":["http","协议"],"title":"HTTP协议笔记","uri":"/posts/http/httpxieyi/"},{"categories":["HTTP"],"content":"Content-Type ","date":"2022-08-20","objectID":"/posts/http/httpxieyi/:3:0","tags":["http","协议"],"title":"HTTP协议笔记","uri":"/posts/http/httpxieyi/"},{"categories":["HTTP"],"content":"疑惑 关于消息类型中的编码类型，之前见到的都是application/json; charset=utf-8今天发现微信的网页调试工具，响应的是application/json; encoding=utf-8。 不知道encoding和charset两者区别是什么，还是HTTP协议都兼容。 ","date":"2022-08-20","objectID":"/posts/http/httpxieyi/:3:1","tags":["http","协议"],"title":"HTTP协议笔记","uri":"/posts/http/httpxieyi/"},{"categories":["HTTP"],"content":"响应状态码 status（状态码） reason（原因） 405 Method Not Allowed 就是说服务器不理解，不支持你这种请求方法 500 Internal Server Error 服务器业务代码出错 502 Bad Gateway 表示作为网关或代理的服务器，从上游服务器中接收到的响应是无效的 503 Service Unavailable 请求过多，服务器过载，服务不过来 504 Gateway Timeout 表示扮演网关或者代理的服务器无法在规定的时间内获得想要的响应。 比如 Nginx 将请求转发给 PHP ，但是 PHP 未能在规定时间内进行响应。 ","date":"2022-08-20","objectID":"/posts/http/httpxieyi/:4:0","tags":["http","协议"],"title":"HTTP协议笔记","uri":"/posts/http/httpxieyi/"},{"categories":["HTTP"],"content":"常见问题 ","date":"2022-08-20","objectID":"/posts/http/httpxieyi/:5:0","tags":["http","协议"],"title":"HTTP协议笔记","uri":"/posts/http/httpxieyi/"},{"categories":["HTTP"],"content":"跨域问题 Access-Control-Allow-Origin: * Access-Control-Allow-Origin: \u003corigin\u003e 例如，你允许任何网站跨域访问你的资源，那么可以在响应 header 头中添加Access-Control-Allow-Origin: *来解决。 如果只允许https://www.qq.com跨域访问，那么 header 头里添加Access-Control-Allow-Origin: https://www.qq.com即可。 ","date":"2022-08-20","objectID":"/posts/http/httpxieyi/:5:1","tags":["http","协议"],"title":"HTTP协议笔记","uri":"/posts/http/httpxieyi/"},{"categories":["数据库"],"content":"常用函数 ","date":"2022-08-20","objectID":"/posts/database/mysqlfuxibiji/:1:0","tags":["MySQL","索引"],"title":"MySQL复习笔记","uri":"/posts/database/mysqlfuxibiji/"},{"categories":["数据库"],"content":"日期时间 时间戳转格式化日期 # 输出 1970-01-01 08:00:01 SELECT FROM_UNIXTIME(1) AS t 日期转时间戳 # 输出 0 SELECT UNIX_TIMESTAMP('1970-01-01 08:00:00') AS t ","date":"2022-08-20","objectID":"/posts/database/mysqlfuxibiji/:1:1","tags":["MySQL","索引"],"title":"MySQL复习笔记","uri":"/posts/database/mysqlfuxibiji/"},{"categories":["数据库"],"content":"ACID ","date":"2022-08-20","objectID":"/posts/database/mysqlfuxibiji/:2:0","tags":["MySQL","索引"],"title":"MySQL复习笔记","uri":"/posts/database/mysqlfuxibiji/"},{"categories":["数据库"],"content":"事务的隔离级别 默认隔离级别：可重复读 级别 存在的问题 可解决的问题 ","date":"2022-08-20","objectID":"/posts/database/mysqlfuxibiji/:3:0","tags":["MySQL","索引"],"title":"MySQL复习笔记","uri":"/posts/database/mysqlfuxibiji/"},{"categories":["数据库"],"content":"锁 操作 锁行/锁表 是否为排他锁 新增 删除 修改 where 条件有索引锁行，否则锁表 修改自带排他锁 阻塞其他事务的修改和排他锁查询查询 ==不阻塞其他事务的不加锁查询== 查询 取决 where 条件，有索引锁行，否则锁表 需要手动加锁 阻塞其他事务的修改和排他锁查询 ==不阻塞其他事务的不加锁查询== 排他锁：低并发场景性能低，适合高并发场景。 乐观锁：CAS，比较并替换。高并发的情况下，乐观锁性能低，使用于低并发场景。 自旋：获得不到锁，不断尝试获取锁的过程称之为自旋。 ","date":"2022-08-20","objectID":"/posts/database/mysqlfuxibiji/:4:0","tags":["MySQL","索引"],"title":"MySQL复习笔记","uri":"/posts/database/mysqlfuxibiji/"},{"categories":["数据库"],"content":"死锁如何解决 死锁不能解决，只能避免。 所有事务都按照相同的加锁顺序，业务约定顺序容易遗忘，最好按照表名字典序上锁 给锁设置超时时间，死锁时超时自动释放 ","date":"2022-08-20","objectID":"/posts/database/mysqlfuxibiji/:4:1","tags":["MySQL","索引"],"title":"MySQL复习笔记","uri":"/posts/database/mysqlfuxibiji/"},{"categories":["数据库"],"content":"配置事务隔离级别 todo READ UNCOMMITTED READ COMMITTED REPEATABLE READ SERIALIZABLE 事务1加排他锁查询，where条件无索引。 事务2更新操作，where条件无索引，均阻塞。 事务2更新操作，where条件有索引，非同一行数据，不阻塞。 事务2更新操作，where条件有索引，且事务1操作同一行数据，阻塞。 事务1加排他锁查询，where条件无索引。 事务2排他锁查询操作，where条件无索引，均阻塞。 事务2排他锁查询操作，where条件有索引，非同一行数据，不阻塞。 事务2排他锁查询操作，where条件有索引，其与事务1操作同一行数据，阻塞。 ","date":"2022-08-20","objectID":"/posts/database/mysqlfuxibiji/:4:2","tags":["MySQL","索引"],"title":"MySQL复习笔记","uri":"/posts/database/mysqlfuxibiji/"},{"categories":["数据库"],"content":"查询优化 ","date":"2022-08-20","objectID":"/posts/database/mysqlfuxibiji/:5:0","tags":["MySQL","索引"],"title":"MySQL复习笔记","uri":"/posts/database/mysqlfuxibiji/"},{"categories":["数据库"],"content":"select * 的缺点 不能有效利用索引覆盖，索引覆盖就是你查询的字段都有索引，你一张表不可能所有字段都建索引 让查询变慢，查询的数据量越大，IO 就越慢，网络传输也越慢 ","date":"2022-08-20","objectID":"/posts/database/mysqlfuxibiji/:5:1","tags":["MySQL","索引"],"title":"MySQL复习笔记","uri":"/posts/database/mysqlfuxibiji/"},{"categories":["数据库"],"content":"使用 char 还是 varchar char 是定长，varchar 是变长。定长的好处是固定长度，很容易计算下一个数据。如果数据的长度是固定的，那就选 char。 应用： md5 值是固定 32 位，肯定选 char 姓名虽然看似不定长，有人 2 个字，有人 3 个字，更有甚者 6 个字，为了提高查找效率，我们完全可以大方点给他char(32)，如果你名字真超过 32 个长度，你赢了 手机号用 char，大陆手机号 11 位，还不固定吗，计算是座机，空出几个字符又如何，空间换时间不丢人 手机号不要用 int，因为 char 支持模糊查询，更适合他的业务 ","date":"2022-08-20","objectID":"/posts/database/mysqlfuxibiji/:5:2","tags":["MySQL","索引"],"title":"MySQL复习笔记","uri":"/posts/database/mysqlfuxibiji/"},{"categories":["数据库"],"content":"不使用视图，触发器，存储过程，事件 Event 缺点： 可移植性不好，底层换数据库类型，这些东西都要重写 并发大的时候，效率低。数据库只适合干存储和索引，计算的事情交给业务层代码来完成。 ","date":"2022-08-20","objectID":"/posts/database/mysqlfuxibiji/:5:3","tags":["MySQL","索引"],"title":"MySQL复习笔记","uri":"/posts/database/mysqlfuxibiji/"},{"categories":["数据库"],"content":"const 主键查询 使用 like 查询主键就变成了 all。 唯一性索引 unique key，如果使用 like 查询就是 range，使用 = 查询就是 const，可见性能差距还是挺大的。 ","date":"2022-08-20","objectID":"/posts/database/mysqlfuxibiji/:5:4","tags":["MySQL","索引"],"title":"MySQL复习笔记","uri":"/posts/database/mysqlfuxibiji/"},{"categories":["数据库"],"content":"ref 使用了普通索引，或者唯一性索引的左前缀。 ","date":"2022-08-20","objectID":"/posts/database/mysqlfuxibiji/:5:5","tags":["MySQL","索引"],"title":"MySQL复习笔记","uri":"/posts/database/mysqlfuxibiji/"},{"categories":["数据库"],"content":"range 常见于\u003e，\u003c，=，in，like，和between的查询，且使用了索引。 ","date":"2022-08-20","objectID":"/posts/database/mysqlfuxibiji/:5:6","tags":["MySQL","索引"],"title":"MySQL复习笔记","uri":"/posts/database/mysqlfuxibiji/"},{"categories":["数据库"],"content":"insert优化 ","date":"2022-08-20","objectID":"/posts/database/mysqlfuxibiji/:6:0","tags":["MySQL","索引"],"title":"MySQL复习笔记","uri":"/posts/database/mysqlfuxibiji/"},{"categories":["数据库"],"content":"解决添加重复数据的问题 insert ignore into 添加 ignore 关键字，如果添加的记录存在主键索引或唯一性索引重复时，返回 0。 replace into 使用replace into替代insert into，此操作即先添加新记录，如果发现存在重复主键索引或唯一性索引时，==先删除旧记录==，==再插入新记录==。 on duplicate key update … 在 insert into 语句后添加，不重复则插入，存在重复，则执行后面的更新语句。 ","date":"2022-08-20","objectID":"/posts/database/mysqlfuxibiji/:6:1","tags":["MySQL","索引"],"title":"MySQL复习笔记","uri":"/posts/database/mysqlfuxibiji/"},{"categories":["数据库"],"content":"索引优化 ","date":"2022-08-20","objectID":"/posts/database/mysqlfuxibiji/:7:0","tags":["MySQL","索引"],"title":"MySQL复习笔记","uri":"/posts/database/mysqlfuxibiji/"},{"categories":["数据库"],"content":"区分度小的字段不适合建索引 比如性别，状态 ","date":"2022-08-20","objectID":"/posts/database/mysqlfuxibiji/:7:1","tags":["MySQL","索引"],"title":"MySQL复习笔记","uri":"/posts/database/mysqlfuxibiji/"},{"categories":["数据库"],"content":"长字符串，部分索引或倒序索引 ","date":"2022-08-20","objectID":"/posts/database/mysqlfuxibiji/:7:2","tags":["MySQL","索引"],"title":"MySQL复习笔记","uri":"/posts/database/mysqlfuxibiji/"},{"categories":["数据库"],"content":"分组必排序，排序就要用索引，否则文件排序 ","date":"2022-08-20","objectID":"/posts/database/mysqlfuxibiji/:7:3","tags":["MySQL","索引"],"title":"MySQL复习笔记","uri":"/posts/database/mysqlfuxibiji/"},{"categories":["数据库"],"content":"联合索引，区分度高的字段放前面 这样能提供性能 ","date":"2022-08-20","objectID":"/posts/database/mysqlfuxibiji/:7:4","tags":["MySQL","索引"],"title":"MySQL复习笔记","uri":"/posts/database/mysqlfuxibiji/"},{"categories":["数据库"],"content":"性能优化 高并发大数据的互联网业务，架构设计思路是“解放数据库 CPU，将计算转移到服务层”，并发量大的情况下，这些功能很可能将数据库拖死，业务逻辑放到服务层具备更好的扩展性，能够轻易实现“增机器就加性能”。数据库擅长存储与索引，CPU 计算还是上移吧。 ","date":"2022-08-20","objectID":"/posts/database/mysqlfuxibiji/:8:0","tags":["MySQL","索引"],"title":"MySQL复习笔记","uri":"/posts/database/mysqlfuxibiji/"},{"categories":["数据库"],"content":"数据库连接池 ","date":"2022-08-20","objectID":"/posts/database/mysqlfuxibiji/:9:0","tags":["MySQL","索引"],"title":"MySQL复习笔记","uri":"/posts/database/mysqlfuxibiji/"},{"categories":["数据库"],"content":"binlog日志格式 binlog 日志有三种格式，分别为 STATMENT 、 ROW 和 MIXED。 在 MySQL 5.7.7 之前，默认的格式是 STATEMENT，MySQL 5.7.7 之后，默认值是 ROW。 日志格式通过 binlog-format 指定： STATMENT：基于 SQL 语句的复制，每一条会修改数据的sql语句会记录到 binlog 中 ROW：基于行的复制 MIXED：基于 STATMENT 和 ROW 两种模式的混合复制，比如一般的数据操作使用 row 格式保存，有些表结构的变更语句，使用 statement 来记录 ","date":"2022-08-20","objectID":"/posts/database/mysqlfuxibiji/:10:0","tags":["MySQL","索引"],"title":"MySQL复习笔记","uri":"/posts/database/mysqlfuxibiji/"},{"categories":["数据库"],"content":"主从复制延时 三个线程： ","date":"2022-08-20","objectID":"/posts/database/mysqlfuxibiji/:11:0","tags":["MySQL","索引"],"title":"MySQL复习笔记","uri":"/posts/database/mysqlfuxibiji/"},{"categories":["数据库"],"content":"延时原理 主库 A 执行完成一个事务，写入 binlog，该时刻记为 T1。 传给从库 B，从库接受完这个 binlog 的时刻记为 T2。 从库 B 执行完这个事务，该时刻记为 T3。 那么所谓主从延迟，就是同一个事务，从库执行完成的时间和主库执行完成的时间之间的差值，即 T3-T1。 我们也可以通过在从库执行show slave status，返回结果会显示seconds_behind_master，表示当前从库延迟了多少秒。 seconds_behind_master 如何计算： 每一个事务的 binlog 都有一个时间字段，用于记录主库上写入的时间。 从库取出当前正在执行的事务的时间字段，跟当前系统的时间进行相减，得到的就是 seconds_behind_master，也就是前面所描述的 T3-T1。 ","date":"2022-08-20","objectID":"/posts/database/mysqlfuxibiji/:11:1","tags":["MySQL","索引"],"title":"MySQL复习笔记","uri":"/posts/database/mysqlfuxibiji/"},{"categories":["数据库"],"content":"原因 主库并发性地写，导致 T2-T1 时间变长 从库配置低，读取压力过大，导致 T3-T2 时间变长，所以主从机器最好相同配置 某个从库网络阻塞，波动。导致 T2-T1 变长 大事务的执行，因为只要事务提交了，主库才写 binlog ","date":"2022-08-20","objectID":"/posts/database/mysqlfuxibiji/:11:2","tags":["MySQL","索引"],"title":"MySQL复习笔记","uri":"/posts/database/mysqlfuxibiji/"},{"categories":["数据库"],"content":"影响 ","date":"2022-08-20","objectID":"/posts/database/mysqlfuxibiji/:11:3","tags":["MySQL","索引"],"title":"MySQL复习笔记","uri":"/posts/database/mysqlfuxibiji/"},{"categories":["数据库"],"content":"解决手段 对实时性要求高的业务，查主库，避免查从库 本质性解决，缺点，丧失了主从架构的优越性。 接口层缓存业务单号 缓存业务单号+有效时间段，对提交的业务单号做重复提交校验。如果担心后期缓存的业务单号过多，可以给缓存的单号添加一个失效时间，失效时间大于主从复制的延时时长即可。 前端做防重复提交处理 简单，效果好，不影响服务器性能。缺点防君子不防小人。 ","date":"2022-08-20","objectID":"/posts/database/mysqlfuxibiji/:11:4","tags":["MySQL","索引"],"title":"MySQL复习笔记","uri":"/posts/database/mysqlfuxibiji/"},{"categories":["数据库"],"content":"系统命令 ","date":"2022-08-20","objectID":"/posts/database/mysqlfuxibiji/:12:0","tags":["MySQL","索引"],"title":"MySQL复习笔记","uri":"/posts/database/mysqlfuxibiji/"},{"categories":["数据库"],"content":"查看被锁的表 SHOW OPEN TABLES WHERE in_use \u003e 0; ","date":"2022-08-20","objectID":"/posts/database/mysqlfuxibiji/:12:1","tags":["MySQL","索引"],"title":"MySQL复习笔记","uri":"/posts/database/mysqlfuxibiji/"},{"categories":["数据库"],"content":"查看被锁的事务 SELECT * FROM information_schema.INNODB_LOCKS; ","date":"2022-08-20","objectID":"/posts/database/mysqlfuxibiji/:12:2","tags":["MySQL","索引"],"title":"MySQL复习笔记","uri":"/posts/database/mysqlfuxibiji/"},{"categories":["数据库"],"content":"查看等待锁的事务 SELECT * FROM information_schema.INNODB_LOCK_WAITS; ","date":"2022-08-20","objectID":"/posts/database/mysqlfuxibiji/:12:3","tags":["MySQL","索引"],"title":"MySQL复习笔记","uri":"/posts/database/mysqlfuxibiji/"},{"categories":["数据库"],"content":"精读报错 ","date":"2022-08-20","objectID":"/posts/database/mysqlfuxibiji/:13:0","tags":["MySQL","索引"],"title":"MySQL复习笔记","uri":"/posts/database/mysqlfuxibiji/"},{"categories":["数据库"],"content":"字符集不同的字段比较出错 连表时遇到 2 个字符集不同的字段的比较，出错。 Illegal mix of collations (utf8_general_ci,IMPLICIT) and (utf8_unicode_ci,IMPLICIT) for operation '=' 解决办法，在连表 ON 条件的字段后，加上同一字符集标识，例如 COLLATE utf8_unicode_ci。 ","date":"2022-08-20","objectID":"/posts/database/mysqlfuxibiji/:13:1","tags":["MySQL","索引"],"title":"MySQL复习笔记","uri":"/posts/database/mysqlfuxibiji/"},{"categories":["PHP"],"content":"PHP7.4 ","date":"2022-08-20","objectID":"/posts/php/php7%E6%96%B0%E7%89%B9%E6%80%A7/:1:0","tags":["PHP7.4"],"title":"PHP7新版本新特性","uri":"/posts/php/php7%E6%96%B0%E7%89%B9%E6%80%A7/"},{"categories":["PHP"],"content":"null合并运算符与三目运算符的区别 看代码： $remark = ''; // A ?: B，empty(A) 是真，则返回 A，否则返回 B self::assertSame('maria', $remark ?: 'maria'); // A ?? B，A 非 null 则返回 A，否则返回 B self::assertSame('', $remark ?? 'maria'); 其实 null 合并运算符的出现就是为了解决三目运算符的。 isset与is_null的区别 互为相反 $name1 = 'tony'; unset($name1); // $name1 值为 null self::assertFalse(isset($name1)); self::assertTrue(is_null($name1)); // $name2 未设置，不存在 self::assertFalse(isset($name2)); self::assertTrue(is_null($name2)); $name1 = 'maria'; self::assertSame(is_null($name1) ? '' : $name1, isset($name1) ? $name1 : ''); self::assertSame(is_null($name1) ? '' : $name1, $name1 ?? ''); self::assertSame(isset($name1) ? $name1 : '', $name1 ?? ''); isset能够同时检查多个变量 这些变量之前为且的关系，即全部为真则返回真。 ","date":"2022-08-20","objectID":"/posts/php/php7%E6%96%B0%E7%89%B9%E6%80%A7/:1:1","tags":["PHP7.4"],"title":"PHP7新版本新特性","uri":"/posts/php/php7%E6%96%B0%E7%89%B9%E6%80%A7/"},{"categories":["系统"],"content":"Session和Cookie cookie/session 是我们最初接触的认证。 他的步骤如下： 用户用浏览器提交用户名和密码给服务器 服务器鉴定此用户为合法用户，和身份后，在服务器建立一个文件，这个文件就是 session，文件名叫做会话 id，文件内容存放用户身份信息。然后给这个文件名返回给浏览器。 用户让浏览器带着服务器给返回的 session 文件名，服务器按文件名查找，确实存在此文件，并获取文件内容，并与用户交互。 ","date":"2022-08-20","objectID":"/posts/2022/fangwenrenzhen/:1:0","tags":["安全认证","单点登录","SSO"],"title":"身份认证","uri":"/posts/2022/fangwenrenzhen/"},{"categories":["系统"],"content":"access_token认证 微信的接口认证方式，正是此。 ","date":"2022-08-20","objectID":"/posts/2022/fangwenrenzhen/:2:0","tags":["安全认证","单点登录","SSO"],"title":"身份认证","uri":"/posts/2022/fangwenrenzhen/"},{"categories":["系统"],"content":"jwt认证 ","date":"2022-08-20","objectID":"/posts/2022/fangwenrenzhen/:3:0","tags":["安全认证","单点登录","SSO"],"title":"身份认证","uri":"/posts/2022/fangwenrenzhen/"},{"categories":["系统"],"content":"SSO单点登录 ","date":"2022-08-20","objectID":"/posts/2022/fangwenrenzhen/:4:0","tags":["安全认证","单点登录","SSO"],"title":"身份认证","uri":"/posts/2022/fangwenrenzhen/"},{"categories":["系统"],"content":"迷惑的地方 浏览器端禁用了 cookie 还能使用吗？ 答：能，禁用了 header 头传递 cookie，还可以曲线救国，用地址栏传递 cookie。 ","date":"2022-08-20","objectID":"/posts/2022/fangwenrenzhen/:4:1","tags":["安全认证","单点登录","SSO"],"title":"身份认证","uri":"/posts/2022/fangwenrenzhen/"},{"categories":["工具"],"content":"编码格式约定 位置 调整 Code Generation Wrapping and Braces/Array initializer 不要勾选Align key-value pairs，即数组元素对齐。 其他保持默认即可。 ","date":"2022-08-19","objectID":"/posts/tools/phpstorm/:1:0","tags":["PHPStorm","编辑器"],"title":"PHPStorm","uri":"/posts/tools/phpstorm/"},{"categories":["工具"],"content":"常用插件整理 Composer Dump-Autoload IDE Eval Reset PHP Annotations Swagger Git，可以使用代码版本控制 Terminal，使得可以在 PHPStorm 中使用 命令行工具 ","date":"2022-08-19","objectID":"/posts/tools/phpstorm/:2:0","tags":["PHPStorm","编辑器"],"title":"PHPStorm","uri":"/posts/tools/phpstorm/"},{"categories":["工具"],"content":"代码规范检查工具 PHP CodeSniffer 打开配置 File \u003e Settings \u003e Language \u0026 Frameworks \u003e PHP \u003e Quality Tools 点开配置 配置 Composer 安装的扩展 composer.phar global require \"squizlabs/php_codesniffer=*\" 安装完对应的脚本路径为： C:\\Users\\Shali\\AppData\\Roaming\\Composer\\vendor\\bin 配置工具的路径： ","date":"2022-08-19","objectID":"/posts/tools/phpstorm/:2:1","tags":["PHPStorm","编辑器"],"title":"PHPStorm","uri":"/posts/tools/phpstorm/"},{"categories":["工具"],"content":"配置测试框架 ","date":"2022-08-19","objectID":"/posts/tools/phpstorm/:2:2","tags":["PHPStorm","编辑器"],"title":"PHPStorm","uri":"/posts/tools/phpstorm/"},{"categories":["工具"],"content":"常用快捷键 ","date":"2022-08-19","objectID":"/posts/tools/phpstorm/:3:0","tags":["PHPStorm","编辑器"],"title":"PHPStorm","uri":"/posts/tools/phpstorm/"},{"categories":["工具"],"content":"光标控制 快捷键 描述 Ctrl+Enter 往上新增一行 Shift+Enter 往下新增一行 Shift+Delete 删除当前行 Ctrl+D 复制当前行 Ctrl+Backspace 删除一个单词 Alt+Insert 自动生成set/get/test方法 Ctrl+B 追踪变量定义 ","date":"2022-08-19","objectID":"/posts/tools/phpstorm/:3:1","tags":["PHPStorm","编辑器"],"title":"PHPStorm","uri":"/posts/tools/phpstorm/"},{"categories":["工具"],"content":"格式化 快捷键 描述 Ctrl+Alt+L 自动格式化整个文件，也可选中部分代码，仅部分格式化 Ctrl+Alt+O 优化导入，使用的类自动导包，未使用的包自动移除 ","date":"2022-08-19","objectID":"/posts/tools/phpstorm/:3:2","tags":["PHPStorm","编辑器"],"title":"PHPStorm","uri":"/posts/tools/phpstorm/"},{"categories":["工具"],"content":"附加功能 快捷键 描述 F11 添加代码书签 添加喜爱Favorites标签页Tab，右键 Add to Favorites Ctrl+Shift+A/双击Shift 快速搜索功能 ","date":"2022-08-19","objectID":"/posts/tools/phpstorm/:3:3","tags":["PHPStorm","编辑器"],"title":"PHPStorm","uri":"/posts/tools/phpstorm/"},{"categories":["工具"],"content":"自定义快捷键习惯 原快捷键 自定义快捷键 搜索关键词 功能描述 Ctrl+S Alt+S Save All 保存所有文件 Alt+X Edit\u003eMacros\u003eStart Macro Recording 运行单元测试方法 Ctrl+Alt+V Alt+A Introduce Variable 自动生成变量 ","date":"2022-08-19","objectID":"/posts/tools/phpstorm/:4:0","tags":["PHPStorm","编辑器"],"title":"PHPStorm","uri":"/posts/tools/phpstorm/"},{"categories":["工具"],"content":"版本跟踪 ","date":"2022-08-19","objectID":"/posts/tools/phpstorm/:5:0","tags":["PHPStorm","编辑器"],"title":"PHPStorm","uri":"/posts/tools/phpstorm/"},{"categories":["工具"],"content":"SVN 开启当前当前项目的 SVN。 File -\u003e Settings -\u003e Version Control -\u003e 点击右侧弹出窗口的 + 添加工程映射。 ","date":"2022-08-19","objectID":"/posts/tools/phpstorm/:5:1","tags":["PHPStorm","编辑器"],"title":"PHPStorm","uri":"/posts/tools/phpstorm/"},{"categories":["编辑器","工具"],"content":"常用命令 ","date":"2022-08-19","objectID":"/posts/tools/ruishijundaosublime/:1:0","tags":["sublime","Sublime Text","去重"],"title":"Sublime Text 3","uri":"/posts/tools/ruishijundaosublime/"},{"categories":["编辑器","工具"],"content":"去除重复行 Edit \u003e Premute Lines \u003e Unique 其实还有其他 2 个操作： Reverse：倒序行 Shuffle：打乱行 添加快捷键 添加快捷键，执行先排序，后移除重复行。 录制宏，或者自建宏文件 新建文件C:\\Users\\Shali\\AppData\\Roaming\\Sublime Text 3\\Packages\\User\\先排序再去除重复行.sublime-macro 填充如下内容，json 格式： [ { \"args\": { \"case_sensitive\": false }, \"command\": \"sort_lines\" }, { \"args\": { \"operation\": \"unique\" }, \"command\": \"permute_lines\" } ] case_sensitive：标识排序时是否区分大小写，按照 ASCII 码，大写字母排前面。 绑定快捷键 添加如下快捷键配置项： { \"keys\": [\"ctrl+alt+l\"], \"command\": \"run_macro_file\", \"args\": {\"file\": \"Packages/User/先排序再去除重复行.sublime-macro\"} }, ","date":"2022-08-19","objectID":"/posts/tools/ruishijundaosublime/:1:1","tags":["sublime","Sublime Text","去重"],"title":"Sublime Text 3","uri":"/posts/tools/ruishijundaosublime/"},{"categories":["ThinkPHP"],"content":"没看到关闭 MySQL 连接 在使用 TP3.2 的过程中，一直看到使用 M 方法，查询数据，那 M 方法肯定帮我们连接上了 MySQL，但是没看到他关闭啊。既然没有连接池，那数据库连接用完应该关闭不是，不然 MySQL 会报很多 Warning。 我想这些客户端异常关闭肯定不是框架造成的，成熟的框架肯定会自动关闭，关闭连接可能放在析构方法__destruct()中了。 果不其然，在\\Think\\Db\\Driver::_destruct()中，关闭了PDO连接。 代码的意思，就是给 PDO 赋 null 值，就能被关闭。是的。 ","date":"2022-08-19","objectID":"/posts/2022/tp3.2deyihuo/:1:0","tags":["thinkphp","pdo","mysql"],"title":"ThinkPHP3.2的疑惑","uri":"/posts/2022/tp3.2deyihuo/"},{"categories":["ThinkPHP"],"content":"给 PDO 连接关闭的两种方式 关闭 PDO 连接 2 种方式，其中一种就是赋值 null。手册里也是这么说的。另一种方式是，别管他，等 PHP 进程执行完毕，自动关闭。 总结就是一种显式关闭连接，也叫主动关闭连接，另一种是隐式关闭，也叫被动关闭，哈哈自己总结的，官方没这么说。 ==注意==：给 PDO 赋值 null 后，并不是脚本执行完，连接才关闭，而是赋值 null 后，立即关闭。我真实测试过。也发现当变量被赋值 null 后，内存就会被回收了。 ","date":"2022-08-19","objectID":"/posts/2022/tp3.2deyihuo/:1:1","tags":["thinkphp","pdo","mysql"],"title":"ThinkPHP3.2的疑惑","uri":"/posts/2022/tp3.2deyihuo/"},{"categories":["HTTP"],"content":"[TOC] 在 HTTP 协议眼里只有字符串，没有所谓的表单数组，至于你要解析成表单数组，那是服务器代码的一厢情愿。 ","date":"2022-08-19","objectID":"/posts/http/biaodanshuzu/:0:0","tags":["Html","form","表单","数组"],"title":"表单数组","uri":"/posts/http/biaodanshuzu/"},{"categories":["HTTP"],"content":"数据格式 HTML 表单发送数组数据： \u003cform action=\"\"\u003e \u003cinput type=\"text\" name=\"user[0][name]\" value=\"xiaoming\"\u003e \u003cinput type=\"text\" name=\"user[0][age]\" value=\"20\"\u003e \u003cinput type=\"text\" name=\"user[1][name]\" value=\"lihua\"\u003e \u003cinput type=\"text\" name=\"user[1][age]\" value=\"22\"\u003e \u003cinput type=\"text\" name=\"user[2][name]\" value=\"wanggang\"\u003e \u003cinput type=\"text\" name=\"user[2][age]\" value=\"19\"\u003e \u003c/form\u003e ","date":"2022-08-19","objectID":"/posts/http/biaodanshuzu/:1:0","tags":["Html","form","表单","数组"],"title":"表单数组","uri":"/posts/http/biaodanshuzu/"},{"categories":["HTTP"],"content":"PHP 接收到的数据 // 打印获取到的数据 var_dump($_POST); array(1) { [\"user\"]=\u003e array(3) { [0]=\u003e array(2) { [\"name\"]=\u003e string(8) \"xiaoming\" [\"age\"]=\u003e string(2) \"20\" } [1]=\u003e array(2) { [\"name\"]=\u003e string(5) \"lihua\" [\"age\"]=\u003e string(2) \"22\" } [2]=\u003e array(2) { [\"name\"]=\u003e string(8) \"wanggang\" [\"age\"]=\u003e string(2) \"19\" } } } ","date":"2022-08-19","objectID":"/posts/http/biaodanshuzu/:1:1","tags":["Html","form","表单","数组"],"title":"表单数组","uri":"/posts/http/biaodanshuzu/"},{"categories":["HTTP"],"content":"Java 接收到的数据 { \"args\": {}, \"data\": \"\", \"files\": {}, \"form\": { \"user[0][age]\": \"20\", \"user[0][name]\": \"xiaoming\", \"user[1][age]\": \"22\", \"user[1][name]\": \"lihua\", \"user[2][age]\": \"19\", \"user[2][name]\": \"wanggang\" }, \"headers\": { \"Accept\": \"*/*\", \"Accept-Encoding\": \"gzip, deflate, br\", \"Content-Length\": \"161\", \"Content-Type\": \"application/x-www-form-urlencoded\", \"Host\": \"httpbin.org\", \"Postman-Token\": \"97f65f22-18c0-404c-bf43-097274ec575d\", \"User-Agent\": \"PostmanRuntime/7.28.3\", \"X-Amzn-Trace-Id\": \"Root=1-62fef6e3-602efcd14413700f76a3a573\" }, \"json\": null, \"origin\": \"113.111.187.215\", \"url\": \"https://httpbin.org/post\" } ","date":"2022-08-19","objectID":"/posts/http/biaodanshuzu/:1:2","tags":["Html","form","表单","数组"],"title":"表单数组","uri":"/posts/http/biaodanshuzu/"},{"categories":["HTTP"],"content":"问题 看到这里，大家会觉得，表单提交的就是数组啊，为何 PHP 拿到请求数据就能获得数组，而 Java 却不能呢。 需要强调的是，根本没有什么数组，HTTP 协议传输的就是字符串。上面的数据在 HTTP 报文中，其实传递的是这样的字符串。 user%5B0%5D%5Bname%5D=xiaoming\u0026user%5B0%5D%5Bage%5D=20\u0026user%5B1%5D%5Bname%5D=lihua\u0026user%5B1%5D%5Bage%5D=22\u0026user%5B2%5D%5Bname%5D=wanggang\u0026user%5B2%5D%5Bage%5D=19 上面的数据还不够明显，因为请求参数被==urlencode==了，我解码下。 user[0][name]=xiaoming\u0026user[0][age]=20\u0026user[1][name]=lihua\u0026user[1][age]=22\u0026user[2][name]=wanggang\u0026user[2][age]=19 ==总结==：其实user[0][name]这种格式的数据就是字符串，只不过 PHP 故意对其进行处理，将其解析成了数组。 你甚至可以跟表单约定传user.0.name这种格式的数据，你将其解析成数组也是可以的。 ","date":"2022-08-19","objectID":"/posts/http/biaodanshuzu/:1:3","tags":["Html","form","表单","数组"],"title":"表单数组","uri":"/posts/http/biaodanshuzu/"},{"categories":["HTTP"],"content":"验证 我们上面猜想 PHP 其实接到的参数就是字符串，没有所谓的数组。也可以编码进行验证。 var_dump(file_get_contents('php://input')); string(113) \"user[0][name]=xiaoming\u0026user[0][age]=20\u0026user[1][name]=lihua\u0026user[1][age]=22\u0026user[2][name]=wanggang\u0026user[2][age]=19\" ","date":"2022-08-19","objectID":"/posts/http/biaodanshuzu/:1:4","tags":["Html","form","表单","数组"],"title":"表单数组","uri":"/posts/http/biaodanshuzu/"},{"categories":["四十二章经"],"content":"区别 概念 说明 指针 变量在内存中的地址，C，C++ 在使用，再高级点的语言，抛弃了，因为管理内存地址很麻烦。 传值 传值很简单，就是将其他变量的值拷贝一个副本给本变量。 需要注意的是有些语言存在常量池，也就是并未拷贝值副本。 在 PHP 语言中，除了对象，其他变量都是传值。 在 Java 中，8 种基本数据类型都是传值。 引用 在 PHP 中存在引用，引用可以认为是指针，但是却又不能进行指针运算。 同一个引用的变量，一改全改。 地址值 在 Java 中出现地址，其实也是传值，不过传的指针的地址值。 同一个地址值的变量，存在重新赋值时，不会像 PHP 那样一改全改。 ==注意==：地址 = 指针，地址值 ≠ 地址，地址值 = 指针的地址。 ","date":"2022-08-19","objectID":"/posts/2022/zhizhendizhiyinyong/:1:0","tags":["指针","引用","传值","地址"],"title":"地址，指针与引用","uri":"/posts/2022/zhizhendizhiyinyong/"},{"categories":["四十二章经"],"content":"传值 传值很简单，就是将基本数据类型的值拷贝一份副本。 ","date":"2022-08-19","objectID":"/posts/2022/zhizhendizhiyinyong/:1:1","tags":["指针","引用","传值","地址"],"title":"地址，指针与引用","uri":"/posts/2022/zhizhendizhiyinyong/"},{"categories":["四十二章经"],"content":"引用 下面的代码都是在测试框架下，验证，TDL（Test Drive Learn） $var1 = 'no'; // 引用赋值 $var2 = \u0026$var1; $var2 = 'yes'; $var3 = \u0026$var2; self::assertSame('yes', $var2); self::assertSame('yes', $var1); // 将变量名与引用解绑 unset($var2); self::assertSame('yes', $var1); self::assertSame('yes', $var3); // 将引用对应的数据清空，一改全改，改了 $val3，$val1 也被改了，因为相同引用 $var3 = null; self::assertNull($var3); self::assertNull($var1); PHP 手册 引用定位 ","date":"2022-08-19","objectID":"/posts/2022/zhizhendizhiyinyong/:1:2","tags":["指针","引用","传值","地址"],"title":"地址，指针与引用","uri":"/posts/2022/zhizhendizhiyinyong/"},{"categories":["四十二章经"],"content":"地址值 Java 中的地址值传递。 Integer a = 1; Integer b = a; // 这里只是将 b 与 1 解绑，与 2 地址值绑定 b = 2; Assert.assertTrue(b.equals(2)); Assert.assertTrue(a.equals(1)); // 将 b 与 2 的地址值解绑 b = null; Assert.assertNull(b); Assert.assertTrue(a.equals(1)); Integer c = 1; Integer d = c; // 这里只是将 c 与 1 解绑，与 2 地址值绑定 // c 与 1 的地址值解绑，并不影响 d c = 2; Assert.assertTrue(c.equals(2)); Assert.assertTrue(d.equals(1)); // 将 c 与 2 的地址值解绑 c = null; Assert.assertNull(c); Assert.assertTrue(d.equals(1)); ","date":"2022-08-19","objectID":"/posts/2022/zhizhendizhiyinyong/:1:3","tags":["指针","引用","传值","地址"],"title":"地址，指针与引用","uri":"/posts/2022/zhizhendizhiyinyong/"},{"categories":["四十二章经"],"content":"总结 通过上面代码我们可以得出结论，PHP 中的对象才是真正的引用传递。而 Java 中的非基本数据类型传递的不是引用，而是引用的地址值，或者说是引用的地址值的副本。 PHP 中将$var3置null，导致$val2和$val1都为null。因为他们是引用，是地址，是指针。 Java 中b，c置null，而a和d的值却没有变。因为他们都是地址值，是指针的地址。 ","date":"2022-08-19","objectID":"/posts/2022/zhizhendizhiyinyong/:2:0","tags":["指针","引用","传值","地址"],"title":"地址，指针与引用","uri":"/posts/2022/zhizhendizhiyinyong/"},{"categories":["git","工具"],"content":"commit 规范 标识 描述 feat 新功能feature fix 修补bug docs 开发文档变动 style 代码格式变动，无代码变动，比如格式化了代码 refactor 重构业务，既不是新增功能，也不是修复bug test 增加测试用例 chore 脚手架工具变动，无业务代码变动 ","date":"2022-08-18","objectID":"/posts/2022/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:0","tags":["git","规范","仓库"],"title":"Git学习笔记","uri":"/posts/2022/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["设计模式"],"content":"值对象（Value Object） 即没有唯一标识 id 的对象，例如颜色，长短，价格 实体 有唯一标识的对象，比如某个用户，某个商品。但是用户的高矮，胖瘦；商品的颜色，尺寸，价格就是值对象。 领域服务（领域对象 domain object） 领域服务是没有任何属性（无状态）的对象，只有方法，这些方法仅描述如何解决领域问题。 领域对象的创建，使用工厂来创建。 聚合 聚合根 聚合根之间的通信，使用事件。 领域模型的目标：让技术复杂性和业务复杂性分割开，那么如何分割开呢？我们将领域模型划分到领域层，底层技术实现划分到基础层。 ","date":"2022-08-17","objectID":"/posts/2022/ddd/:0:0","tags":["DDD","领域驱动设计"],"title":"领域驱动设计实现","uri":"/posts/2022/ddd/"},{"categories":["设计模式"],"content":"分层 层 操作 用户接口层 应用层 领域层 基础设施层 数据驱动，Mapper，DTO，PO ","date":"2022-08-17","objectID":"/posts/2022/ddd/:1:0","tags":["DDD","领域驱动设计"],"title":"领域驱动设计实现","uri":"/posts/2022/ddd/"},{"categories":["设计模式"],"content":"疑惑 你以为分层后，能避免耦合，不会跨层调用 错，DDD 分层后，上层可以跨层调用下层。是不是有点晕了，这其实也是为了灵活和变通。 举个例子： 需要你输出一个接口，返回配置表的数据。我认为你应该是在controller直接查库返回，而不是再封装一个dao，service。 灵活高效，特事特办。 分层 ","date":"2022-08-17","objectID":"/posts/2022/ddd/:2:0","tags":["DDD","领域驱动设计"],"title":"领域驱动设计实现","uri":"/posts/2022/ddd/"},{"categories":["心得"],"content":"多阅读别人的代码 多阅读距离你最近的人的代码，比如同事的代码呀。 ","date":"2022-08-17","objectID":"/posts/2022/ruhetigao/:1:0","tags":["提高","总结"],"title":"自我提高","uri":"/posts/2022/ruhetigao/"},{"categories":["心得"],"content":"如何做晋升述职 作者在阿里巴巴已经做了好几年的晋升评委，发现很多同学都缺乏结构化思维，冗长的 PPT 里，却不能很好的把一件事情说清楚。实际上在做工作汇报或者述职的时候，是很容易结构化的。 最清晰、最实用的结构化表达是：提出问题，定义问题，分析问题，解决问题，最后展望未来。 如果按照这个逻辑顺序去阐述一件事情，会比不知道这个“套路”写出来的东西，要好的多。这也是麦肯锡常用的解决问题的框架。 ———————————————— 版权声明：本文为CSDN博主「张建飞（Frank）」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/significantfrank/article/details/101095176 ","date":"2022-08-17","objectID":"/posts/2022/ruhetigao/:2:0","tags":["提高","总结"],"title":"自我提高","uri":"/posts/2022/ruhetigao/"},{"categories":["MQ","消息队列"],"content":"安装 安装容器 docker run -d --name es -p 9200:9200 -p 9300:9300 -e \"discovery.type=single-node\" -e ES_JAVA_OPTS=\"-Xms512m -Xmx512m\" elasticsearch:8.3.3 进入容器 docker exec -it es /bin/bash ","date":"2022-08-15","objectID":"/posts/2022/rabbitmq/:1:0","tags":["RabbitMQ","MQ","Kafka","ActiveMQ","Beanstalk"],"title":"RabbitMQ 笔记","uri":"/posts/2022/rabbitmq/"},{"categories":["MQ","消息队列"],"content":"应用场景 ","date":"2022-08-15","objectID":"/posts/2022/rabbitmq/:2:0","tags":["RabbitMQ","MQ","Kafka","ActiveMQ","Beanstalk"],"title":"RabbitMQ 笔记","uri":"/posts/2022/rabbitmq/"},{"categories":["MQ","消息队列"],"content":"消息分发策略 消息流转 简单模式 路由模式 通配符模式 发布订阅模式 工作队模式 ","date":"2022-08-15","objectID":"/posts/2022/rabbitmq/:3:0","tags":["RabbitMQ","MQ","Kafka","ActiveMQ","Beanstalk"],"title":"RabbitMQ 笔记","uri":"/posts/2022/rabbitmq/"},{"categories":["规约","Java基础"],"content":"约定大于配置，配置大于编码。 ","date":"2022-08-15","objectID":"/posts/yueding/bianchengguiyue/:0:0","tags":["规范","锲约","Java"],"title":"编程规约","uri":"/posts/yueding/bianchengguiyue/"},{"categories":["规约","Java基础"],"content":"关键字顺序 示例 描述 @Override public ==abstract== void service(ServletRequest req, ServletResponse res) throws ServletException, IOException; 抽象方法 private static final long serialVersionUID = 1L; private static final long serialVersionUID = 8294180014912103005L; 类常量，非大写 private static ==final== String METHOD_POST = “POST”; 类常量，大写 public static void main(String[] args) {} main方法 private ==transient== String password; 禁止序列化某个属性，这样能保证序列化后存放的内容里无 transient 修饰的内容 public ==default== void sessionDestroyed(HttpSessionEvent se) {} JDK1.8 引入，接口的默认实现，空方法体 protected void finalize() throws Throwable {} 类的析构方法 public final ==synchronized== void setName(String name) {} 设置线程名称 private ==volatile== boolean flag = false; 使用 volatile 修饰线程共享变量 public ==synchronized== StringBuffer append(String str) {} 同步方法 总结顺序：[public|protected|private] [static] [final|default|transient|abstract] [synchronized] [返回值类型|变量类型] 第一个修饰符必须是访问修饰符 public|protected|private 最后一个修饰符必须是变量类型/返回值类型修饰符 static final final synchronized ","date":"2022-08-15","objectID":"/posts/yueding/bianchengguiyue/:1:0","tags":["规范","锲约","Java"],"title":"编程规约","uri":"/posts/yueding/bianchengguiyue/"},{"categories":["规约","Java基础"],"content":"方法起名 见名知意 \u003e 方法名长度 业务 方法名 名画名嘴 建造者模式的建造输出 build() 获取当前类的实例 getInstance() 获取当前类的单例 getSingleton() SLF4J框架中的org/slf4j/impl/StaticLoggerBinder.getSingleton() Dao层查询数据 findByXxx() / selectByXxx Service层查询数据 getXxx() / listXxx() ","date":"2022-08-15","objectID":"/posts/yueding/bianchengguiyue/:2:0","tags":["规范","锲约","Java"],"title":"编程规约","uri":"/posts/yueding/bianchengguiyue/"},{"categories":["规约","Java基础"],"content":"增删改查 业务 方法前缀 增 createXXX() 删 基础层使用 deleteXXX()，业务层使用 removeXXX() 改 updateXXX() 查 查 1 条 findOne()/查多条 findAll() ","date":"2022-08-15","objectID":"/posts/yueding/bianchengguiyue/:2:1","tags":["规范","锲约","Java"],"title":"编程规约","uri":"/posts/yueding/bianchengguiyue/"},{"categories":["规约","Java基础"],"content":"不同层的区别 在 infrastructure 基础层，下单就是createOrder很简单明了，但是在业务层，就应该按业务术语来，而不是有 CURD 的影子，例如叫placeOrder。 取消订单，基础层就是deleteOrder，业务层cancelOrder。 Tips：在业务层，尽量避免 CRUD，努力找到更好的业务词汇来表达业务语义，如果非用不可，请使用约定好的 CRUD 命名。 ","date":"2022-08-15","objectID":"/posts/yueding/bianchengguiyue/:2:2","tags":["规范","锲约","Java"],"title":"编程规约","uri":"/posts/yueding/bianchengguiyue/"},{"categories":["规约","Java基础"],"content":"大咖秀 我们在规范自己代码风格的同时，还要有一颗包容的♥。 ","date":"2022-08-15","objectID":"/posts/yueding/bianchengguiyue/:3:0","tags":["规范","锲约","Java"],"title":"编程规约","uri":"/posts/yueding/bianchengguiyue/"},{"categories":["规约","Java基础"],"content":"不整洁的代码 Java 源码 java.lang.Class，产于 1994, 2014 ","date":"2022-08-15","objectID":"/posts/yueding/bianchengguiyue/:3:1","tags":["规范","锲约","Java"],"title":"编程规约","uri":"/posts/yueding/bianchengguiyue/"},{"categories":["规约","Java基础"],"content":"应用设计 在设计开发一个系统时，可以分为三层，各层关注点不同： 高层：架构设计 中层：设计原则、设计模式 底层：代码整洁之道 ","date":"2022-08-15","objectID":"/posts/yueding/bianchengguiyue/:4:0","tags":["规范","锲约","Java"],"title":"编程规约","uri":"/posts/yueding/bianchengguiyue/"},{"categories":["规约","Java基础"],"content":"常量写左边的好处 来自 chatgpt 的回答： 避免赋值误写为比较：将常量写在左边可以避免在比较时将赋值操作误写为比较操作，因为在大多数编程语言中，赋值操作的返回值是被赋的值，而不是布尔值。 提高代码可读性：将常量写在左边可以使代码更易读，因为常量通常是程序员自己定义的，而变量则可能是从其他地方传入的，将常量写在左边可以更清晰地表达程序员的意图。 提高代码效率：将常量写在左边可以提高代码的执行效率，因为在大多数编程语言中，将常量写在左边可以避免进行类型转换，从而减少了代码的执行时间。 ","date":"2022-08-15","objectID":"/posts/yueding/bianchengguiyue/:5:0","tags":["规范","锲约","Java"],"title":"编程规约","uri":"/posts/yueding/bianchengguiyue/"},{"categories":["NoSQL"],"content":"[TOC] Redis复习笔记 ","date":"2022-08-01","objectID":"/posts/database/redisfuxibiji/:0:0","tags":["redis","nosql"],"title":"Redis复习笔记","uri":"/posts/database/redisfuxibiji/"},{"categories":["NoSQL"],"content":"数据类型 数据类型 特点 添加 删除 修改 查询 string（字符串） 二进制安全，可存图片 一个字符串最大能存512MB的内容 set del set get list（列表） 列表里都是按插入顺序存储的字符串string类型 一个列表能存储2^32-1=42亿9496万7295个字符串 rpush/lpush rpop/lpop set（无序集合） 集合里的元素都是string类型 集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1) sadd srem spop/srandmember/smembers zset（有序集合） zadd 添加存在的元素时会返回 0 ，但是会更新 score zrem zrange hash（哈希表） 一个哈希能存2^32-1=42亿9496万7295个键值对 hset hdel hget hgetall 获取哈希表中的所有键值对 publish/subscribe（发布/订阅） stream Redis 5.0 新增的数据结构 主要用于消息队列 HyperLogLog（用来做基数统计的算法） 基数统计就是统计不重复数据的个数 pfadd 基数表名 元素 pfcount 基数表名 即可统计里面不重复元素的个数 ","date":"2022-08-01","objectID":"/posts/database/redisfuxibiji/:1:0","tags":["redis","nosql"],"title":"Redis复习笔记","uri":"/posts/database/redisfuxibiji/"},{"categories":["NoSQL"],"content":"Redis Stream 官网说他是一种新型数据结构，Redis 5.0 才引入。可用来做消息队列，弥补发布/订阅数据结构的，因为发布订阅不支持消息持久化，断网宕机都会造成未被消费的消息丢失。 特点 未被 ACK 的消息支持持久化 支持为消费者分组，类似于为队列 Queue 绑定 Topic 消费组负责消费消息，并移动游标last_delivered_id，每一个消费者同时用pending_ids维护消费组获取的消息但是没有消费完执行 ACK 的消息 命令 发布消息 xadd 文档名 记录的自增id 记录字段1 记录值1 记录字段2 记录值2，*代表系统指定自增id，每次执行完，系统会返回新增记录的自增 id。 \u003e xadd stream * name tony age 23 1662448868097-0 \u003e xadd stream * color red status off 1662448921552-0 看看添加后的效果，就知道为啥将其类比MongoDb的文档而不是结构化数据库的表了。因为其数据没有MySQl之类的表字段结构限制。 常用命令 命令 描述 ==xadd== stream_key * filed1 value1 … 添加记录 ==xlen== stream_key 获取 stream_key 流中记录的总数 ==xdel== stream_key 记录主键 id 删除 stream_key 流中某个主键 id 对应的记录 ==xrange== stream_key - + 获取 stream_key 流中的所有记录，- 表示最小主键 id， + 表示最大 ==xrange== stream_key - + count 3 获取指定数量的 stream_key 流中的数据列表 ==xinfo stream== stream_key 查看 stream_key 的信息 ==xgroup create== stream_key consumer1 $ 创建消费组 consumer1 绑定消息队列 stream_key ==xreadgroup group== consumer1 cli ==count== 1 ==streams== stream_key \u003e 消费者读取消息 ==xack== stream_key consumer1 1662453607729-0 消费者 ACK 消息 1662453607729-0 Redis 生成的自增 id 的含义 1662448868097-0其格式即添加时的毫秒数-同毫秒时并发生成的第几条。 ","date":"2022-08-01","objectID":"/posts/database/redisfuxibiji/:1:1","tags":["redis","nosql"],"title":"Redis复习笔记","uri":"/posts/database/redisfuxibiji/"},{"categories":["NoSQL"],"content":"应用场景 ","date":"2022-08-01","objectID":"/posts/database/redisfuxibiji/:2:0","tags":["redis","nosql"],"title":"Redis复习笔记","uri":"/posts/database/redisfuxibiji/"},{"categories":["NoSQL"],"content":"缓存 ","date":"2022-08-01","objectID":"/posts/database/redisfuxibiji/:2:1","tags":["redis","nosql"],"title":"Redis复习笔记","uri":"/posts/database/redisfuxibiji/"},{"categories":["NoSQL"],"content":"分布式锁 ","date":"2022-08-01","objectID":"/posts/database/redisfuxibiji/:2:2","tags":["redis","nosql"],"title":"Redis复习笔记","uri":"/posts/database/redisfuxibiji/"},{"categories":["NoSQL"],"content":"数据类型 ","date":"2022-08-01","objectID":"/posts/database/redisfuxibiji/:3:0","tags":["redis","nosql"],"title":"Redis复习笔记","uri":"/posts/database/redisfuxibiji/"},{"categories":["NoSQL"],"content":"字符串 ","date":"2022-08-01","objectID":"/posts/database/redisfuxibiji/:3:1","tags":["redis","nosql"],"title":"Redis复习笔记","uri":"/posts/database/redisfuxibiji/"},{"categories":["NoSQL"],"content":"队列 ","date":"2022-08-01","objectID":"/posts/database/redisfuxibiji/:3:2","tags":["redis","nosql"],"title":"Redis复习笔记","uri":"/posts/database/redisfuxibiji/"},{"categories":["NoSQL"],"content":"安全 大写为命令 ","date":"2022-08-01","objectID":"/posts/database/redisfuxibiji/:4:0","tags":["redis","nosql"],"title":"Redis复习笔记","uri":"/posts/database/redisfuxibiji/"},{"categories":["NoSQL"],"content":"检查 Redis 是否设置了密码 \u003e CONFIG get requirepass requirepass ","date":"2022-08-01","objectID":"/posts/database/redisfuxibiji/:4:1","tags":["redis","nosql"],"title":"Redis复习笔记","uri":"/posts/database/redisfuxibiji/"},{"categories":["NoSQL"],"content":"设置密码 CONFIG set requirepass \"abc123\" ","date":"2022-08-01","objectID":"/posts/database/redisfuxibiji/:4:2","tags":["redis","nosql"],"title":"Redis复习笔记","uri":"/posts/database/redisfuxibiji/"},{"categories":["NoSQL"],"content":"验证密码 AUTH \"abc123\" ","date":"2022-08-01","objectID":"/posts/database/redisfuxibiji/:4:3","tags":["redis","nosql"],"title":"Redis复习笔记","uri":"/posts/database/redisfuxibiji/"},{"categories":["NoSQL"],"content":"分区 分区有点类似分布式，就是将 Redis 中的数据分到不同的 Redis 服务器上。 优点： 提高了内存和带宽 缺点： 分布在不同主机上 set 没法做集合运算。 ","date":"2022-08-01","objectID":"/posts/database/redisfuxibiji/:5:0","tags":["redis","nosql"],"title":"Redis复习笔记","uri":"/posts/database/redisfuxibiji/"},{"categories":["NoSQL"],"content":"分区类型 水平分区 按照用户 id 所属的范围进行分区，使其分布在不同的 Redis 主机上。 Hash分区 先对 key 进行 hash 计算，得到的整数，再对主机数量取模运算，得出数据位于那台机器上。 例如：xiaoming_session_id 进行哈希运算得到整数 10，我们有 4 台 Redis 主机，10 % 4 = 2，所以我们应该去 Redis 主机编号为 2 的实例上去查询 xiaoming_session_id。 ","date":"2022-08-01","objectID":"/posts/database/redisfuxibiji/:5:1","tags":["redis","nosql"],"title":"Redis复习笔记","uri":"/posts/database/redisfuxibiji/"},{"categories":["NoSQL"],"content":"衍生问题 ","date":"2022-08-01","objectID":"/posts/database/redisfuxibiji/:6:0","tags":["redis","nosql"],"title":"Redis复习笔记","uri":"/posts/database/redisfuxibiji/"},{"categories":["NoSQL"],"content":"如何确保缓存与数据库数据的一致性 延迟双删：先删除缓存，更新数据库，完事再删除缓存。这种操作只能尽最大努力保证可靠，就像 TCP 3 次握手，4 次挥手一样，都是尽最大努力。 ","date":"2022-08-01","objectID":"/posts/database/redisfuxibiji/:6:1","tags":["redis","nosql"],"title":"Redis复习笔记","uri":"/posts/database/redisfuxibiji/"},{"categories":["PHP"],"content":"输出控制 函数 清空缓冲区 刷出缓冲区内容 返回缓冲区内容 关闭缓冲区 ob_clean 是 否 否 否 ob_end_clean 是 否 否 是 ob_end_flush 否 是 否 是 ob_flush 否 是 否 否 ob_get_clean 是 否 是 是 ob_get_contents 否 否 是 否 ob_get_flush 否 是 是 是 注意: 输出缓冲区的内容一旦被刷出后, 将不再存在 ","date":"2021-11-27","objectID":"/posts/php/php%E8%BE%93%E5%87%BA%E6%8E%A7%E5%88%B6%E5%87%BD%E6%95%B0/:1:0","tags":["php","flush","输入输出控制"],"title":"PHP输出控制函数","uri":"/posts/php/php%E8%BE%93%E5%87%BA%E6%8E%A7%E5%88%B6%E5%87%BD%E6%95%B0/"},{"categories":["Java基础"],"content":" Servlet 是 Server Applet 的缩写，译为“服务器端小程序”，是一种使用 Java 语言来开发动态网站的技术。 使用原生 Java 开发动态网站非常麻烦，需要自己解析 HTTP 请求的报头，需要自己分析用户的请求参数，需要自己加载数据库组件，种种原因导致使用原生 Java 开发动态网站几乎是一件不能被接受的事情。正是基于这种原因，Java 官方后来推出了 Servlet 技术，它对开发动态网站需要使用的原生 Java API 进行了封装，形成了一套新的 API，称为 Servlet API。 您可能还听说过 Applet，它和 Servlet 是相对的： Java Servlet 是“服务器端小程序”，运行在服务器上，用来开发动态网站； Java Applet 是“客户端小程序”，一般被嵌入到 HTML 页面，运行在支持 Java 的浏览器中。 Applet 和 Servlet 都是基于 Java 的一种技术，功能都非常强大，但是 Applet 开发步骤繁杂，而且只能在安装 Java 虚拟机（JVM）的计算机上运行，现在已经被 JavaScript 全面替代，几乎没有人再学习 Applet。 ","date":"2021-03-01","objectID":"/posts/java%E5%9F%BA%E7%A1%80/servlet/:0:0","tags":["java","servlet"],"title":"Servlet","uri":"/posts/java%E5%9F%BA%E7%A1%80/servlet/"},{"categories":["Java基础"],"content":"演进 Servlet 是第 1 代 Java Web 开发技术 JSP 是第 2 代 Java Web 开发技术，因为 Servlet 将 HTML 代码以字符串的形式向外输出，编写 HTML 文档就是在拼接字符串，非常麻烦 学习 JSP 的顺序，Java =\u003e Servlet =\u003e JSP JSP 才是现代化的 Web 开发技术，它允许 HTML 代码和 JSP 代码分离，让程序员能够在 HTML 文档中直接嵌入 JSP 代码。 现在没有人直接使用 Servlet 开发动态网站，大家都转向了 JSP 阵营。但是 JSP 依赖于 Servlet，用户访问 JSP 页面时，JSP 代码会被翻译成 Servlet 代码，最终，HTML 代码还是以字符串的形式向外输出的。您看，JSP 只是在 Servlet 的基础上做了进一步封装。 JSP 代码可以调用 Servlet 类，程序员可以将部分功能在 Servlet 中实现，然后在 JSP 中调用即可。 总之，Servlet 是 JSP 的基础，Servlet 虽然不直接面向用户，但是它依然是 JSP 的后台支撑，想玩转 JSP，必须先玩转 Servlet。 ","date":"2021-03-01","objectID":"/posts/java%E5%9F%BA%E7%A1%80/servlet/:1:0","tags":["java","servlet"],"title":"Servlet","uri":"/posts/java%E5%9F%BA%E7%A1%80/servlet/"},{"categories":["Java基础"],"content":"Servlet框架调用 ","date":"2021-03-01","objectID":"/posts/java%E5%9F%BA%E7%A1%80/servlet/:2:0","tags":["java","servlet"],"title":"Servlet","uri":"/posts/java%E5%9F%BA%E7%A1%80/servlet/"},{"categories":["Java基础"],"content":"转发与重定向的区别 转发由分发器javax.servlet.RequestDispatcher#forward触发。 重定向由javax.servlet.http.HttpServletResponse#sendRedirect触发。 二者虽然都能使用页面发生跳转，但是原理不同： ","date":"2021-03-01","objectID":"/posts/java%E5%9F%BA%E7%A1%80/servlet/:3:0","tags":["java","servlet"],"title":"Servlet","uri":"/posts/java%E5%9F%BA%E7%A1%80/servlet/"},{"categories":["Java基础"],"content":"Session Servlet 容器为每一个浏览器创建一个 Session： javax.servlet.http.HttpServletRequest#getSession() ","date":"2021-03-01","objectID":"/posts/java%E5%9F%BA%E7%A1%80/servlet/:4:0","tags":["java","servlet"],"title":"Servlet","uri":"/posts/java%E5%9F%BA%E7%A1%80/servlet/"},{"categories":["Java基础"],"content":"过滤器javax.servlet.http.HttpFilter 类似一个钩子，就是对请求内容做处理：权限检查，记录请求日志，甚至可以修改javax.servlet.http.HttpServletRequest中的内容。 也可以修改页面 XxxServlet 的响应javax.servlet.http.HttpServletResponse，比如在响应头里添加X-Power-By: xxx公司，过滤敏感词 public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException; ","date":"2021-03-01","objectID":"/posts/java%E5%9F%BA%E7%A1%80/servlet/:5:0","tags":["java","servlet"],"title":"Servlet","uri":"/posts/java%E5%9F%BA%E7%A1%80/servlet/"},{"categories":["Java基础"],"content":"监听器javax.servlet.http.HttpSessionListener 常见的几种监听器： 监听器 触发场景 ServletContextListener#contextInitialized ServletContextListener#contextDestroyed Servlet 容器初始化和容器关闭时触发 2 个对应方法 HttpSessionListener 监听 HttpSession 的创建和销毁事件 ServletRequestListener 监听 ServletRequest 请求的创建和销毁事件 ServletRequestAttributeListener 监听 ServletRequest 请求的属性变化事件（即调用ServletRequest.setAttribute()方法） ServletContextAttributeListener 监听 ServletContext 的属性变化事件（即调用ServletContext.setAttribute()方法） ServletContext 还提供了动态添加 Servlet、Filter、Listener 等功能，它允许应用程序在运行期间动态添加一个组件，虽然这个功能不是很常用。 这是热加载技术吧。 监听器其实也是一个钩子，当执行相关标签方法时，就会触发对应的钩子方法。比如： 执行方法 被触发方法 认证成功，创建session javax.servlet.http.HttpServletRequest#getSession() javax.servlet.http.HttpSessionListener#sessionCreated 退出登录，销毁session javax.servlet.http.HttpSession#invalidate javax.servlet.http.HttpSessionListener#sessionDestroyed ","date":"2021-03-01","objectID":"/posts/java%E5%9F%BA%E7%A1%80/servlet/:6:0","tags":["java","servlet"],"title":"Servlet","uri":"/posts/java%E5%9F%BA%E7%A1%80/servlet/"},{"categories":["Java基础"],"content":"疑问 Servlet 基于 Java 语言开发，运行 Servlet 代码只用 JRE 还不行，因为不支持 Servlet 规范。那所谓的 Servlet 容器不就是框架吗？ 读者可能会提出疑问，我们自己编写的 Servlet 类为什么需要 Servlet 容器来管理呢？这是因为我们编写的 Servlet 类没有 main() 函数，不能独立运行，只能作为一个模块被载入到 Servlet 容器，然后由 Servlet 容器来实例化，并调用其中的方法。 ","date":"2021-03-01","objectID":"/posts/java%E5%9F%BA%E7%A1%80/servlet/:7:0","tags":["java","servlet"],"title":"Servlet","uri":"/posts/java%E5%9F%BA%E7%A1%80/servlet/"},{"categories":["Java基础"],"content":" 约定大于配置，配置大于编码。 日志是系统运行的“照妖镜”，通过它能够实时反映系统的运行状态。 ","date":"2021-03-01","objectID":"/posts/yueding/log/:0:0","tags":["日志","log","Java"],"title":"日志","uri":"/posts/yueding/log/"},{"categories":["Java基础"],"content":"日志的打印也需要设计 如果日志的打印不设计，就会出现以下问题： 开发者各自为政，日志怎么打全凭个人喜好，无统一的规范 打了一些毫无意义的日志，徒增日志文件大小 阅读日志的人不知日志中打印参数的含义，还要结合日志打印的位置→业务代码→参数位置→参数注释，来学习了解 ","date":"2021-03-01","objectID":"/posts/yueding/log/:1:0","tags":["日志","log","Java"],"title":"日志","uri":"/posts/yueding/log/"},{"categories":["Java基础"],"content":"When 什么时候打日志，当你需要日志才能定位生产环境的问题，而不是看代码猜测的时候，就是你需要打日志的时候。 ","date":"2021-03-01","objectID":"/posts/yueding/log/:2:0","tags":["日志","log","Java"],"title":"日志","uri":"/posts/yueding/log/"},{"categories":["Java基础"],"content":"HTTP/RPC接口调用时 接口调用无论是调用成功还是调用失败，均要打印请求和成功/失败响应日志。 ","date":"2021-03-01","objectID":"/posts/yueding/log/:2:1","tags":["日志","log","Java"],"title":"日志","uri":"/posts/yueding/log/"},{"categories":["Java基础"],"content":"程序抛出Exception时，不向上抛就打印异常堆栈 注意，不能记录异常日志后，继续向上抛异常。 但是接口调用除外，因为我们可能需要打印错误的响应报文后，再往上抛接口异常。 ","date":"2021-03-01","objectID":"/posts/yueding/log/:2:2","tags":["日志","log","Java"],"title":"日志","uri":"/posts/yueding/log/"},{"categories":["Java基础"],"content":"不太可能进入的条件分支，要打印条件值 例如年龄小于 0 的分支。 ","date":"2021-03-01","objectID":"/posts/yueding/log/:2:3","tags":["日志","log","Java"],"title":"日志","uri":"/posts/yueding/log/"},{"categories":["Java基础"],"content":"关键执行步骤和中间态 例如，优惠的计算和分发，每次达到的条件，和计算出的优惠。都要打日志，便于后续跟踪优惠的计算。 ","date":"2021-03-01","objectID":"/posts/yueding/log/:2:4","tags":["日志","log","Java"],"title":"日志","uri":"/posts/yueding/log/"},{"categories":["Java基础"],"content":"函数的入口和出口处 ","date":"2021-03-01","objectID":"/posts/yueding/log/:2:5","tags":["日志","log","Java"],"title":"日志","uri":"/posts/yueding/log/"},{"categories":["Java基础"],"content":"Where 什么地方打日志 容易发生扯皮地方 例如，调别人接口的地方，一定要MUST打日志，哪怕你现在对接，运行正常，谁能保证永远不出问题，一旦到时候出问题了，谁有日志，谁就有主导权，以日志服人。 看到有的文章说，接口日志对接调试的时候打，上线了就不需要打了。你能保证你对接完上线后，不改代码，你能保证别人不改吗？如果哪天报错了，你说别人的问题，别人让你提供现场日志，你说你没有？多么无力。 程序加载的地方 毕竟加载的程序，只会走一次，只需要打一次，就能方便后面定位错误，不信你看 SpringBoot 启动时就打了 INFO 类型的启动日志。 这里加载一次，指的是常驻内存的应用。 ","date":"2021-03-01","objectID":"/posts/yueding/log/:3:0","tags":["日志","log","Java"],"title":"日志","uri":"/posts/yueding/log/"},{"categories":["Java基础"],"content":"对接外部的接口的封装，必须打上下行日志，防扯皮 ","date":"2021-03-01","objectID":"/posts/yueding/log/:3:1","tags":["日志","log","Java"],"title":"日志","uri":"/posts/yueding/log/"},{"categories":["Java基础"],"content":"程序重要状态信息变化要记录，方便还原现场 ","date":"2021-03-01","objectID":"/posts/yueding/log/:3:2","tags":["日志","log","Java"],"title":"日志","uri":"/posts/yueding/log/"},{"categories":["Java基础"],"content":"系统出入口，重要方法出入口 记录输入和输出，方便定位。 ","date":"2021-03-01","objectID":"/posts/yueding/log/:3:3","tags":["日志","log","Java"],"title":"日志","uri":"/posts/yueding/log/"},{"categories":["Java基础"],"content":"任何发生异常的地方 任何异常都应该被记录。 ","date":"2021-03-01","objectID":"/posts/yueding/log/:3:4","tags":["日志","log","Java"],"title":"日志","uri":"/posts/yueding/log/"},{"categories":["Java基础"],"content":"很少可能走到的 else 分支 此 else 分支要记录。 ","date":"2021-03-01","objectID":"/posts/yueding/log/:3:5","tags":["日志","log","Java"],"title":"日志","uri":"/posts/yueding/log/"},{"categories":["Java基础"],"content":"耗时的任务执行要记录进度 ","date":"2021-03-01","objectID":"/posts/yueding/log/:3:6","tags":["日志","log","Java"],"title":"日志","uri":"/posts/yueding/log/"},{"categories":["Java基础"],"content":"What 打文件名和行号 为啥要打文件名和行号？通过错误描述不能定位吗？ 有时候我们的项目中会有很多的 copy 代码，甚至错误日志都 copy，别人 copy 了你的错误日志描述，到时候打出来了，算你的，没有文件名和行号，你要跟他扯皮吗。 打出问题的时间，最好精确到毫秒 并发性的问题，用秒做单位的时间，有时候真不好排错。 异常问题，打印异常堆栈 打上下文内容，如果不打上下文，就相当于报警说这家超市里有小偷，打了上下文就相当于报警说工号 007 的那位员工是小偷。上下文内容能帮你快速，准确地定位错误。 ","date":"2021-03-01","objectID":"/posts/yueding/log/:4:0","tags":["日志","log","Java"],"title":"日志","uri":"/posts/yueding/log/"},{"categories":["Java基础"],"content":"How 怎样打日志？ ","date":"2021-03-01","objectID":"/posts/yueding/log/:5:0","tags":["日志","log","Java"],"title":"日志","uri":"/posts/yueding/log/"},{"categories":["Java基础"],"content":"不使用具体的日志框架而是使用抽象的日志框架 import org.slf4j.Logger; import org.slf4j.LoggerFactory; private static final Logger logger = LoggerFactory.getLogger(Xxx.class); 即不使用logback，而使用slf4j。 ","date":"2021-03-01","objectID":"/posts/yueding/log/:5:1","tags":["日志","log","Java"],"title":"日志","uri":"/posts/yueding/log/"},{"categories":["Java基础"],"content":"系统程序错误是Error级别，用户参数错误是Warning级别 高效地打日志 对于 debug 日志级别日志，必须判断 debug 级别后才能打印日志 使用格式化的占位符打日志，而不是字符串拼接日志，占位符的效率远远高于拼接字符串 异常时不能打印完日志，再向上抛异常，向上的异常捕获者又打印了异常日志。应该交给异常的最终捕获处理者来打日志。 不要在循环中打印日志，最好的办法是在循环中统计单个日志，循环外打印统计的日志。跟不要在循环中执行 sql 一个道理。 禁止线上环境开启 debug 日志级别，因为除了你写了少部分的 debug 级别日志，可以你用的依赖库，框架可能写了大量的 debug 日志，这样会塞爆你的服务器的。 不要使用错误的日志级别，你在 info 日志文件中的打的 error 日志，同事在 error 日志文件中死活找不到。 不要使用 e.printStackTrace()，因为他的实现是打印日志到控制台，日志文件里是不会记录的 ","date":"2021-03-01","objectID":"/posts/yueding/log/:5:2","tags":["日志","log","Java"],"title":"日志","uri":"/posts/yueding/log/"},{"categories":["Java基础"],"content":"日志级别 ","date":"2021-03-01","objectID":"/posts/yueding/log/:5:3","tags":["日志","log","Java"],"title":"日志","uri":"/posts/yueding/log/"},{"categories":["Java基础"],"content":"日志格式 参数使用 {} 占位符，而不是字符串拼接，因为这样只有日志真正打印的时候，才会处理参数，降低了日志系统的负载 使用 [] 分隔参数，提高日志的可读性 每一个请求最好有一个 requestId，记入日志，同时记录线程名称 ","date":"2021-03-01","objectID":"/posts/yueding/log/:5:4","tags":["日志","log","Java"],"title":"日志","uri":"/posts/yueding/log/"},{"categories":["Java基础"],"content":"疑问 说打印日志时，不要直接 json 化对象，那么 LOG.error(“xxx”, exception) 中又传递对象，需要确认 error 的实现。 ","date":"2021-03-01","objectID":"/posts/yueding/log/:6:0","tags":["日志","log","Java"],"title":"日志","uri":"/posts/yueding/log/"},{"categories":["Java基础"],"content":"优雅的日志处理需求 能自动将异常错误,转换成对前端友好的错误输出，并记录调用栈和出错 能准确定位前端的错误提示对应的异常错误日志，以及请求参数 ","date":"2021-03-01","objectID":"/posts/yueding/log/:7:0","tags":["日志","log","Java"],"title":"日志","uri":"/posts/yueding/log/"},{"categories":["JavaScript"],"content":"javascript 三大类变量类型 3种基本数据类型 字符串(String) 数字(Number) 布尔(Boolean) 2种复合数据类型 对象(Object) 数组(Array) 2种特殊数据类型 Null undefined 除了 null undefined 没有 toString() 继承方法，其他变量类型都有。 对象的继承属性用 delete 删除表达式无法删除 ","date":"2018-03-02","objectID":"/posts/javascript/jsvariable/:1:0","tags":["js","变量","variable"],"title":"第一章","uri":"/posts/javascript/jsvariable/"},{"categories":["JavaScript"],"content":"引用传值 请注意在 js 中，数组和对象是引用传值的.那么问题来了,在赋值的时候出现了新的问题了,改变 A 值的同时也会改变 B 值. 解决办法: 深度复制法: var cloneObj = JSON.parse(JSON.stringify(obj)); 上面这种方法好处是非常简单易用，但是坏处也显而易见，这会抛弃对象的constructor，也就是深复制之后，无论这个对象原本的构造函数是什么，在深复制之后都会变成Object。另外诸如RegExp对象是无法通过这种方式深复制的。 ","date":"2018-03-02","objectID":"/posts/javascript/jsvariable/:2:0","tags":["js","变量","variable"],"title":"第一章","uri":"/posts/javascript/jsvariable/"},{"categories":["JavaScript"],"content":"历史 年份 名称 描述 1997 ECMAScript 1 First Edition. 1998 ECMAScript 2 Editorial changes only. 1999 ECMAScript 3 Added Regular Expressions. Added try/catch. ECMAScript 4 Was never released. 2009 ECMAScript 5 Added “strict mode”. Added JSON support. 2011 ECMAScript 5.1 Editorial changes. 2015 ECMAScript 6 Added classes and modules. 2016 ECMAScript 7 Added exponential operator (**). Added Array.prototype.includes. ","date":"2018-02-27","objectID":"/posts/javascript/javascripthistory/:1:0","tags":["js","javascript","历史"],"title":"JavaScript","uri":"/posts/javascript/javascripthistory/"},{"categories":["JavaScript"],"content":"声明 本书中凡是提到 ES2015 就是 ES6 的意思，二者等同 ","date":"2018-02-27","objectID":"/posts/javascript/javascripthistory/:2:0","tags":["js","javascript","历史"],"title":"JavaScript","uri":"/posts/javascript/javascripthistory/"},{"categories":["JavaScript"],"content":"历史 ES1.0 发布于1997年. ES2.0 发布于1998年6月. ES3.0 发布于1999年12月. ES4.0 草案发布于2007年10月. ES5.0 发布于2009年12月. ES6 起草于2000年,诞生于2015年6月,正式名称为 ECMAScript2015 标准. ","date":"2018-02-27","objectID":"/posts/javascript/javascripthistory/:3:0","tags":["js","javascript","历史"],"title":"JavaScript","uri":"/posts/javascript/javascripthistory/"},{"categories":["JavaScript"],"content":"Babel 转码器 Babel 是一个广泛使用的 ES6 转码器，可以将 ES6 代码转为 ES5 代码，从而在现有环境执行。这意味着，你可以用 ES6 的方式编写程序，又不用担心现有环境是否支持。 Babel 的配置文件是 .babelrc Babel 提供了一个在线编译器: REPL在线编译器 ","date":"2018-02-27","objectID":"/posts/javascript/javascripthistory/:3:1","tags":["js","javascript","历史"],"title":"JavaScript","uri":"/posts/javascript/javascripthistory/"},{"categories":["JavaScript"],"content":"ESLint 用于静态检查代码的语法和风格 ESLint 的配置文件是 .eslintrc ","date":"2018-02-27","objectID":"/posts/javascript/javascripthistory/:3:2","tags":["js","javascript","历史"],"title":"JavaScript","uri":"/posts/javascript/javascripthistory/"},{"categories":["JavaScript"],"content":"Mocha 一个测试框架 Mocha ES6 语法的测试脚本 ","date":"2018-02-27","objectID":"/posts/javascript/javascripthistory/:3:3","tags":["js","javascript","历史"],"title":"JavaScript","uri":"/posts/javascript/javascripthistory/"},{"categories":["JavaScript"],"content":"Traceur 是 Node 的一个模块 可以在控制台直接运行 ES6 语法的脚本。 ","date":"2018-02-27","objectID":"/posts/javascript/javascripthistory/:3:4","tags":["js","javascript","历史"],"title":"JavaScript","uri":"/posts/javascript/javascripthistory/"},{"categories":["JavaScript"],"content":"作用域提升 var 声明变量，会将变量提升到全局作用域或函数作用域的头部。 ","date":"2018-02-27","objectID":"/posts/javascript/basic/:1:0","tags":["var","作用域"],"title":"JavaScript var 作用域","uri":"/posts/javascript/basic/"},{"categories":["JavaScript"],"content":"暂时性死区 ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。 在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。 例如： // var 的情况 console.log(foo); // 输出undefined var foo = 2; // let 的情况 console.log(bar); // 报错ReferenceError let bar = 2; // 情况二 var tmp = 123; if (true) { tmp = 'abc'; // ReferenceError let tmp; } // 情况三 if (true) { // TDZ开始 tmp = 'abc'; // ReferenceError console.log(tmp); // ReferenceError let tmp; // TDZ结束 console.log(tmp); // undefined tmp = 123; console.log(tmp); // 123 } ","date":"2018-02-27","objectID":"/posts/javascript/basic/:2:0","tags":["var","作用域"],"title":"JavaScript var 作用域","uri":"/posts/javascript/basic/"},{"categories":["JavaScript"],"content":"块级作用域的写法 // IIFE 写法 (function () { var tmp = ...; ... }()); // 块级作用域写法 { let tmp = ...; ... } ","date":"2018-02-27","objectID":"/posts/javascript/basic/:3:0","tags":["var","作用域"],"title":"JavaScript var 作用域","uri":"/posts/javascript/basic/"},{"categories":["JavaScript"],"content":"块级作用域中的函数声明，ES6 支持 在 ES5 中，是不允许在块级作用域中声明函数的，但是为了兼容以前的旧代码，浏览器厂商没有遵守 ES5 的这一标准。 ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。 ","date":"2018-02-27","objectID":"/posts/javascript/basic/:4:0","tags":["var","作用域"],"title":"JavaScript var 作用域","uri":"/posts/javascript/basic/"},{"categories":["JavaScript"],"content":"块级作用域是语句 本质上，块级作用域是一个语句，将多个操作封装在一起，没有返回值。 例如：我们无法从下方代码块中获得计算返回值 { let t = f(); t = t * t + 1; } 那么如何获得上述块级作用域的计算结果，这时需要我们引入 do let x = do { let t = f(); t * t + 1; }; ","date":"2018-02-27","objectID":"/posts/javascript/basic/:5:0","tags":["var","作用域"],"title":"JavaScript var 作用域","uri":"/posts/javascript/basic/"},{"categories":["JavaScript"],"content":"const 声明常量 const声明一个只读的常量。一旦声明，常量的值就不能改变。 const PI = 3.1415; PI // 3.1415 PI = 3; // TypeError: Assignment to constant variable. const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。 const foo; // SyntaxError: Missing initializer in const declaration ","date":"2018-02-27","objectID":"/posts/javascript/basic/:6:0","tags":["var","作用域"],"title":"JavaScript var 作用域","uri":"/posts/javascript/basic/"},{"categories":["JavaScript"],"content":"codePointAt() JavaScript内部，字符以UTF-16的格式储存，每个字符固定为2个字节。对于那些需要4个字节储存的字符（Unicode码点大于0xFFFF的字符），JavaScript会认为它们是两个字符。 ","date":"2018-02-27","objectID":"/posts/javascript/basic/:7:0","tags":["var","作用域"],"title":"JavaScript var 作用域","uri":"/posts/javascript/basic/"},{"categories":["JavaScript"],"content":"判断某个方法是否存在 1). 方法一 if (typeof myMethod !== 'undefined' \u0026\u0026 myMethod instanceof Function) { console.log(myMethod, '是方法') } 2). 方法二 if (对象名.方法名) { } 3). 方法三 if (typeof(对象名.方法名) === 'function') { // 存在 } else { // 不存在 } ","date":"2017-12-30","objectID":"/posts/javascript/jsfunction/:0:1","tags":["js","function","方法"],"title":"方法","uri":"/posts/javascript/jsfunction/"}]